<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wadezhx.github.io/"/>
  <updated>2018-12-06T03:19:02.105Z</updated>
  <id>https://wadezhx.github.io/</id>
  
  <author>
    <name>wadezhx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式数据库</title>
    <link href="https://wadezhx.github.io/2018/12/06/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://wadezhx.github.io/2018/12/06/分布式数据库/</id>
    <published>2018-12-06T03:18:18.000Z</published>
    <updated>2018-12-06T03:19:02.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h1><p>分布式数据库是用计算机网络将物理上分散的多个数据库单元连接起来组成的一个逻辑上统一的数据库。每个被连接起来的数据库单元称为站点或节点。分布式数据库有一个统一的数据库管理系统来进行管理，称为分布式数据库管理系统。分布式数据库的基本特点包括：物理分布性、逻辑整体性和站点自治性。从这三个基本特点还可以导出的其它特点有：数据分布透明性、按既定协议达成共识的机制、适当的数据冗余度和事务管理的分布性。</p><p>这种组织数据库的方法克服了物理中心数据库组织的弱点。首先，降低了数据传送代价，因为大多数的对数据库的访问操作都是针对局部数据库的，而不是对其他位置的数据库访问；其次，系统的可靠性提高了很多，因为当网络出现故障时，仍然允许对局部数据库的操作，而且一个位置的故障不影响其他位置的处理工作，只有当访问出现故障位置的数据时，在某种程度上才受影响；第三，便于系统的扩充，增加一个新的局部数据库，或在某个位置扩充一台适当的小型计算机，都很容易实现。然而有些功能要付出更高的代价。例如，为了调配在几个位置上的活动，事务管理的性能比在中心数据库时花费更高，而且甚至抵消许多其他的优点。</p><p>分布式软件系统(Distributed Software Systems)是支持分布式处理的软件系统,是在由通信网络互联的多处理机体系结构上执行任务的系统。它包括分布式操作系统、分布式程序设计语言及其编译(解释)系统、分布式文件系统和分布式数据库系统等。</p><p>分布式操作系统负责管理分布式处理系统资源和控制分布式程序运行。它和集中式操作系统的区别在于资源管理、进程通信和系统结构等方面。 分布式程序设计语言用于编写运行于分布式计算机系统上的分布式程序。一个分布式程序由若干个可以独立执行的程序模块组成,它们分布于一个分布式处理系统的多台计算机上被同时执行。它与集中式的程序设计语言相比有三个特点：分布性、通信性和稳健性。 分布式文件系统具有执行远程文件存取的能力,并以透明方式对分布在网络上的文件进行管理和存取。 分布式数据库系统由分布于多个计算机结点上的若干个数据库系统组成,它提供有效的存取手段来操纵这些结点上的子数据库。分布式数据库在使用上可视为一个完整的数据库,而实际上它是分布在地理分散的各个结点上。当然,分布在各个结点上的子数据库在逻辑上是相关的。</p><p>Hadoop的分布式文件系统HDFS，作为开源的分布式平台，为目前流行的很多分布式数据库提供了支持，譬如HBase等。Yonghong的分布式文件系统ZFS，为分布式数据集市Z-DataMart提供了底层平台。</p><p>2<br>体系结构<br>编辑<br>根据我国制定的《分布式数据库系统标准》，分布式数据库系统抽象为4层的结构模式。这种结构模式得到了国内外的支持和认同。</p><p>4层模式划分为全局外层、全局概念层、局部概念层和局部内层，在各层间还有相应的层间映射。这种4层模式适用于同构型分布式数据库系统，也适用于异构型分布式数据库系统。</p><p>3<br>主要特点<br>编辑<br>· 多数处理就地完成；</p><p>· 各地的计算机由数据通信网络相联系；</p><p>· 克服了中心数据库的弱点：降低了数据传输代价；</p><p>· 提高了系统的可靠性，局部系统发生故障，其他部分还可继续工作；</p><p>· 各个数据库的位置是透明的，方便系统的扩充；</p><p>· 为了协调整个系统的事务活动，事务管理的性能花费高；</p><p>4<br>数据分配方式<br>编辑<br>（1）集中式：所有数据片段都安排在同一个场地上。</p><p>（2）分割式：所有数据只有一份，它被分割成若干逻辑片段，每个逻辑片段被指派在一个特定的场地上。</p><p>（3）全复制式：数据在每个场地重复存储。也就是每个场地上都有一个完整的数据副本。</p><p>（4）混合式：这是一种介乎于分割式和全复制式之间的分配方式。</p><p>目前分布式数据库分配的设计，越来越多的采用寻找最优解的算法，比如遗传算法、退火机制等</p><p>5<br>数据分片类型<br>编辑<br>（1）水平分片：按一定的条件把全局关系的所有元组划分成若干不相交的子集，每个子集为关系的一个片段。</p><p>（2）垂直分片：把一个全局关系的属性集分成若干子集，并在这些子集上作投影运算，每个投影称为垂直分片。</p><p>（3）导出分片：又称为导出水平分片，即水平分片的条件不是本关系属性的条件，而是其他关系属性的条件。</p><p>（4）混合分片：以上三种方法的混合。可以先水平分片再垂直分片，或先垂直分片再水平分片，或其他形式，但他们的结果是不相同的。</p><p>条件：</p><p>（1）完备性条件：必须把全局关系的所有数据映射到片段中，决不允许有属于全局关系的数据却不属于它的某一个片段。</p><p>（2）可重构条件：必须保证能够由同一个全局关系的各个片段来重建该全局关系。对于水平分片可用并操作重构全局关系；对于垂直分片可用联接操作重构全局关系。</p><p>（3）不相交条件：要求一个全局关系被分割后所得的各个数据片段互不重叠（对垂直分片的主键除外）。</p><p>6<br>查询优化<br>编辑<br>指在执行分布式查询时选择查询执行计划的方法和关系运算符的实现算法。根据系统环境的不同，查询优化所使用的算法也有所不同，通常分为远程广域网环境和高速局域网环境，其区别主要在网络的带宽。对于一元运算符可以采用集中式数据库中的查询优化方法。而对于二元运算符，由于涉及场地间的数据传输，因此必须考虑通信代价。分布式查询中常见的连接运算执行策略包括：</p><p>（1）半连接方法：利用半连接运算的转换方法R∞S=（RµS）∞S。假设场地1和场地2上分别有关系R和关系S，首先在S上执行连接属性上的投影并将结果传输至场地1，在场地1上执行关系R与投影的连接操作，再将结果传输至场地2与关系S执行连接操作。这种方法能够降低执行连接运算时的网络通信代价，主要适用于带宽较低的远程广域网络。</p><p>（2）枚举法方法：指枚举关系运算符的物理执行计划，通过对比执行计划的代价选择执行算法的方法。其中，连接运算符的物理执行计划包括嵌套循环方法、哈希连接法和归并连接法。枚举法主要适用于以磁盘IO代价为主的高速局域网环境。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式数据库&quot;&gt;&lt;a href=&quot;#分布式数据库&quot; class=&quot;headerlink&quot; title=&quot;分布式数据库&quot;&gt;&lt;/a&gt;分布式数据库&lt;/h1&gt;&lt;p&gt;分布式数据库是用计算机网络将物理上分散的多个数据库单元连接起来组成的一个逻辑上统一的数据库。每个被连接起来的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据结构中各种树</title>
    <link href="https://wadezhx.github.io/2018/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E5%90%84%E7%A7%8D%E6%A0%91/"/>
    <id>https://wadezhx.github.io/2018/12/06/数据结构中各种树/</id>
    <published>2018-12-06T02:48:13.000Z</published>
    <updated>2018-12-06T02:58:30.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构中各种树"><a href="#数据结构中各种树" class="headerlink" title="数据结构中各种树"></a>数据结构中各种树</h1><p>原文出处： Poll的笔记<br>数据结构中有很多树的结构，其中包括二叉树、二叉搜索树、2-3树、红黑树等等。本文中对数据结构中常见的几种树的概念和用途进行了汇总，不求严格精准，但求简单易懂。1. 二叉树<br>二叉树是数据结构中一种重要的数据结构，也是树表家族最为基础的结构。<br>二叉树的定义：二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2i-1个结点；深度为k的二叉树至多有2k-1个结点；对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。<br>二叉树的示例：</p><p>满二叉树和完全二叉树：<br>满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上。<br>满二叉树的性质：<br>1) 一颗树深度为h，最大层数为k，深度与最大层数相同，k=h;<br>2) 叶子数为2h;<br>3) 第k层的结点数是：2k-1;<br>4) 总结点数是：2k-1，且总节点数一定是奇数。<br>完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。<br>注：完全二叉树是效率很高的数据结构，堆是一种完全二叉树或者近似完全二叉树，所以效率极高，像十分常用的排序算法、Dijkstra算法、Prim算法等都要用堆才能优化，二叉排序树的效率也要借助平衡性来提高，而平衡性基于完全二叉树。</p><p>二叉树的性质：<br>1) 在非空二叉树中，第i层的结点总数不超过2i-1, i&gt;=1;<br>2) 深度为h的二叉树最多有2h-1个结点(h&gt;=1)，最少有h个结点;<br>3) 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1;<br>4) 具有n个结点的完全二叉树的深度为log2(n+1);<br>5)有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系：<br>若I为结点编号则 如果I&gt;1，则其父结点的编号为I/2；<br>如果2I&lt;=N，则其左儿子（即左子树的根结点）的编号为2I；若2I&gt;N，则无左儿子；<br>如果2I+1&lt;=N，则其右儿子的结点编号为2I+1；若2I+1&gt;N，则无右儿子。<br>6)给定N个节点，能构成h(N)种不同的二叉树，其中h(N)为卡特兰数的第N项，h(n)=C(2*n, n)/(n+1)。<br>7)设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和J=I+2i。2. 二叉查找树<br>二叉查找树定义：又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：<br>1) 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>2) 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；<br>3) 左、右子树也分别为二叉排序树；<br>4) 没有键值相等的节点。<br>二叉查找树的性质：对二叉查找树进行中序遍历，即可得到有序的数列。<br>二叉查找树的时间复杂度：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。<br>二叉查找树的高度决定了二叉查找树的查找效率。<br>二叉查找树的插入过程如下：<br>1) 若当前的二叉查找树为空，则插入的元素为根节点;<br>2) 若插入的元素值小于根节点值，则将元素插入到左子树中;<br>3) 若插入的元素值不小于根节点值，则将元素插入到右子树中。<br>二叉查找树的删除，分三种情况进行处理：<br>1) p为叶子节点，直接删除该节点，再修改其父节点的指针（注意分是根节点和不是根节点），如图a;<br>2) p为单支节点（即只有左子树或右子树）。让p的子树与p的父亲节点相连，删除p即可（注意分是根节点和不是根节点），如图b;<br>3) p的左子树和右子树均不空。找到p的后继y，因为y一定没有左子树，所以可以删除y，并让y的父亲节点成为y的右子树的父亲节点，并用y的值代替p的值；或者方法二是找到p的前驱x，x一定没有右子树，所以可以删除x，并让x的父亲节点成为y的左子树的父亲节点。如图c。</p><p>二叉树相关实现源码：<br>插入操作：</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60</p><p>struct node<br>{<br>    int val;<br>    pnode lchild;<br>    pnode rchild;<br>};</p><p>pnode BT = NULL;</p><p>//递归方法插入节点<br>pnode insert(pnode root, int x)<br>{<br>    pnode p = (pnode)malloc(LEN);<br>    p-&gt;val = x;<br>    p-&gt;lchild = NULL;<br>    p-&gt;rchild = NULL;<br>    if(root == NULL){<br>        root = p;<br>    }<br>    else if(x &lt; root-&gt;val){<br>        root-&gt;lchild = insert(root-&gt;lchild, x);<br>    }<br>    else{<br>        root-&gt;rchild = insert(root-&gt;rchild, x);<br>    }<br>    return root;<br>}</p><p>//非递归方法插入节点<br>void insert_BST(pnode q, int x)<br>{<br>    pnode p = (pnode)malloc(LEN);<br>    p-&gt;val = x;<br>    p-&gt;lchild = NULL;<br>    p-&gt;rchild = NULL;<br>    if(q == NULL){<br>        BT = p;<br>        return ;<br>    }<br>    while(q-&gt;lchild != p &amp;&amp; q-&gt;rchild != p){<br>        if(x &lt; q-&gt;val){<br>            if(q-&gt;lchild){<br>                q = q-&gt;lchild;<br>            }<br>            else{<br>                q-&gt;lchild = p;<br>            }<br>        }<br>        else{<br>            if(q-&gt;rchild){<br>                q = q-&gt;rchild;<br>            }<br>            else{<br>                q-&gt;rchild = p;<br>            }<br>        }<br>    }<br>    return;<br>}</p><p>删除操作：</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77</p><p>bool delete_BST(pnode p, int x) //返回一个标志，表示是否找到被删元素<br>{<br>    bool find = false;<br>    pnode q;<br>    p = BT;<br>    while(p &amp;&amp; !find){  //寻找被删元素<br>        if(x == p-&gt;val){  //找到被删元素<br>            find = true;<br>        }<br>        else if(x &lt; p-&gt;val){ //沿左子树找<br>            q = p;<br>            p = p-&gt;lchild;<br>        }<br>        else{   //沿右子树找<br>            q = p;<br>            p = p-&gt;rchild;<br>        }<br>    }<br>    if(p == NULL){   //没找到<br>        cout &lt;&lt; “没有找到” &lt;&lt; x &lt;&lt; endl;<br>    }</p><pre><code>if(p-&gt;lchild == NULL &amp;&amp; p-&gt;rchild == NULL){  //p为叶子节点    if(p == BT){  //p为根节点        BT = NULL;        }    else if(q-&gt;lchild == p){          q-&gt;lchild = NULL;    }            else{        q-&gt;rchild = NULL;        }    free(p);  //释放节点p}else if(p-&gt;lchild == NULL || p-&gt;rchild == NULL){ //p为单支子树    if(p == BT){  //p为根节点        if(p-&gt;lchild == NULL){            BT = p-&gt;rchild;            }            else{            BT = p-&gt;lchild;            }    }        else{        if(q-&gt;lchild == p &amp;&amp; p-&gt;lchild){ //p是q的左子树且p有左子树            q-&gt;lchild = p-&gt;lchild;    //将p的左子树链接到q的左指针上        }            else if(q-&gt;lchild == p &amp;&amp; p-&gt;rchild){            q-&gt;lchild = p-&gt;rchild;            }        else if(q-&gt;rchild == p &amp;&amp; p-&gt;lchild){            q-&gt;rchild = p-&gt;lchild;            }        else{            q-&gt;rchild = p-&gt;rchild;        }    }    free(p);}else{ //p的左右子树均不为空    pnode t = p;    pnode s = p-&gt;lchild;  //从p的左子节点开始    while(s-&gt;rchild){  //找到p的前驱，即p左子树中值最大的节点        t = s;          s = s-&gt;rchild;        }    p-&gt;val = s-&gt;val;   //把节点s的值赋给p    if(t == p){        p-&gt;lchild = s-&gt;lchild;        }        else{        t-&gt;rchild = s-&gt;lchild;        }    free(s);}return find;</code></pre><p>}</p><p>查找操作：</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19</p><p>pnode search_BST(pnode p, int x)<br>{<br>    bool solve = false;<br>    while(p &amp;&amp; !solve){<br>        if(x == p-&gt;val){<br>            solve = true;<br>        }<br>        else if(x &lt; p-&gt;val){<br>            p = p-&gt;lchild;<br>        }<br>        else{<br>            p = p-&gt;rchild;<br>        }<br>    }<br>    if(p == NULL){<br>        cout &lt;&lt; “没有找到” &lt;&lt; x &lt;&lt; endl;<br>    }<br>    return p;<br>}</p><ol start="3"><li>平衡二叉树<br>我们知道，对于一般的二叉搜索树（Binary Search Tree），其期望高度（即为一棵平衡树时）为log2n，其各操作的时间复杂度O(log2n)同时也由此而决定。但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即O(n)。我们可以通过随机化建立二叉搜索树来尽量的避免这种情况，但是在进行了多次的操作之后，由于在删除时，我们总是选择将待删除节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于树向左偏沉。这同时也会造成树的平衡性受到破坏，提高它的操作的时间复杂度。于是就有了我们下边介绍的平衡二叉树。<br>平衡二叉树定义：平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用算法有红黑树、AVL树等。在平衡二叉搜索树中，我们可以看到，其高度一般都良好地维持在O(log2n)，大大降低了操作的时间复杂度。<br>最小二叉平衡树的节点的公式如下：<br>F(n)=F(n-1)+F(n-2)+1<br>这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。3.1 平衡查找树之AVL树<br>有关AVL树的具体实现，可以参考C小加的博客《一步一步写平衡二叉树（AVL）》。<br>AVL树定义：AVL树是最先发明的自平衡二叉查找树。AVL树得名于它的发明者 G.M. Adelson-Velsky 和 E.M. Landis，他们在 1962 年的论文 “An algorithm for the organization of information” 中发表了它。在AVL中任何节点的两个儿子子树的高度最大差别为1，所以它也被称为高度平衡树，n个结点的AVL树最大深度约1.44log2n。查找、插入和删除在平均和最坏情况下都是O(logn)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。<br>AVL树的自平衡操作——旋转：<br>AVL树最关键的也是最难的一步操作就是旋转。旋转主要是为了实现AVL树在实施了插入和删除操作以后，树重新回到平衡的方法。下面我们重点研究一下AVL树的旋转。<br>对于一个平衡的节点，由于任意节点最多有两个儿子，因此高度不平衡时，此节点的两颗子树的高度差2.容易看出，这种不平衡出现在下面四种情况：</li></ol><p>1) 6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为左左。<br>2) 6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为左右。<br>3) 2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为右左。<br>4) 2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为右右。<br>从图2中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，我们称之为单旋转。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，我们称之为双旋转。<br>单旋转<br>单旋转是针对于左左和右右这两种情况的解决方案，这两种情况是对称的，只要解决了左左这种情况，右右就很好办了。图3是左左情况的解决方案，节点k2不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的左子树X子树，所以属于左左情况。</p><p>为使树恢复平衡，我们把k2变成这棵树的根节点，因为k2大于k1，把k2置于k1的右子树上，而原本在k1右子树的Y大于k1，小于k2，就把Y置于k2的左子树上，这样既满足了二叉查找树的性质，又满足了平衡二叉树的性质。<br>这样的操作只需要一部分指针改变，结果我们得到另外一颗二叉查找树，它是一棵AVL树，因为X向上一移动了一层，Y还停留在原来的层面上，Z向下移动了一层。整棵树的新高度和之前没有在左子树上插入的高度相同，插入操作使得X高度长高了。因此，由于这颗子树高度没有变化，所以通往根节点的路径就不需要继续旋转了。<br>双旋转<br>对于左右和右左这两种情况，单旋转不能使它达到一个平衡状态，要经过两次旋转。双旋转是针对于这两种情况的解决方案，同样的，这样两种情况也是对称的，只要解决了左右这种情况，右左就很好办了。图4是左右情况的解决方案，节点k3不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的右子树k2子树，所以属于左右情况。</p><p>为使树恢复平衡，我们需要进行两步，第一步，把k1作为根，进行一次右右旋转，旋转之后就变成了左左情况，所以第二步再进行一次左左旋转，最后得到了一棵以k2为根的平衡二叉树。<br>AVL树实现源码：</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148<br>149<br>150<br>151<br>152<br>153<br>154<br>155<br>156<br>157<br>158<br>159<br>160<br>161<br>162<br>163<br>164<br>165<br>166<br>167<br>168<br>169<br>170<br>171<br>172<br>173<br>174<br>175<br>176<br>177<br>178<br>179<br>180<br>181<br>182<br>183<br>184<br>185<br>186<br>187<br>188<br>189<br>190<br>191<br>192<br>193<br>194<br>195<br>196<br>197<br>198<br>199<br>200<br>201<br>202<br>203<br>204<br>205<br>206<br>207<br>208<br>209<br>210<br>211<br>212<br>213<br>214<br>215<br>216<br>217<br>218<br>219<br>220<br>221<br>222<br>223<br>224<br>225<br>226<br>227<br>228<br>229</p><p>//AVL树节点信息<br>template<class t=""><br>class TreeNode<br>{<br>    public:<br>        TreeNode():lson(NULL),rson(NULL),freq(1),hgt(0){}<br>        T data;//值<br>        int hgt;//高度<br>        unsigned int freq;//频率<br>        TreeNode<em> lson;//指向左儿子的地址<br>        TreeNode</em> rson;//指向右儿子的地址<br>};<br>//AVL树类的属性和方法声明<br>template<class t=""><br>class AVLTree<br>{<br>    private:<br>        TreeNode<t><em> root;//根节点<br>        void insertpri(TreeNode<t></t></em> &amp;node,T x);//插入<br>        TreeNode<t><em> findpri(TreeNode<t></t></em> node,T x);//查找<br>        void insubtree(TreeNode<t><em> node);//中序遍历<br>        void Deletepri(TreeNode<t></t></em> &amp;node,T x);//删除<br>        int height(TreeNode<t><em> node);//求树的高度<br>        void SingRotateLeft(TreeNode<t></t></em> &amp;k2);//左左情况下的旋转<br>        void SingRotateRight(TreeNode<t><em> &amp;k2);//右右情况下的旋转<br>        void DoubleRotateLR(TreeNode<t></t></em> &amp;k3);//左右情况下的旋转<br>        void DoubleRotateRL(TreeNode<t>* &amp;k3);//右左情况下的旋转<br>        int Max(int cmpa,int cmpb);//求最大值</t></t></t></t></t></t></class></class></p><pre><code>public:    AVLTree():root(NULL){}    void insert(T x);//插入接口    TreeNode&lt;T&gt;* find(T x);//查找接口    void Delete(T x);//删除接口    void traversal();//遍历接口</code></pre><p>};<br>//计算节点的高度<br>template<class t=""><br>int AVLTree<t>::height(TreeNode<t><em> node)<br>{<br>    if(node!=NULL)<br>        return node-&gt;hgt;<br>    return -1;<br>}<br>//求最大值<br>template<class t=""><br>int AVLTree<t>::Max(int cmpa,int cmpb)<br>{<br>    return cmpa&gt;cmpb?cmpa:cmpb;<br>}<br>//左左情况下的旋转<br>template<class t=""><br>void AVLTree<t>::SingRotateLeft(TreeNode<t></t></t></class></t></class></em> &amp;k2)<br>{<br>    TreeNode<t>* k1;<br>    k1=k2-&gt;lson;<br>    k2-&gt;lson=k1-&gt;rson;<br>    k1-&gt;rson=k2;</t></t></t></class></p><pre><code>k2-&gt;hgt=Max(height(k2-&gt;lson),height(k2-&gt;rson))+1;k1-&gt;hgt=Max(height(k1-&gt;lson),k2-&gt;hgt)+1;</code></pre><p>}<br>//右右情况下的旋转<br>template<class t=""><br>void AVLTree<t>::SingRotateRight(TreeNode<t><em> &amp;k2)<br>{<br>    TreeNode<t></t></em> k1;<br>    k1=k2-&gt;rson;<br>    k2-&gt;rson=k1-&gt;lson;<br>    k1-&gt;lson=k2;</t></t></class></p><pre><code>k2-&gt;hgt=Max(height(k2-&gt;lson),height(k2-&gt;rson))+1;k1-&gt;hgt=Max(height(k1-&gt;rson),k2-&gt;hgt)+1;</code></pre><p>}<br>//左右情况的旋转<br>template<class t=""><br>void AVLTree<t>::DoubleRotateLR(TreeNode<t><em> &amp;k3)<br>{<br>    SingRotateRight(k3-&gt;lson);<br>    SingRotateLeft(k3);<br>}<br>//右左情况的旋转<br>template<class t=""><br>void AVLTree<t>::DoubleRotateRL(TreeNode<t></t></t></class></em> &amp;k3)<br>{<br>    SingRotateLeft(k3-&gt;rson);<br>    SingRotateRight(k3);<br>}<br>//插入<br>template<class t=""><br>void AVLTree<t>::insertpri(TreeNode<t><em> &amp;node,T x)<br>{<br>    if(node==NULL)//如果节点为空,就在此节点处加入x信息<br>    {<br>        node=new TreeNode<t>();<br>        node-&gt;data=x;<br>        return;<br>    }<br>    if(node-&gt;data&gt;x)//如果x小于节点的值,就继续在节点的左子树中插入x<br>    {<br>        insertpri(node-&gt;lson,x);<br>        if(2==height(node-&gt;lson)-height(node-&gt;rson))<br>            if(x<node->lson-&gt;data)<br>                SingRotateLeft(node);<br>            else<br>                DoubleRotateLR(node);<br>    }<br>    else if(node-&gt;data&lt;x)//如果x大于节点的值,就继续在节点的右子树中插入x<br>    {<br>        insertpri(node-&gt;rson,x);<br>        if(2==height(node-&gt;rson)-height(node-&gt;lson))//如果高度之差为2的话就失去了平衡,需要旋转<br>            if(x&gt;node-&gt;rson-&gt;data)<br>                SingRotateRight(node);<br>            else<br>                DoubleRotateRL(node);<br>    }<br>    else ++(node-&gt;freq);//如果相等,就把频率加1<br>    node-&gt;hgt=Max(height(node-&gt;lson),height(node-&gt;rson));<br>}<br>//插入接口<br>template<class t=""><br>void AVLTree<t>::insert(T x)<br>{<br>    insertpri(root,x);<br>}<br>//查找<br>template<class t=""><br>TreeNode<t></t></class></t></class></node-></t></em> AVLTree<t>::findpri(TreeNode<t><em> node,T x)<br>{<br>    if(node==NULL)//如果节点为空说明没找到,返回NULL<br>    {<br>        return NULL;<br>    }<br>    if(node-&gt;data&gt;x)//如果x小于节点的值,就继续在节点的左子树中查找x<br>    {<br>        return findpri(node-&gt;lson,x);<br>    }<br>    else if(node-&gt;data&lt;x)//如果x大于节点的值,就继续在节点的左子树中查找x<br>    {<br>        return findpri(node-&gt;rson,x);<br>    }<br>    else return node;//如果相等,就找到了此节点<br>}<br>//查找接口<br>template<class t=""><br>TreeNode<t></t></class></em> AVLTree<t>::find(T x)<br>{<br>    return findpri(root,x);<br>}<br>//删除<br>template<class t=""><br>void AVLTree<t>::Deletepri(TreeNode<t>* &amp;node,T x)<br>{<br>    if(node==NULL) return ;//没有找到值是x的节点<br>    if(x &lt; node-&gt;data)<br>    {<br>         Deletepri(node-&gt;lson,x);//如果x小于节点的值,就继续在节点的左子树中删除x<br>         if(2==height(node-&gt;rson)-height(node-&gt;lson))<br>            if(node-&gt;rson-&gt;lson!=NULL&amp;&amp;(height(node-&gt;rson-&gt;lson)&gt;height(node-&gt;rson-&gt;rson)) )<br>                DoubleRotateRL(node);<br>            else<br>                SingRotateRight(node);<br>    }</t></t></class></t></t></t></t></t></class></t></t></class></p><pre><code>else if(x &gt; node-&gt;data){     Deletepri(node-&gt;rson,x);//如果x大于节点的值,就继续在节点的右子树中删除x     if(2==height(node-&gt;lson)-height(node-&gt;rson))        if(node-&gt;lson-&gt;rson!=NULL&amp;&amp; (height(node-&gt;lson-&gt;rson)&gt;height(node-&gt;lson-&gt;lson) ))            DoubleRotateLR(node);        else            SingRotateLeft(node);}else//如果相等,此节点就是要删除的节点{    if(node-&gt;lson&amp;&amp;node-&gt;rson)//此节点有两个儿子    {        TreeNode&lt;T&gt;* temp=node-&gt;rson;//temp指向节点的右儿子        while(temp-&gt;lson!=NULL) temp=temp-&gt;lson;//找到右子树中值最小的节点        //把右子树中最小节点的值赋值给本节点        node-&gt;data=temp-&gt;data;        node-&gt;freq=temp-&gt;freq;        Deletepri(node-&gt;rson,temp-&gt;data);//删除右子树中最小值的节点        if(2==height(node-&gt;lson)-height(node-&gt;rson))        {            if(node-&gt;lson-&gt;rson!=NULL&amp;&amp; (height(node-&gt;lson-&gt;rson)&gt;height(node-&gt;lson-&gt;lson) ))                DoubleRotateLR(node);            else                SingRotateLeft(node);        }    }    else//此节点有1个或0个儿子    {        TreeNode&lt;T&gt;* temp=node;        if(node-&gt;lson==NULL)//有右儿子或者没有儿子        node=node-&gt;rson;        else if(node-&gt;rson==NULL)//有左儿子        node=node-&gt;lson;        delete(temp);        temp=NULL;    }}if(node==NULL) return;node-&gt;hgt=Max(height(node-&gt;lson),height(node-&gt;rson))+1;return;</code></pre><p>}<br>//删除接口<br>template<class t=""><br>void AVLTree<t>::Delete(T x)<br>{<br>    Deletepri(root,x);<br>}<br>//中序遍历函数<br>template<class t=""><br>void AVLTree<t>::insubtree(TreeNode<t>* node)<br>{<br>    if(node==NULL) return;<br>    insubtree(node-&gt;lson);//先遍历左子树<br>    cout&lt;<node->data&lt;&lt;” “;//输出根节点<br>    insubtree(node-&gt;rson);//再遍历右子树<br>}<br>//中序遍历接口<br>template<class t=""><br>void AVLTree<t>::traversal()<br>{<br>    insubtree(root);<br>}</t></class></node-></t></t></class></t></class></p><p>3.2 平衡二叉树之红黑树<br>红黑树的定义：红黑树是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它是在1972年由鲁道夫·贝尔发明的，称之为”对称二叉B树”，它现代的名字是在 Leo J. Guibas 和 Robert Sedgewick 于1978年写的一篇论文中获得的。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(logn)时间内做查找，插入和删除，这里的n是树中元素的数目。<br>红黑树和AVL树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。这不只是使它们在时间敏感的应用如实时应用（real time application）中有价值，而且使它们有在提供最坏情况担保的其他数据结构中作为建造板块的价值；例如，在计算几何中使用的很多数据结构都可以基于红黑树。此外，红黑树还是2-3-4树的一种等同，它们的思想是一样的，只不过红黑树是2-3-4树用二叉树的形式表示的。<br>红黑树的性质：<br>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制的一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:<br>性质1. 节点是红色或黑色。<br>性质2. 根是黑色。<br>性质3. 所有叶子都是黑色（叶子是NIL节点）。<br>性质4. 每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。)<br>性质5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。<br>下面是一个具体的红黑树的图例：</p><p>这些约束确保了红黑树的关键特性: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。<br>要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。<br>以下内容整理自wiki百科之红黑树。<br>红黑树的自平衡操作：<br>因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。然而，在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量(O(logn))的颜色变更(实际是非常快速的)和不超过三次树旋转(对于插入操作是两次)。虽然插入和删除很复杂，但操作时间仍可以保持为O(logn) 次。<br>我们首先以二叉查找树的方法增加节点并标记它为红色。如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的（违背性质5）。但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整。下面要进行什么操作取决于其他临近节点的颜色。同人类的家族树中一样，我们将使用术语叔父节点来指一个节点的父节点的兄弟节点。注意:</p><pre><code>* </code></pre><p>性质1和性质3总是保持着。</p><pre><code>* </code></pre><p>性质4只在增加红色节点、重绘黑色节点为红色，或做旋转时受到威胁。</p><pre><code>* </code></pre><p>性质5只在增加黑色节点、重绘红色节点为黑色，或做旋转时受到威胁。</p><p>插入操作：<br>假设，将要插入的节点标为N，N的父节点标为P，N的祖父节点标为G，N的叔父节点标为U。在图中展示的任何颜色要么是由它所处情形这些所作的假定，要么是假定所暗含的。<br>情形1: 该树为空树，直接插入根结点的位置，违反性质1，把节点颜色有红改为黑即可。<br>情形2: 插入节点N的父节点P为黑色，不违反任何性质，无需做任何修改。在这种情形下，树仍是有效的。性质5也未受到威胁，尽管新节点N有两个黑色叶子子节点；但由于新节点N是红色，通过它的每个子节点的路径就都有同通过它所取代的黑色的叶子的路径同样数目的黑色节点，所以依然满足这个性质。<br>注： 情形1很简单，情形2中P为黑色，一切安然无事，但P为红就不一样了，下边是P为红的各种情况，也是真正难懂的地方。<br>情形3: 如果父节点P和叔父节点U二者都是红色，(此时新插入节点N做为P的左子节点或右子节点都属于情形3,这里右图仅显示N做为P左子的情形)则我们可以将它们两个重绘为黑色并重绘祖父节点G为红色(用来保持性质4)。现在我们的新节点N有了一个黑色的父节点P。因为通过父节点P或叔父节点U的任何路径都必定通过祖父节点G，在这些路径上的黑节点数目没有改变。但是，红色的祖父节点G的父节点也有可能是红色的，这就违反了性质4。为了解决这个问题，我们在祖父节点G上递归地进行上述情形的整个过程（把G当成是新加入的节点进行各种情形的检查）。比如，G为根节点，那我们就直接将G变为黑色（情形1）；如果G不是根节点，而它的父节点为黑色，那符合所有的性质，直接插入即可（情形2）；如果G不是根节点，而它的父节点为红色，则递归上述过程（情形3）。</p><p>情形4: 父节点P是红色而叔父节点U是黑色或缺少，新节点N是其父节点的左子节点，而父节点P又是其父节点G的左子节点。在这种情形下，我们进行针对祖父节点G的一次右旋转; 在旋转产生的树中，以前的父节点P现在是新节点N和以前的祖父节点G的父节点。我们知道以前的祖父节点G是黑色，否则父节点P就不可能是红色(如果P和G都是红色就违反了性质4，所以G必须是黑色)。我们切换以前的父节点P和祖父节点G的颜色，结果的树满足性质4。性质5也仍然保持满足，因为通过这三个节点中任何一个的所有路径以前都通过祖父节点G，现在它们都通过以前的父节点P。在各自的情形下，这都是三个节点中唯一的黑色节点。</p><p>情形5: 父节点P是红色而叔父节点U是黑色或缺少，并且新节点N是其父节点P的右子节点而父节点P又是其父节点的左子节点。在这种情形下，我们进行一次左旋转调换新节点和其父节点的角色; 接着，我们按情形4处理以前的父节点P以解决仍然失效的性质4。注意这个改变会导致某些路径通过它们以前不通过的新节点N（比如图中1号叶子节点）或不通过节点P（比如图中3号叶子节点），但由于这两个节点都是红色的，所以性质5仍有效。</p><p>注: 插入实际上是原地算法，因为上述所有调用都使用了尾部递归。<br>删除操作：<br>如果需要删除的节点有两个儿子，那么问题可以被转化成删除另一个只有一个儿子的节点的问题。对于二叉查找树，在删除带有两个非叶子儿子的节点的时候，我们找到要么在它的左子树中的最大元素、要么在它的右子树中的最小元素，并把它的值转移到要删除的节点中。我们接着删除我们从中复制出值的那个节点，它必定有少于两个非叶子的儿子。因为只是复制了一个值，不违反任何性质，这就把问题简化为如何删除最多有一个儿子的节点的问题。它不关心这个节点是最初要删除的节点还是我们从中复制出值的那个节点。<br>我们只需要讨论删除只有一个儿子的节点(如果它两个儿子都为空，即均为叶子，我们任意将其中一个看作它的儿子)。如果我们删除一个红色节点（此时该节点的儿子将都为叶子节点），它的父亲和儿子一定是黑色的。所以我们可以简单的用它的黑色儿子替换它，并不会破坏性质3和性质4。通过被删除节点的所有路径只是少了一个红色节点，这样可以继续保证性质5。另一种简单情况是在被删除节点是黑色而它的儿子是红色的时候。如果只是去除这个黑色节点，用它的红色儿子顶替上来的话，会破坏性质5，但是如果我们重绘它的儿子为黑色，则曾经通过它的所有路径将通过它的黑色儿子，这样可以继续保持性质5。<br>需要进一步讨论的是在要删除的节点和它的儿子二者都是黑色的时候，这是一种复杂的情况。我们首先把要删除的节点替换为它的儿子。出于方便，称呼这个儿子为N(在新的位置上)，称呼它的兄弟(它父亲的另一个儿子)为S。在下面的示意图中，我们还是使用P称呼N的父亲，SL称呼S的左儿子，SR称呼S的右儿子。<br>如果N和它初始的父亲是黑色，则删除它的父亲导致通过N的路径都比不通过它的路径少了一个黑色节点。因为这违反了性质5，树需要被重新平衡。有几种情形需要考虑:<br>情形1: N是新的根。在这种情形下，我们就做完了。我们从所有路径去除了一个黑色节点，而新根是黑色的，所以性质都保持着。<br>注意: 在情形2、5和6下，我们假定N是它父亲的左儿子。如果它是右儿子，则在这些情形下的左和右应当对调。<br>情形2: S是红色。在这种情形下我们在N的父亲上做左旋转，把红色兄弟转换成N的祖父，我们接着对调N的父亲和祖父的颜色。完成这两个操作后，尽管所有路径上黑色节点的数目没有改变，但现在N有了一个黑色的兄弟和一个红色的父亲（它的新兄弟是黑色因为它是红色S的一个儿子），所以我们可以接下去按情形4、情形5或情形6来处理。</p><p>情形3: N的父亲、S和S的儿子都是黑色的。在这种情形下，我们简单的重绘S为红色。结果是通过S的所有路径，它们就是以前不通过N的那些路径，都少了一个黑色节点。因为删除N的初始的父亲使通过N的所有路径少了一个黑色节点，这使事情都平衡了起来。但是，通过P的所有路径现在比不通过P的路径少了一个黑色节点，所以仍然违反性质5。要修正这个问题，我们要从情形1开始，在P上做重新平衡处理。</p><p>情形4: S和S的儿子都是黑色，但是N的父亲是红色。在这种情形下，我们简单的交换N的兄弟和父亲的颜色。这不影响不通过N的路径的黑色节点的数目，但是它在通过N的路径上对黑色节点数目增加了一，添补了在这些路径上删除的黑色节点。</p><p>情形5: S是黑色，S的左儿子是红色，S的右儿子是黑色，而N是它父亲的左儿子。在这种情形下我们在S上做右旋转，这样S的左儿子成为S的父亲和N的新兄弟。我们接着交换S和它的新父亲的颜色。所有路径仍有同样数目的黑色节点，但是现在N有了一个黑色兄弟，他的右儿子是红色的，所以我们进入了情形6。N和它的父亲都不受这个变换的影响。</p><p>情形6: S是黑色，S的右儿子是红色，而N是它父亲的左儿子。在这种情形下我们在N的父亲上做左旋转，这样S成为N的父亲（P）和S的右儿子的父亲。我们接着交换N的父亲和S的颜色，并使S的右儿子为黑色。子树在它的根上的仍是同样的颜色，所以性质3没有被违反。但是，N现在增加了一个黑色祖先: 要么N的父亲变成黑色，要么它是黑色而S被增加为一个黑色祖父。所以，通过N的路径都增加了一个黑色节点。<br>此时，如果一个路径不通过N，则有两种可能性:</p><pre><code>* </code></pre><p>它通过N的新兄弟。那么它以前和现在都必定通过S和N的父亲，而它们只是交换了颜色。所以路径保持了同样数目的黑色节点。</p><pre><code>* </code></pre><p>它通过N的新叔父，S的右儿子。那么它以前通过S、S的父亲和S的右儿子，但是现在只通过S，它被假定为它以前的父亲的颜色，和S的右儿子，它被从红色改变为黑色。合成效果是这个路径通过了同样数目的黑色节点。</p><p>在任何情况下，在这些路径上的黑色节点数目都没有改变。所以我们恢复了性质4。在示意图中的白色节点可以是红色或黑色，但是在变换前后都必须指定相同的颜色。</p><p>红黑树实现源码：</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148<br>149<br>150<br>151<br>152<br>153<br>154<br>155<br>156<br>157<br>158<br>159<br>160<br>161<br>162<br>163<br>164<br>165<br>166<br>167<br>168<br>169<br>170<br>171<br>172<br>173<br>174<br>175<br>176<br>177<br>178<br>179<br>180<br>181<br>182<br>183<br>184<br>185<br>186<br>187<br>188<br>189<br>190<br>191<br>192<br>193<br>194<br>195<br>196<br>197<br>198<br>199<br>200<br>201<br>202<br>203<br>204<br>205<br>206<br>207<br>208<br>209<br>210<br>211<br>212<br>213<br>214<br>215<br>216<br>217<br>218<br>219<br>220<br>221<br>222<br>223<br>224<br>225<br>226<br>227<br>228<br>229<br>230<br>231<br>232<br>233<br>234<br>235<br>236<br>237<br>238<br>239<br>240<br>241<br>242<br>243<br>244<br>245<br>246<br>247<br>248<br>249<br>250<br>251<br>252<br>253<br>254<br>255<br>256<br>257<br>258<br>259<br>260<br>261<br>262<br>263<br>264<br>265<br>266<br>267<br>268<br>269<br>270<br>271<br>272<br>273<br>274<br>275<br>276<br>277<br>278<br>279<br>280<br>281<br>282<br>283<br>284<br>285<br>286<br>287<br>288<br>289<br>290<br>291<br>292<br>293<br>294<br>295<br>296<br>297<br>298<br>299<br>300<br>301<br>302<br>303<br>304<br>305<br>306<br>307<br>308<br>309<br>310<br>311<br>312<br>313<br>314<br>315<br>316<br>317<br>318<br>319<br>320<br>321<br>322<br>323<br>324<br>325<br>326<br>327<br>328<br>329<br>330<br>331<br>332<br>333</p><p>#define BLACK 1</p><p>#define RED 0</p><p>using namespace std;</p><p>class bst {<br>private:</p><pre><code>struct Node {    int value;    bool color;    Node *leftTree, *rightTree, *parent;    Node() {        color = RED;        leftTree = NULL;        rightTree = NULL;        parent = NULL;        value = 0;    }    Node* grandparent() {        if (parent == NULL) {            return NULL;        }        return parent-&gt;parent;    }    Node* uncle() {        if (grandparent() == NULL) {            return NULL;        }        if (parent == grandparent()-&gt;rightTree)            return grandparent()-&gt;leftTree;        else            return grandparent()-&gt;rightTree;    }    Node* sibling() {        if (parent-&gt;leftTree == this)            return parent-&gt;rightTree;        else            return parent-&gt;leftTree;    }};void rotate_right(Node *p) {    Node *gp = p-&gt;grandparent();    Node *fa = p-&gt;parent;    Node *y = p-&gt;rightTree;    fa-&gt;leftTree = y;    if (y != NIL)        y-&gt;parent = fa;    p-&gt;rightTree = fa;    fa-&gt;parent = p;    if (root == fa)        root = p;    p-&gt;parent = gp;    if (gp != NULL) {        if (gp-&gt;leftTree == fa)            gp-&gt;leftTree = p;        else            gp-&gt;rightTree = p;    }}void rotate_left(Node *p) {    if (p-&gt;parent == NULL) {        root = p;        return;    }    Node *gp = p-&gt;grandparent();    Node *fa = p-&gt;parent;    Node *y = p-&gt;leftTree;    fa-&gt;rightTree = y;    if (y != NIL)        y-&gt;parent = fa;    p-&gt;leftTree = fa;    fa-&gt;parent = p;    if (root == fa)        root = p;    p-&gt;parent = gp;    if (gp != NULL) {        if (gp-&gt;leftTree == fa)            gp-&gt;leftTree = p;        else            gp-&gt;rightTree = p;    }}void inorder(Node *p) {    if (p == NIL)        return;    if (p-&gt;leftTree)        inorder(p-&gt;leftTree);    cout &lt;&lt; p-&gt;value &lt;&lt; &quot; &quot;;    if (p-&gt;rightTree)        inorder(p-&gt;rightTree);}string outputColor(bool color) {    return color ? &quot;BLACK&quot; : &quot;RED&quot;;}Node* getSmallestChild(Node *p) {    if (p-&gt;leftTree == NIL)        return p;    return getSmallestChild(p-&gt;leftTree);}bool delete_child(Node *p, int data) {    if (p-&gt;value &gt; data) {        if (p-&gt;leftTree == NIL) {            return false;        }        return delete_child(p-&gt;leftTree, data);    } else if (p-&gt;value &lt; data) {        if (p-&gt;rightTree == NIL) {            return false;        }        return delete_child(p-&gt;rightTree, data);    } else if (p-&gt;value == data) {        if (p-&gt;rightTree == NIL) {            delete_one_child(p);            return true;        }        Node *smallest = getSmallestChild(p-&gt;rightTree);        swap(p-&gt;value, smallest-&gt;value);        delete_one_child(smallest);        return true;    }}void delete_one_child(Node *p) {    Node *child = p-&gt;leftTree == NIL ? p-&gt;rightTree : p-&gt;leftTree;    if (p-&gt;parent == NULL &amp;&amp; p-&gt;leftTree == NIL &amp;&amp; p-&gt;rightTree == NIL) {        p = NULL;        root = p;        return;    }    if (p-&gt;parent == NULL) {        delete  p;        child-&gt;parent = NULL;        root = child;        root-&gt;color = BLACK;        return;    }    if (p-&gt;parent-&gt;leftTree == p) {        p-&gt;parent-&gt;leftTree = child;    } else {        p-&gt;parent-&gt;rightTree = child;    }    child-&gt;parent = p-&gt;parent;    if (p-&gt;color == BLACK) {        if (child-&gt;color == RED) {            child-&gt;color = BLACK;        } else            delete_case(child);    }    delete p;}void delete_case(Node *p) {    if (p-&gt;parent == NULL) {        p-&gt;color = BLACK;        return;    }    if (p-&gt;sibling()-&gt;color == RED) {        p-&gt;parent-&gt;color = RED;        p-&gt;sibling()-&gt;color = BLACK;        if (p == p-&gt;parent-&gt;leftTree)            rotate_left(p-&gt;sibling());        else            rotate_right(p-&gt;sibling());    }    if (p-&gt;parent-&gt;color == BLACK &amp;&amp; p-&gt;sibling()-&gt;color == BLACK            &amp;&amp; p-&gt;sibling()-&gt;leftTree-&gt;color == BLACK &amp;&amp; p-&gt;sibling()-&gt;rightTree-&gt;color == BLACK) {        p-&gt;sibling()-&gt;color = RED;        delete_case(p-&gt;parent);    } else if (p-&gt;parent-&gt;color == RED &amp;&amp; p-&gt;sibling()-&gt;color == BLACK            &amp;&amp; p-&gt;sibling()-&gt;leftTree-&gt;color == BLACK &amp;&amp; p-&gt;sibling()-&gt;rightTree-&gt;color == BLACK) {        p-&gt;sibling()-&gt;color = RED;        p-&gt;parent-&gt;color = BLACK;    } else {        if (p-&gt;sibling()-&gt;color == BLACK) {            if (p == p-&gt;parent-&gt;leftTree &amp;&amp; p-&gt;sibling()-&gt;leftTree-&gt;color == RED                    &amp;&amp; p-&gt;sibling()-&gt;rightTree-&gt;color == BLACK) {                p-&gt;sibling()-&gt;color = RED;                p-&gt;sibling()-&gt;leftTree-&gt;color = BLACK;                rotate_right(p-&gt;sibling()-&gt;leftTree);            } else if (p == p-&gt;parent-&gt;rightTree &amp;&amp; p-&gt;sibling()-&gt;leftTree-&gt;color == BLACK                    &amp;&amp; p-&gt;sibling()-&gt;rightTree-&gt;color == RED) {                p-&gt;sibling()-&gt;color = RED;                p-&gt;sibling()-&gt;rightTree-&gt;color = BLACK;                rotate_left(p-&gt;sibling()-&gt;rightTree);            }        }        p-&gt;sibling()-&gt;color = p-&gt;parent-&gt;color;        p-&gt;parent-&gt;color = BLACK;        if (p == p-&gt;parent-&gt;leftTree) {            p-&gt;sibling()-&gt;rightTree-&gt;color = BLACK;            rotate_left(p-&gt;sibling());        } else {            p-&gt;sibling()-&gt;leftTree-&gt;color = BLACK;            rotate_right(p-&gt;sibling());        }    }}void insert(Node *p, int data) {    if (p-&gt;value &gt;= data) {        if (p-&gt;leftTree != NIL)            insert(p-&gt;leftTree, data);        else {            Node *tmp = new Node();            tmp-&gt;value = data;            tmp-&gt;leftTree = tmp-&gt;rightTree = NIL;            tmp-&gt;parent = p;            p-&gt;leftTree = tmp;            insert_case(tmp);        }    } else {        if (p-&gt;rightTree != NIL)            insert(p-&gt;rightTree, data);        else {            Node *tmp = new Node();            tmp-&gt;value = data;            tmp-&gt;leftTree = tmp-&gt;rightTree = NIL;            tmp-&gt;parent = p;            p-&gt;rightTree = tmp;            insert_case(tmp);        }    }}void insert_case(Node *p) {    if (p-&gt;parent == NULL) {        root = p;        p-&gt;color = BLACK;        return;    }    if (p-&gt;parent-&gt;color == RED) {        if (p-&gt;uncle()-&gt;color == RED) {            p-&gt;parent-&gt;color = p-&gt;uncle()-&gt;color = BLACK;            p-&gt;grandparent()-&gt;color = RED;            insert_case(p-&gt;grandparent());        } else {            if (p-&gt;parent-&gt;rightTree == p &amp;&amp; p-&gt;grandparent()-&gt;leftTree == p-&gt;parent) {                rotate_left(p);                rotate_right(p);                p-&gt;color = BLACK;                p-&gt;leftTree-&gt;color = p-&gt;rightTree-&gt;color = RED;            } else if (p-&gt;parent-&gt;leftTree == p &amp;&amp; p-&gt;grandparent()-&gt;rightTree == p-&gt;parent) {                rotate_right(p);                rotate_left(p);                p-&gt;color = BLACK;                p-&gt;leftTree-&gt;color = p-&gt;rightTree-&gt;color = RED;            } else if (p-&gt;parent-&gt;leftTree == p &amp;&amp; p-&gt;grandparent()-&gt;leftTree == p-&gt;parent) {                p-&gt;parent-&gt;color = BLACK;                p-&gt;grandparent()-&gt;color = RED;                rotate_right(p-&gt;parent);            } else if (p-&gt;parent-&gt;rightTree == p &amp;&amp; p-&gt;grandparent()-&gt;rightTree == p-&gt;parent) {                p-&gt;parent-&gt;color = BLACK;                p-&gt;grandparent()-&gt;color = RED;                rotate_left(p-&gt;parent);            }        }    }}void DeleteTree(Node *p) {    if (!p || p == NIL) {        return;    }    DeleteTree(p-&gt;leftTree);    DeleteTree(p-&gt;rightTree);    delete p;}</code></pre><p>public:</p><pre><code>bst() {    NIL = new Node();    NIL-&gt;color = BLACK;    root = NULL;}~bst() {    if (root)        DeleteTree(root);    delete NIL;}void inorder() {    if (root == NULL)        return;    inorder(root);    cout &lt;&lt; endl;}void insert(int x) {    if (root == NULL) {        root = new Node();        root-&gt;color = BLACK;        root-&gt;leftTree = root-&gt;rightTree = NIL;        root-&gt;value = x;    } else {        insert(root, x);    }}bool delete_value(int data) {    return delete_child(root, data);}</code></pre><p>private:<br>    Node <em>root, </em>NIL;<br>};</p><ol start="4"><li>B树<br>B树也是一种用于查找的平衡树，但是它不是二叉树。<br>B树的定义：B树（B-tree）是一种树状数据结构，能够用来存储排序后的数据。这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树，可以拥有多于2个子节点。与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。这种数据结构常被应用在数据库和文件系统的实作上。<br>在B树中查找给定关键字的方法是，首先把根结点取来，在根结点所包含的关键字K1,…,Kn查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查找的关键字在Ki与Ki+1之间，Pi为指向子树根节点的指针，此时取指针Pi所指的结点继续查找，直至找到，或指针Pi为空时查找失败。<br>B树作为一种多路搜索树（并不是二叉的）：<br>1) 定义任意非叶子结点最多只有M个儿子；且M&gt;2；<br>2) 根结点的儿子数为[2, M]；<br>3) 除根结点以外的非叶子结点的儿子数为[M/2, M]；<br>4) 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）<br>5) 非叶子结点的关键字个数=指向儿子的指针个数-1；<br>6) 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；<br>7) 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；<br>8) 所有叶子结点位于同一层；<br>如下图为一个M=3的B树示例：</li></ol><p>B树创建的示意图：</p><ol start="5"><li>B+树<br>B+树是B树的变体，也是一种多路搜索树：<br>1) 其定义基本与B-树相同，除了：<br>2) 非叶子结点的子树指针与关键字个数相同；<br>3) 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；<br>4) 为所有叶子结点增加一个链指针；<br>5) 所有关键字都在叶子结点出现；<br>下图为M=3的B+树的示意图：</li></ol><p>B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；<br>B+的性质：<br>1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；<br>2.不可能在非叶子结点命中；<br>3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；<br>4.更适合文件索引系统。<br>下面为一个B+树创建的示意图：</p><ol start="6"><li>B<em>树<br>B</em>树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针，将结点的最低利用率从1/2提高到2/3。<br>B*树如下图所示：</li></ol><p>B<em>树定义了非叶子结点关键字个数至少为(2/3)</em>M，即块的最低使用率为2/3（代替B+树的1/2）；<br>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；<br>B<em>树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；<br>所以，B</em>树分配新结点的概率比B+树要低，空间使用率更高。7. Trie树<br>Tire树称为字典树，又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。<br>Tire树的三个基本性质：<br>1) 根节点不包含字符，除根节点外每一个节点都只包含一个字符；<br>2) 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；<br>3) 每个节点的所有子节点包含的字符都不相同。<br>Tire树的应用：<br>1) 串的快速检索<br>给出N个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。在这道题中，我们可以用数组枚举，用哈希，用字典树，先把熟词建一棵树，然后读入文章进行比较，这种方法效率是比较高的。<br>2) “串”排序<br>给定N个互不相同的仅由一个单词构成的英文名，让你将他们按字典序从小到大输出。用字典树进行排序，采用数组的方式创建字典树，这棵树的每个结点的所有儿子很显然地按照其字母大小排序。对这棵树进行先序遍历即可。<br>3) 最长公共前缀<br>对所有串建立字典树，对于两个串的最长公共前缀的长度即他们所在的结点的公共祖先个数，于是，问题就转化为求公共祖先的问题。<br> 1 赞  12 收藏  3 评论</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构中各种树&quot;&gt;&lt;a href=&quot;#数据结构中各种树&quot; class=&quot;headerlink&quot; title=&quot;数据结构中各种树&quot;&gt;&lt;/a&gt;数据结构中各种树&lt;/h1&gt;&lt;p&gt;原文出处： Poll的笔记&lt;br&gt;数据结构中有很多树的结构，其中包括二叉树、二叉搜索树、2-
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>经典排序算法总结与实现</title>
    <link href="https://wadezhx.github.io/2018/12/06/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://wadezhx.github.io/2018/12/06/经典排序算法总结与实现/</id>
    <published>2018-12-06T02:46:37.000Z</published>
    <updated>2018-12-06T02:58:27.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="经典排序算法总结与实现"><a href="#经典排序算法总结与实现" class="headerlink" title="经典排序算法总结与实现"></a>经典排序算法总结与实现</h1><p>by WuChong, wuchong.me</p><p>经典排序算法在面试中占有很大的比重，也是基础，为了未雨绸缪，在寒假里整理并用Python实现了七大经典排序算法，包括冒泡排序，插入排序，选择排序，希尔排序，归并排序，快速排序，堆排序。希望能帮助到有需要的同学。之所以用Python实现，主要是因为它更接近伪代码，能用更少的代码实现算法，更利于理解。<br>本篇博客所有排序实现均默认从小到大。一、冒泡排序 BubbleSort<br>介绍：<br>冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。<br>步骤：</p><pre><code>1. </code></pre><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p><pre><code>2. </code></pre><p>对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。</p><pre><code>3. </code></pre><p>针对所有的元素重复以上的步骤，除了最后一个。</p><pre><code>4. </code></pre><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><p>源代码：(python实现)</p><p>def bubble_sort(arry):<br>n = len(arry) #获得数组的长度<br>for i in range(n):<br>for j in range(1,n-i):<br>if arry[j-1] &gt; arry[j] : #如果前者比后者大<br>arry[j-1],arry[j] = arry[j],arry[j-1] #则交换两者<br>return arry<br>不过针对上述代码还有两种优化方案。</p><p>优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。用一个标记记录这个状态即可。<br>优化2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。<br>这两种优化方案的实现可以详见这里。二、选择排序 SelectionSort<br>介绍：<br>选择排序无疑是最简单直观的排序。它的工作原理如下。<br>步骤：</p><pre><code>1. </code></pre><p>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p><pre><code>2. </code></pre><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p><pre><code>3. </code></pre><p>以此类推，直到所有元素均排序完毕。</p><p>源代码：(python实现)</p><p>def select_sort(ary):<br>n = len(ary)<br>for i in range(0,n):<br>min = i #最小元素下标标记<br>for j in range(i+1,n):<br>if ary[j] &lt; ary[min] :<br>min = j #找到最小值的下标<br>ary[min],ary[i] = ary[i],ary[min] #交换两者<br>return ary三、插入排序 InsertionSort<br>介绍：<br>插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br>步骤：</p><pre><code>1. </code></pre><p>从第一个元素开始，该元素可以认为已经被排序</p><pre><code>2. </code></pre><p>取出下一个元素，在已经排序的元素序列中从后向前扫描</p><pre><code>3. </code></pre><p>如果被扫描的元素（已排序）大于新元素，将该元素后移一位</p><pre><code>4. </code></pre><p>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</p><pre><code>5. </code></pre><p>将新元素插入到该位置后</p><pre><code>6. </code></pre><p>重复步骤2~5</p><p>排序演示：</p><p>源代码：(python实现)四、希尔排序 ShellSort<br>介绍：<br>希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。<br>希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。<br>例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p><p>13 14 94 33 82<br>25 59 94 65 23<br>45 27 73 25 39<br>10</p><p>然后我们对每列进行排序：</p><p>10 14 73 25 23<br>13 27 94 33 39<br>25 59 94 65 82<br>45</p><p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]。这时10已经移至正确位置了，然后再以3为步长进行排序：</p><p>10 14 73<br>25 23 13<br>27 94 33<br>39 25 59<br>94 65 82<br>45</p><p>排序之后变为：</p><p>10 14 13<br>25 23 33<br>27 25 59<br>39 65 73<br>45 94 82<br>94</p><p>最后以1步长进行排序（此时就是简单的插入排序了）。<br>源代码：(python实现)</p><p>def shell_sort(ary):<br>n = len(ary)<br>gap = round(n/2) #初始步长 , 用round四舍五入取整<br>while gap &gt; 0 :<br>for i in range(gap,n): #每一列进行插入排序 , 从gap 到 n-1<br>temp = ary[i]<br>j = i<br>while ( j &gt;= gap and ary[j-gap] &gt; temp ): #插入排序<br>ary[j] = ary[j-gap]<br>j = j - gap<br>ary[j] = temp<br>gap = round(gap/2) #重新设置步长<br>return ary<br>上面源码的步长的选择是从n/2开始，每次再减半，直至为0。步长的选择直接决定了希尔排序的复杂度。在维基百科上有对于步长串行的详细介绍。五、归并排序 MergeSort<br>介绍：<br>归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。<br>先考虑合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。<br>再考虑递归分解，基本思路是将数组分解成left和right，如果这两个数组内部数据是有序的，那么就可以用上面合并数组的方法将这两个数组合并排序。如何让这两个数组内部是有序的？可以再二分，直至分解出的小组只含有一个元素时为止，此时认为该小组内部已有序。然后合并排序相邻二个小组即可。<br>排序演示：<br>源代码：(python实现)</p><p>def merge_sort(ary):<br>if len(ary) &lt;= 1 : return ary<br>num = int(len(ary)/2) #二分分解<br>left = merge_sort(ary[:num])<br>right = merge_sort(ary[num:])<br>return merge(left,right) #合并数组def merge(left,right):<br>‘’’合并操作，<br>将两个有序数组left[]和right[]合并成一个大的有序数组’’’<br>l,r = 0,0 #left与right数组的下标指针<br>result = []<br>while l&lt;len(left) and r&lt;len(right) :<br>if left[l] &lt; right[r]:<br>result.append(left[l])<br>l += 1<br>else:<br>result.append(right[r])<br>r += 1<br>result += left[l:]<br>result += right[r:]<br>return result六、快速排序 QuickSort</p><p>介绍：<br>快速排序通常明显比同为Ο(n log n)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。<br>步骤：</p><pre><code>1. </code></pre><p>从数列中挑出一个元素作为基准数。</p><pre><code>2. </code></pre><p>分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。</p><pre><code>3. </code></pre><p>再对左右区间递归执行第二步，直至各区间只有一个数。</p><p>排序演示：<br>源代码：(python实现)</p><p>def quick_sort(ary):<br>return qsort(ary,0,len(ary)-1)def qsort(ary,left,right):</p><p>#快排函数，ary为待排序数组，left为待排序的左边界，right为右边界<br>if left &gt;= right : return ary<br>key = ary[left] #取最左边的为基准数<br>lp = left #左指针<br>rp = right #右指针<br>while lp &lt; rp :<br>while ary[rp] &gt;= key and lp &lt; rp :<br>rp -= 1<br>while ary[lp] &lt;= key and lp &lt; rp :<br>lp += 1<br>ary[lp],ary[rp] = ary[rp],ary[lp]<br>ary[left],ary[lp] = ary[lp],ary[left]<br>qsort(ary,left,lp-1)<br>qsort(ary,rp+1,right)<br>return ary七、堆排序 HeapSort<br>介绍：<br>堆排序在 top K 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。二叉堆是一个近似完全二叉树 。<br>二叉堆具有以下性质：</p><pre><code>1. </code></pre><p>父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。</p><pre><code>2. </code></pre><p>每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。</p><p>步骤：</p><pre><code>1. </code></pre><p>构造最大堆（Build_Max_Heap）：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆。于是只要从n/2-1开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。</p><pre><code>2. </code></pre><p>堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[n-1]交换，再对heap[0…n-2]做最大堆调整。第二次将heap[0]与heap[n-2]交换，再对heap[0…n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。</p><pre><code>3. </code></pre><p>最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点 。</p><p>排序演示：<br>源代码：(python实现)</p><p>def heap_sort(ary) :<br>n = len(ary)<br>first = int(n/2-1) #最后一个非叶子节点<br>for start in range(first,-1,-1) : #构造大根堆<br>max_heapify(ary,start,n-1)<br>for end in range(n-1,0,-1): #堆排，将大根堆转换成有序数组<br>ary[end],ary[0] = ary[0],ary[end]<br>max_heapify(ary,0,end-1)<br>return ary</p><p>#最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点</p><p>#start为当前需要调整最大堆的位置，end为调整边界<br>def max_heapify(ary,start,end):<br>root = start<br>while True :<br>child = root*2 +1 #调整节点的子节点<br>if child &gt; end : break child = child+1 #取较大的子节点<br>if ary[root] &lt; ary[child] : #较大的子节点成为父节点<br>ary[root],ary[child] = ary[child],ary[root] #交换<br>root = child<br>else :<br>break总结<br>下面为七种经典排序算法指标对比情况：<br>参考资料<br>注：本文所有源代码已共享到GitHub。<br>-EOF-<br>Original Page: <a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/" target="_blank" rel="noopener">http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;经典排序算法总结与实现&quot;&gt;&lt;a href=&quot;#经典排序算法总结与实现&quot; class=&quot;headerlink&quot; title=&quot;经典排序算法总结与实现&quot;&gt;&lt;/a&gt;经典排序算法总结与实现&lt;/h1&gt;&lt;p&gt;by WuChong, wuchong.me&lt;/p&gt;
&lt;p&gt;经典排序
      
    
    </summary>
    
    
      <category term="算法" scheme="https://wadezhx.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java学习第五次笔记</title>
    <link href="https://wadezhx.github.io/2018/12/05/java%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%94%E6%AC%A1%E7%AC%94%E8%AE%B0/"/>
    <id>https://wadezhx.github.io/2018/12/05/java学习第五次笔记/</id>
    <published>2018-12-05T12:28:32.000Z</published>
    <updated>2018-12-06T03:01:19.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wade-zhx"><a href="#wade-zhx" class="headerlink" title="wade.zhx"></a>wade.zhx</h1><h5 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h5><p><img src="en-resource://database/7241:1" alt="6d408ddd2a3f5b00edd918de34fc52fa.png"></p><blockquote><h5 id="整数运算："><a href="#整数运算：" class="headerlink" title="整数运算：　"></a>整数运算：　</h5><ol><li>如果两个操作数有一个为Long, 则结果也为long。　</li><li>没有long时，结果为int。即使操作数全为short，byte，结果也是int。　　<h5 id="浮点运算："><a href="#浮点运算：" class="headerlink" title="浮点运算：　　"></a>浮点运算：　　</h5></li><li>如果两个操作数有一个为double，则结果为double。　</li><li>只有两个操作数都是float，则结果才为float。　　<h5 id="取模运算："><a href="#取模运算：" class="headerlink" title="取模运算：　　"></a>取模运算：　　</h5>1.其操作数可以为浮点数,一般使用整数，结果是“余数”，<br><strong>“余数”符号和左边操作数相同，</strong><br>如：<strong>7%3=1，-7%3=-1，7%-3=1。</strong></li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(-9%5);</span><br><span class="line">    </span><br><span class="line">-4</span><br></pre></td></tr></table></figure><p>算术运算符中++，–属于一元运算符，该类运算符只需要一个操作数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        byte &lt;u&gt;a1&lt;/u&gt; = 1;</span><br><span class="line"></span><br><span class="line">        int b1 = 2;</span><br><span class="line"></span><br><span class="line">        // byte c = a+b;</span><br><span class="line"></span><br><span class="line">        long b2 = 3;</span><br><span class="line"></span><br><span class="line">        // &lt;u&gt;int&lt;/u&gt; c2 = b2+b; 因为不接受into &lt;u&gt;int&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        float f1 = 3.14f;</span><br><span class="line"></span><br><span class="line">        double &lt;u&gt;d&lt;/u&gt; = b1+b2;//</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        float &lt;u&gt;f2&lt;/u&gt; = f1+6.2f;//浮点型默认double</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        System.out.println(-9%5);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        //测试自增自减</span><br><span class="line"></span><br><span class="line">        int a = 3;</span><br><span class="line"></span><br><span class="line">        int b = a++;//先赋值后++</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;a=&quot;+a+&quot;\nb=&quot;+b);</span><br><span class="line"></span><br><span class="line">        //a=4</span><br><span class="line"></span><br><span class="line">        //b=3</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">         a = 3;</span><br><span class="line"></span><br><span class="line">         b = ++a; //先++后赋值</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;a=&quot;+a+&quot;\nb=&quot;+b);</span><br><span class="line"></span><br><span class="line">        //a=4</span><br><span class="line"></span><br><span class="line">        //b=4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;wade-zhx&quot;&gt;&lt;a href=&quot;#wade-zhx&quot; class=&quot;headerlink&quot; title=&quot;wade.zhx&quot;&gt;&lt;/a&gt;wade.zhx&lt;/h1&gt;&lt;h5 id=&quot;算术运算符&quot;&gt;&lt;a href=&quot;#算术运算符&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="java" scheme="https://wadezhx.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>在N个不相等的整数中找出最大的第K个数(N&gt;K)</title>
    <link href="https://wadezhx.github.io/2018/12/04/%E5%9C%A8N%E4%B8%AA%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E6%95%B4%E6%95%B0%E4%B8%AD%E6%89%BE%E5%87%BA%E6%9C%80%E5%A4%A7%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%95%B0(NK)/"/>
    <id>https://wadezhx.github.io/2018/12/04/在N个不相等的整数中找出最大的第K个数(NK)/</id>
    <published>2018-12-04T02:46:37.000Z</published>
    <updated>2018-12-06T02:58:36.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目：在N个不相等的整数中找出最大的第K个数-N-gt-K-。"><a href="#题目：在N个不相等的整数中找出最大的第K个数-N-gt-K-。" class="headerlink" title="题目：在N个不相等的整数中找出最大的第K个数(N&gt;K)。"></a>题目：在N个不相等的整数中找出最大的第K个数(N&gt;K)。</h1><p>思路：首先，用前K个整数构造容量为K的最小堆。然后，将后N-K个整数依次与堆顶元素比较，若比堆顶元素大，则替换堆顶元素并调整最小堆结构；反之，则继续比较下一个整数。最终，最小堆存储最大的k个数，其堆顶元素即为所求。<br>代码：</p><p>1 #include <cstdio><br>2 #include <cstdlib><br>3 #include <cmath><br>4 #include <ctime><br>5 #include <iostream><br>6<br>7 #define N 90<br>8 #define K 13<br>9<br>10<br>11 void HeapAdjust (int <em>heap, int beginidx, int endidx);<br>12 void HeapConstruct (int </em>heap);<br>13<br>14 void SetData (int <em>data);<br>15 void ShowData (int </em>data);<br>16<br>17 int main (int argc, char *<em>argv)<br>18 {<br>19 int i;<br>20 int h[N + 1];<br>21<br>22 SetData(h);<br>23 ShowData(h);<br>24<br>25 HeapConstruct(h);<br>26 for (i = K + 1; i &lt;= N; i++)<br>27 {<br>28 if (h[i] &gt; h[1])<br>29 {<br>30 h[1] = h[i];<br>31 HeapAdjust(h, 1, K);<br>32 }<br>33 }<br>34<br>35 printf(“The Kth biggest number: %d\n”, h[1]);<br>36 return 0;<br>37 }<br>38<br>39 void HeapAdjust (int </em>heap, int beginidx, int endidx)<br>40 {<br>41 int &amp;current = beginidx;<br>42 int tmp, left, right, data = heap[current];<br>43<br>44 while (left = (current &lt;&lt; 1), left &lt;= endidx)<br>45 {<br>46 right = left | 1;<br>47 if ((left == endidx) || (heap[left] &lt; heap[right]))<br>48 {<br>49 tmp = left;<br>50 }<br>51 else<br>52 {<br>53 tmp = right;<br>54 }<br>55 if (data &gt; heap[tmp])<br>56 {<br>57 heap[current] = heap[tmp];<br>58 current = tmp;<br>59 }<br>60 else<br>61 {<br>62 break;<br>63 }<br>64 }<br>65 heap[current] = data;<br>66 }<br>67<br>68 void HeapConstruct (int <em>heap)<br>69 {<br>70 int i;<br>71 for (i = K/2; i &gt; 0; i–)<br>72 {<br>73 HeapAdjust(heap, i, K);<br>74 }<br>75 }<br>76<br>77 void SetData (int </em>data)<br>78 {<br>79 bool <em>bdata = new bool[N + 1];<br>80 memset(bdata, false, N + 1);<br>81 srand(time(NULL));<br>82 data[0] = -1;<br>83 for (int i = 1; i &lt;= N; i++)<br>84 {<br>85 data[i] = rand() % N + 1;<br>86 while (bdata[data[i]])<br>87 {<br>88 data[i] = rand() % N + 1;<br>89 }<br>90 bdata[data[i]] = true;<br>91 }<br>92 delete []bdata;<br>93 }<br>94<br>95 void ShowData (int </em>data)<br>96 {<br>97 for (int i = 1; i &lt;= N; i++)<br>98 {<br>99 printf(“%02d “, data[i]);<br>100 }<br>101 puts(“”);<br>102 }</iostream></ctime></cmath></cstdlib></cstdio></p><p>时间复杂度：O((N-K+1)<em>K</em>lgK).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目：在N个不相等的整数中找出最大的第K个数-N-gt-K-。&quot;&gt;&lt;a href=&quot;#题目：在N个不相等的整数中找出最大的第K个数-N-gt-K-。&quot; class=&quot;headerlink&quot; title=&quot;题目：在N个不相等的整数中找出最大的第K个数(N&amp;gt;K)
      
    
    </summary>
    
    
      <category term="算法" scheme="https://wadezhx.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Web Service</title>
    <link href="https://wadezhx.github.io/2018/12/04/Web%20Service/"/>
    <id>https://wadezhx.github.io/2018/12/04/Web Service/</id>
    <published>2018-12-04T02:23:45.000Z</published>
    <updated>2018-12-06T02:58:16.271Z</updated>
    
    <content type="html"><![CDATA[<p>一、环境配置：MyEclipse7.0<br>JDK1.6<br>二、创建Web Service Project<br>1）在MyEclipse中选择File—&gt;New—&gt;Other，选择Web Service Project</p><p>2）Project Name：WebServiceServer，Framework：XFire，其他选项默认</p><p>3）Next，这一步保持默认值<br>4）Project Library选择，选择XFire 1.2 Core Libraries</p><p>5）Finish，创建成功后看到的工程目录如下：</p><p>6）完成以上5步后，查看WebRoot/WEB-INF/web.xml</p><p>这里指明了当遇到/services/*请求时，将选用XFireConfigurableServlet来处理  </p><p>三、创建Web Service Code<br>1）通过File—&gt;New—&gt;Other—&gt;Web Services—&gt;Web Service wizard创建JAVA CODE</p><p>2）选择通过JAVA CLASS创建Web Service</p><p>3）创建HelloWebService.java，通过New创建com.service package，向导将为工程自动创建对应的接口类与实现类</p><p>创建成功后查看WebServices/services.xml，发现配置文件多了以下内容：</p><p>4）修改HelloWebServiceImpl.java<br>package com.service;<br>//Generated by meteorWJ</p><p>public class HelloWebServiceImpl implements IHelloWebService {</p><p>public String example(String message) {<br>return getAuthor()+”,”+message;<br>}<br>private String getAuthor(){<br>return “meteorWJ”;<br>}</p><p>}</p><p>四、部署并测试WebSericeServer</p><p>1）部署WebServiceServer</p><p>在部署向导中选择项目、服务器</p><p>2）启动服务器</p><p>3）测试WebService<br>MyEclipse提供了一个Web Service Explorer来测试Web Service</p><p>选择列表中的Launch SOAP Web Services Explorer<br>4）选择WSDL模式</p><p>5）在Explorer中选择WSDL Main，在右边的URL中输入<br><a href="http://localhost:9090/WebServiceServer/services/HelloWebService?WSDL，单击&quot;Go&quot;" target="_blank" rel="noopener">http://localhost:9090/WebServiceServer/services/HelloWebService?WSDL，单击&quot;Go&quot;</a><br>其中9090是服务器端口号，services在之前的web.xml中指定<br>若在Status中显示成功打开WSDL文件则测试成功</p><p>五、创建WebService客户端<br>经过以上几步，我们已经成功发布了一个WebService，现在需要创建一个客户端来调用该服务<br>1）创建Java Project：WebServiceClient<br>2）引入MyEclipse Libraries<br>右键WebServiceClient—&gt;Build Path—&gt;Add Libraries</p><p>选择XFire 1.2 HTTP Client Libraries</p><p>3）创建HelloWebService.java<br>在src目录下创建com.client.HelloWebService.java<br>package com.client;</p><p>import java.net.URL;<br>import org.codehaus.xfire.client.Client;</p><p>public class HelloWebService {<br>public static void main(String[] args) throws Exception<br>{<br>Client client = new Client(new URL(“<a href="http://localhost:9090/WebServiceServer/services/HelloWebService?wsdl&quot;))" target="_blank" rel="noopener">http://localhost:9090/WebServiceServer/services/HelloWebService?wsdl&quot;))</a>;<br>Object[] results = client.invoke(“example”, new Object[] {“hello”});<br>System.out.println((String) results[0]);<br>}<br>}</p><p>4）在确认服务器启动的情况下，运行HelloWebService.java<br>右键点击Run As&gt;Java Application，在控制台中看到如下输出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、环境配置：MyEclipse7.0&lt;br&gt;JDK1.6&lt;br&gt;二、创建Web Service Project&lt;br&gt;1）在MyEclipse中选择File—&amp;gt;New—&amp;gt;Other，选择Web Service Project&lt;/p&gt;
&lt;p&gt;2）Project 
      
    
    </summary>
    
    
      <category term="Web Service" scheme="https://wadezhx.github.io/tags/Web-Service/"/>
    
  </entry>
  
  <entry>
    <title>取石子游戏算法</title>
    <link href="https://wadezhx.github.io/2018/12/03/%E5%8F%96%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://wadezhx.github.io/2018/12/03/取石子游戏算法/</id>
    <published>2018-12-03T02:48:13.000Z</published>
    <updated>2018-12-06T02:52:10.711Z</updated>
    
    <content type="html"><![CDATA[<pre><code>取石子游戏是一个古老的博弈游戏，据说是发源于中国，它是组合数学领域的一个经典问题。它有许多不同的玩法，基本上是两个玩家，玩的形式是轮流抓石子，胜利的标准是抓走了最后的石子。</code></pre><p>玩家设定： 先取石子的是玩家A，后取石子的是玩家B。<br>经典的三种玩法：<br>一、Bash Game，有1堆含n个石子，两个人轮流从这堆物品中取物，规定每次至少取1个，最多取m个。取走最后石子的人获胜。<br>二、Nimm Game，有k堆各n个石子，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限。取走最后石子的人获胜。<br>三、Wythoff Game，有2堆各n个石子，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取1个，多者不限。取走最后石子的人获胜。<br>平衡状态的概念：<br>    引入一个概念，平衡状态，又称作奇异局势。当面对这个局势时则会失败。任意非平衡态经过一次操作可以变为平衡态。每个玩家都会努力使自己抓完石子之后的局势为平衡，将这个平衡局势留给对方。因此，玩家A能够在初始为非平衡的游戏中取胜，玩家B能够在初始为平衡的游戏中取胜。<br>玩法一（1堆n个石子每次最多取m个）：<br>    最后一个奇异局势是n=(0)。一种奇异局势是，n=(m+1)，那么无论我取走多少个，对方都能够一次取走剩余所有的物品取胜。<br>奇异局势的判定：<br>    一般的奇异局势是n=(m+1)<em>i，其中i为自然数，即n%(m+1)=0，面对这种情况无论我怎么取，对方总可以将其恢复为n%(m+1)=0，一直到n=(m+1)局势。<br>玩家的策略：<br>    就是把当前面对的非奇异局势变为奇异局势留给对方。如果当前的石子个数为(m+1)</em>i+s，那么就将s个石子取走，使其达到奇异局势。<br>玩法二（k堆石子每次只从1堆取）：<br>    最后一个奇异局势是(0,0…,0)。另一个奇异局势是(n,n,0…0)，只要对手总是和我拿走一样多的物品，最后会面对(0,0…,0)。<br>奇异局势的判定：<br>    对于一个普通的局势，如何判断其是不是奇异局势？对于一个局势(s1,s2,…sk)，对所有石子个数做位的异或运算，s1^s2^s3^…^sk，如果结果为0，那么局势(s1,s2,…sk)就是奇异局势（平衡），否则就不是（非平衡）。<br>    从二进制位的角度上说，奇异局势时，每一个bit位上1的个数都是偶数。<br>玩家的策略：<br>    就是把面对的非奇异局势变为奇异局势留给对方。也就是从某一堆取出若干石子之后，使得每一个bit位上1的个数都变为偶数，这样的取法一般不只有一种。可以将其中一堆的石子数变为其他堆石子数的位异或运算的值（如果这个值比原来的石子数小的话）。<br>玩法三（2堆石子每次从一或两堆取一样数目的石子）：<br>    最后一个奇异局势是(0,0)。紧接着的奇异局势有(1,2),(3,5),(4,7),(6,10)……<br>    现在把它们看成一个奇异局势组成的序列(0,0),(1,2),(3,5),(4,7),(6,10)……<br>奇异局势的判定：<br>    我们会发现这个序列的规律，设序列第k个奇异局势元素为(Ak,Bk)，k为自然数。那么，初始条件k=0时是，A0=B0=0，递推关系为下一个奇异局势的Ak是未在前面出现过的最小自然数，且Ak = Bk + k。<br>    上面发现了奇异局势的递推公式，那么给出一个局势，如何判断其是否是奇异局势呢？<br>黄金分割数：数学真奇妙，竟然发现，这个序列跟黄金分割数有关系。黄金分割数是2/(1+sqrt(5))=(sqrt(5)-1)/2，其小数约等于0.61803398875，其倒数是(1+sqrt(5))/2，约等于1.61803398875。<br>    这个奇异局势的序列的通项公式可以表示为：<br>  Ak = [k*(1+sqrt(5.0)/2]<br>  Bk = Ak + k<br>  其中k=0，1，2，…,n ，方括号表示int取整函数。<br>    有了这个通项式子，逆向的，对于某一个局势，只需要判断其A是否是黄金分割数的某个k的倍数，然后再确认B是否等于A+k即可。<br>这里写了一个简单的判断程序：</p><p>[cpp] view plain<br>copy</p><pre><code>1. </code></pre><p>#include<cmath>  </cmath></p><pre><code>2. </code></pre><p>#include<iostream>  </iostream></p><pre><code>3. </code></pre><p>using namespace std;  </p><pre><code>4. </code></pre><p>const double m = (1+sqrt(5.0))/2;  </p><pre><code>5. 6. </code></pre><p>void display()  </p><pre><code>7. </code></pre><p>{  </p><pre><code>8. int i;  9. int out;  10. for(i=0;i&lt;30;i++)  11. {  12.     out = int(m*i);  13.     cout&lt;&lt;&quot;(&quot;&lt;&lt;out&lt;&lt;&quot;, &quot;&lt;&lt;out+i&lt;&lt;&quot;)&quot;&lt;&lt;endl;  14. }  15. </code></pre><p>}  </p><pre><code>16. 17. </code></pre><p>bool judge(int a, int b)  </p><pre><code>18. </code></pre><p>{  </p><pre><code>19. int k = a/m;  20. 21. if ( a == int(k*m) )  22. {  23.     if( b == a + k )  24.         return true;  25. }  26. else if( a == int((k+1)*m) )  27. {  28.     if( b == a + k + 1 )  29.         return true;  30. }  31. return false;  32. </code></pre><p>}  </p><pre><code>33. 34. </code></pre><p>void main()  </p><pre><code>35. </code></pre><p>{  </p><pre><code>36. int a,b;  37. cin&gt;&gt;a&gt;&gt;b;  38. cout&lt;&lt;judge(a,b)&lt;&lt;endl;  39. </code></pre><p>}  </p><p>玩家的策略：<br>    就是把面对的非奇异局势变为奇异局势留给对方。也就是说，玩家必须知道临近的奇异局势是什么，然后把当前局势变成奇异局势。</p><p>问题出现在：编程之美。组合数学。<br>游戏的一个变种：两个人轮流报数，每次至少报一个，最多报十个，谁能报到100者胜。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;取石子游戏是一个古老的博弈游戏，据说是发源于中国，它是组合数学领域的一个经典问题。它有许多不同的玩法，基本上是两个玩家，玩的形式是轮流抓石子，胜利的标准是抓走了最后的石子。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;玩家设定： 先取石子的是玩家A，后取石子的是玩家B。
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java学习第四次笔记</title>
    <link href="https://wadezhx.github.io/2018/12/02/java%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E6%AC%A1%E7%AC%94%E8%AE%B0/"/>
    <id>https://wadezhx.github.io/2018/12/02/java学习第四次笔记/</id>
    <published>2018-12-02T12:28:32.000Z</published>
    <updated>2018-12-06T02:58:11.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java学习第四次笔记"><a href="#java学习第四次笔记" class="headerlink" title="java学习第四次笔记"></a>java学习第四次笔记</h1><p>  小数    浮点数 // 不精确<br>| 类型 |  占用存储空间|  |表数范围  |<br>| — | — | — | — |<br>|   float 单精度| 4 字节  || -3.403e38—3.403e38 |<br>|double 双精度| 8 字节 |   |  -1.7989e308—1.798e308 |     </p><p> 科学计数法  3.14e2; 314e-2<br> 默认是double ，后面加f 强制转换；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">import java.math.*;</span><br><span class="line"></span><br><span class="line">public class TestprimitiveDataType &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[]args)&#123;</span><br><span class="line"></span><br><span class="line">        //测试浮点型变量</span><br><span class="line"></span><br><span class="line">    float &lt;u&gt;a&lt;/u&gt; = 3.14f;//默认是double，放不进去，加f转换</span><br><span class="line"></span><br><span class="line">    double b =6.28;</span><br><span class="line"></span><br><span class="line">    double c = 628e-2;</span><br><span class="line"></span><br><span class="line">    System.out.println(b);</span><br><span class="line"></span><br><span class="line">    System.out.println(c);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    //浮点数不精确，不可以比较；</span><br><span class="line"></span><br><span class="line">    float f = 0.1f;</span><br><span class="line"></span><br><span class="line">    double d = 1/10;</span><br><span class="line"></span><br><span class="line">    System.out.println(f==d);//false</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    float d1 = 1246235867;</span><br><span class="line"></span><br><span class="line">    float d2 = d1+1;</span><br><span class="line"></span><br><span class="line">    if(d1==d2)&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;d1==d2&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;d1!=d2&quot;);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;//精度不够</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;#####&quot;);//使用精确用&lt;u&gt;bigdecimal&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    BigDecimal bd = BigDecimal.valueOf(1.0);</span><br><span class="line"></span><br><span class="line">    bd = bd.subtract(BigDecimal.valueOf(0.1));</span><br><span class="line"></span><br><span class="line">    bd = bd.subtract(BigDecimal.valueOf(0.1));</span><br><span class="line"></span><br><span class="line">    bd = bd.subtract(BigDecimal.valueOf(0.1));</span><br><span class="line"></span><br><span class="line">    bd = bd.subtract(BigDecimal.valueOf(0.1));</span><br><span class="line"></span><br><span class="line">    bd = bd.subtract(BigDecimal.valueOf(0.1));</span><br><span class="line"></span><br><span class="line">    System.out.println(bd);//0.5</span><br><span class="line"></span><br><span class="line">    System.out.println(1.0-0.1-0.1-0.1-0.1-0.1);//0.5000000000000001</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    BigDecimal bd2 = BigDecimal.valueOf(0.1);</span><br><span class="line"></span><br><span class="line">    BigDecimal bd3 = </span><br><span class="line">BigDecimal.valueOf(1.0/10.0);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    System.out.println(bd2.equals(bd3));//true</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="java-math包下面的两个有用的类：BigInteger和-BigDecimal，这两个类可以处理任意长度的数值。BigInteger实现了任意精度的整数运算。BigDecimal实现了任意精度的浮点运算。"><a href="#java-math包下面的两个有用的类：BigInteger和-BigDecimal，这两个类可以处理任意长度的数值。BigInteger实现了任意精度的整数运算。BigDecimal实现了任意精度的浮点运算。" class="headerlink" title="java.math包下面的两个有用的类：BigInteger和 BigDecimal，这两个类可以处理任意长度的数值。BigInteger实现了任意精度的整数运算。BigDecimal实现了任意精度的浮点运算。"></a>java.math包下面的两个有用的类：<u>BigInteger</u>和 <u>BigDecimal</u>，这两个类可以处理任意长度的数值。BigInteger实现了任意精度的整数运算。BigDecimal实现了任意精度的浮点运算。</h6><table><thead><tr><th>类型</th><th>占用存储空间</th><th></th><th>表数范围</th></tr></thead><tbody><tr><td>字符型</td><td>char</td><td>2字节</td><td>‘a’</td></tr><tr><td>布尔型</td><td>boolean</td><td>1位</td><td>即0或1  bit</td></tr></tbody></table><p>字符 unicode  十六进制 0000—FFFF<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Testzifu3 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">    char &lt;u&gt;a&lt;/u&gt; = &apos;z&apos;;</span><br><span class="line"></span><br><span class="line">    char &lt;u&gt;b&lt;/u&gt; = &apos;张&apos;;</span><br><span class="line"></span><br><span class="line">    char c = &apos;\u0061&apos;;</span><br><span class="line"></span><br><span class="line">    System.out.println(c);//a </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    String d = &quot;asdasdf&quot;;//&quot;字符串&quot;；</span><br><span class="line"></span><br><span class="line">    System.out.println(d );</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>\n  换行<br>\t  制表符 tab</p><p>转义符|含义|Unicode值|<br>|—|—|—|<br>|\b|退格（backspace）|\u0008|<br>|\n|换行|\u000a|<br>|\r|回车|\u000d|<br>|\t|制表符（tab）|\u0009|<br>|\“|双引号|\u0022|<br>|\ ‘ |单引号|\u0027|<br>| \\ |反斜杠|\u005c|</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class boolean2 &#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">boolean man = true;</span><br><span class="line"> if(man)//不推荐man==true</span><br><span class="line"> &#123;</span><br><span class="line"> System.out.println(&quot;男性&quot;);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java学习第四次笔记&quot;&gt;&lt;a href=&quot;#java学习第四次笔记&quot; class=&quot;headerlink&quot; title=&quot;java学习第四次笔记&quot;&gt;&lt;/a&gt;java学习第四次笔记&lt;/h1&gt;&lt;p&gt;  小数    浮点数 // 不精确&lt;br&gt;| 类型 |  占用存储
      
    
    </summary>
    
    
      <category term="java" scheme="https://wadezhx.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习第三次笔记</title>
    <link href="https://wadezhx.github.io/2018/11/29/java%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%89%E6%AC%A1%E7%AC%94%E8%AE%B0/"/>
    <id>https://wadezhx.github.io/2018/11/29/java学习第三次笔记/</id>
    <published>2018-11-29T14:38:40.000Z</published>
    <updated>2018-12-06T03:21:53.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wade-zhx"><a href="#wade-zhx" class="headerlink" title="wade.zhx"></a>wade.zhx</h1><h4 id="Java的数据类型可分为两大类："><a href="#Java的数据类型可分为两大类：" class="headerlink" title="Java的数据类型可分为两大类："></a>Java的数据类型可分为两大类：</h4><p><img src="en-resource://database/7196:1" alt="76878d3244bd49c9b4584402f32d1c37.png"></p><h5 id="基本数据类型（primitive-data-type）3类8种"><a href="#基本数据类型（primitive-data-type）3类8种" class="headerlink" title="基本数据类型（primitive data type）3类8种"></a>基本数据类型（primitive data type）3类8种</h5><h4 id="1-Byte-8-bits"><a href="#1-Byte-8-bits" class="headerlink" title="1 Byte =8 bits"></a>1 Byte =8 bits</h4><pre><code>数值型－      整数    </code></pre><table><thead><tr><th>类型</th><th>占用存储空间</th><th></th><th>表数范围</th></tr></thead><tbody><tr><td>byte</td><td>1 字节</td><td>2^7</td><td>（-128~127）</td></tr><tr><td>short</td><td>2 字节</td><td>2^15</td><td>(-3w—3w)</td></tr><tr><td>int</td><td>4 字节</td><td>2^31</td><td>(-21亿—21亿)</td></tr><tr><td>long</td><td>8 字节</td><td>2^ 63</td><td>非常非常大</td></tr></tbody></table><p>默认是 int 后面加L强制转换；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public class TestprimitiveDataType &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[]args)&#123;</span><br><span class="line"></span><br><span class="line">        //测试整形变量</span><br><span class="line"></span><br><span class="line">        int &lt;u&gt;a&lt;/u&gt; = 15;</span><br><span class="line"></span><br><span class="line">        int b = 015;//0开头的是八进制</span><br><span class="line"></span><br><span class="line">        int c = 0x15;//0x开头的是十六进制</span><br><span class="line"></span><br><span class="line">        int d = 0b0001111;//0b开头的都是二进制</span><br><span class="line"></span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        System.out.println(d);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        byte  age  = 30;</span><br><span class="line"></span><br><span class="line">        short  salary  = 30000;</span><br><span class="line"></span><br><span class="line">        int  population = 2100000000;</span><br><span class="line"></span><br><span class="line">        long   globalPopulation = 700000000000000l;</span><br></pre></td></tr></table></figure><pre><code>132115</code></pre><h5 id="引用数据类型（reference-data-type）"><a href="#引用数据类型（reference-data-type）" class="headerlink" title="引用数据类型（reference data type）"></a>引用数据类型（reference data type）</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;wade-zhx&quot;&gt;&lt;a href=&quot;#wade-zhx&quot; class=&quot;headerlink&quot; title=&quot;wade.zhx&quot;&gt;&lt;/a&gt;wade.zhx&lt;/h1&gt;&lt;h4 id=&quot;Java的数据类型可分为两大类：&quot;&gt;&lt;a href=&quot;#Java的数据类型可分为两
      
    
    </summary>
    
    
      <category term="java" scheme="https://wadezhx.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习第二次笔记</title>
    <link href="https://wadezhx.github.io/2018/11/28/java%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E6%AC%A1%E7%AC%94%E8%AE%B0/"/>
    <id>https://wadezhx.github.io/2018/11/28/java学习第二次笔记/</id>
    <published>2018-11-28T12:28:32.000Z</published>
    <updated>2018-12-06T02:58:07.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wade-zhx"><a href="#wade-zhx" class="headerlink" title="wade.zhx"></a>wade.zhx</h1><h5 id="局部变量-local-variable-从属于方法"><a href="#局部变量-local-variable-从属于方法" class="headerlink" title="局部变量(local  variable)   从属于方法"></a>局部变量(local  variable)   从属于方法</h5><pre><code>        {           方法或语句块内部定义的变量。生命周期是从声明位置开始到到方法或语句块执行完毕为止。局部变量在使用前必须先声明、初始化(赋初值)再使用。}</code></pre><h5 id="成员变量（也叫实例变量-member-variable）"><a href="#成员变量（也叫实例变量-member-variable）" class="headerlink" title="成员变量（也叫实例变量  member variable）"></a>成员变量（也叫实例变量  member variable）</h5><pre><code>方法外部、类的内部定义的变量。从属于对象，生命周期伴随对象始终。如果不自行初始化，它会自动初始化成该类型的默认初始值。表2-3实例变量的默认初始值数据类型实始值</code></pre><p>   <img src="en-resource://database/7188:1" alt="31201947b053e56b2ca7ea3b79fbfead.png"></p><h5 id="静态变量（类变量-static-variable）"><a href="#静态变量（类变量-static-variable）" class="headerlink" title="静态变量（类变量 static variable）"></a>静态变量（类变量 static variable）</h5><pre><code>使用static定义。 从属于类，生命周期伴随类始终，从类加载到卸载。最长</code></pre><h5 id="常量-Constant"><a href="#常量-Constant" class="headerlink" title="常量(Constant)"></a>常量(Constant)</h5><pre><code>    一般将1、2、3、’a’、’b’、true、false、”helloWorld”等称为字面常量，    而使用final修饰的PI等称为符号常量。final  type  varName = value;fina int PI = 3.141592653;</code></pre><h5 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h5><p>类成员变量：首字母小写和驼峰原则:  monthSalary</p><p>类名：首字母大写和驼峰原则:  Man, GoodMan</p><p>常量：大写字母和下划线：MAX_VALUE</p><p>方法名：首字母小写和驼峰原则: run(), runRun()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class TestVarible &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        final double PI = 3.14;</span><br><span class="line"></span><br><span class="line">        //PI = 3; 定义无效</span><br><span class="line"></span><br><span class="line">        double r = 4;</span><br><span class="line"></span><br><span class="line">        double area = PI * r * r;</span><br><span class="line"></span><br><span class="line">        double circle = 2 * PI * r;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;area =&quot;+ area);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;circle=&quot;+ circle);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;wade-zhx&quot;&gt;&lt;a href=&quot;#wade-zhx&quot; class=&quot;headerlink&quot; title=&quot;wade.zhx&quot;&gt;&lt;/a&gt;wade.zhx&lt;/h1&gt;&lt;h5 id=&quot;局部变量-local-variable-从属于方法&quot;&gt;&lt;a href=&quot;#局部变量
      
    
    </summary>
    
    
      <category term="java" scheme="https://wadezhx.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习第一次笔记</title>
    <link href="https://wadezhx.github.io/2018/11/26/java%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%AC%94%E8%AE%B0/"/>
    <id>https://wadezhx.github.io/2018/11/26/java学习第一次笔记/</id>
    <published>2018-11-26T14:38:40.000Z</published>
    <updated>2018-12-06T02:58:02.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wade-zhx"><a href="#wade-zhx" class="headerlink" title="wade.zhx"></a>wade.zhx</h1><h2 id="wade-zhx-1"><a href="#wade-zhx-1" class="headerlink" title="wade.zhx"></a><strong>wade.zhx</strong></h2><p>2018年11月28日22:34</p><ol><li><h4 id="工具-eclipse"><a href="#工具-eclipse" class="headerlink" title="工具 eclipse"></a>工具 eclipse</h4></li><li><h4 id="学习网址"><a href="#学习网址" class="headerlink" title="学习网址"></a>学习网址</h4><ol><li><a href="https://www.bilibili.com/video/av29306544/?p=25" target="_blank" rel="noopener">bilibili</a></li><li><a href="http://www.sxt.cn/Java_jQuery_in_action/Java_Identifier.html" target="_blank" rel="noopener">尚学堂 </a></li></ol></li><li><h4 id="记录："><a href="#记录：" class="headerlink" title="记录："></a>记录：</h4> JVM是虚拟机；java可以跨平台是因为虚拟机可以不同系统编译<pre><code>![16e79e25643f6d14796fb28087c339ba.png](en-resource://database/7186:1)</code></pre></li><li><h4 id="DOS命令"><a href="#DOS命令" class="headerlink" title="DOS命令"></a>DOS命令</h4><pre><code>cd  cd ..  dir  cls</code></pre></li><li><p>一个源文件中至多只能声明一个public的类，其它类的个数不限，如果源文件中包含一个public 类，源文件名必须和其中定义的public的类名相同，且以“.java”为扩展名</p><ol start="7"><li>// 单行注释<br>/<em> 多行注释，灵活</em>/<br>/*<em> 文档注释 </em>/</li></ol></li></ol><p>8.</p><h5 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h5><pre><code>必须以字母、下划线_、美元符号$开头。 </code></pre><p> 其它部分可以是字母、下划线“_”、美元符“$”和数字的任意组合。</p><pre><code>表示类名的标识符：每个单词的首字母大写，如Man, GoodMan表示方法和变量的标识符：第一个单词小写，从第二个单词开始首字  母大写，  我们称之为**驼峰原则**，如eat(), eatFood()</code></pre><ol start="9"><li><h5 id="变量本质上就是代表一个”可操作的存储空间”，空间位置是确定的，但是里面放置什么值不确定。"><a href="#变量本质上就是代表一个”可操作的存储空间”，空间位置是确定的，但是里面放置什么值不确定。" class="headerlink" title="变量本质上就是代表一个”可操作的存储空间”，空间位置是确定的，但是里面放置什么值不确定。"></a>变量本质上就是代表一个”可操作的存储空间”，空间位置是确定的，但是里面放置什么值不确定。</h5><ol><li>我们可通过变量名来访问“对应的存储空间”，从而操纵这个“存储空间”存储的值。     </li><li>Java是一种强类型语言，每个变量都必须声明其数据类型。变量的数据类型决定了变量占据存储空间的大小。</li></ol></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;wade-zhx&quot;&gt;&lt;a href=&quot;#wade-zhx&quot; class=&quot;headerlink&quot; title=&quot;wade.zhx&quot;&gt;&lt;/a&gt;wade.zhx&lt;/h1&gt;&lt;h2 id=&quot;wade-zhx-1&quot;&gt;&lt;a href=&quot;#wade-zhx-1&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="java" scheme="https://wadezhx.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>吃苦</title>
    <link href="https://wadezhx.github.io/2018/11/15/%E5%90%83%E8%8B%A6/"/>
    <id>https://wadezhx.github.io/2018/11/15/吃苦/</id>
    <published>2018-11-15T02:22:22.000Z</published>
    <updated>2018-12-06T03:16:18.720Z</updated>
    
    <content type="html"><![CDATA[<h5 id="你不会的东西，觉得难的东西，一定不要躲。"><a href="#你不会的东西，觉得难的东西，一定不要躲。" class="headerlink" title="你不会的东西，觉得难的东西，一定不要躲。"></a>你不会的东西，觉得难的东西，一定不要躲。</h5><h5 id="先搞明白，后精湛，你就比别人优秀了。"><a href="#先搞明白，后精湛，你就比别人优秀了。" class="headerlink" title="先搞明白，后精湛，你就比别人优秀了。"></a>先搞明白，后精湛，你就比别人优秀了。</h5><h5 id="因为大部分人都不舍得花力气去钻研，自动淘汰，所以你执着的努力，就占了大便宜。"><a href="#因为大部分人都不舍得花力气去钻研，自动淘汰，所以你执着的努力，就占了大便宜。" class="headerlink" title="因为大部分人都不舍得花力气去钻研，自动淘汰，所以你执着的努力，就占了大便宜。"></a>因为大部分人都不舍得花力气去钻研，自动淘汰，所以你执着的努力，就占了大便宜。</h5><h5 id="奋斗就是每一天都很难，可一年比一年容易。不奋斗就是每一天都很容易，可一年比一年越难。"><a href="#奋斗就是每一天都很难，可一年比一年容易。不奋斗就是每一天都很容易，可一年比一年越难。" class="headerlink" title="奋斗就是每一天都很难，可一年比一年容易。不奋斗就是每一天都很容易，可一年比一年越难。"></a>奋斗就是每一天都很难，可一年比一年容易。不奋斗就是每一天都很容易，可一年比一年越难。</h5><h5 id="怕吃苦的人吃苦一辈子，不怕吃苦的人吃苦一阵子"><a href="#怕吃苦的人吃苦一辈子，不怕吃苦的人吃苦一阵子" class="headerlink" title="怕吃苦的人吃苦一辈子，不怕吃苦的人吃苦一阵子"></a>怕吃苦的人吃苦一辈子，不怕吃苦的人吃苦一阵子</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;你不会的东西，觉得难的东西，一定不要躲。&quot;&gt;&lt;a href=&quot;#你不会的东西，觉得难的东西，一定不要躲。&quot; class=&quot;headerlink&quot; title=&quot;你不会的东西，觉得难的东西，一定不要躲。&quot;&gt;&lt;/a&gt;你不会的东西，觉得难的东西，一定不要躲。&lt;/h5&gt;&lt;
      
    
    </summary>
    
    
      <category term="吃苦" scheme="https://wadezhx.github.io/tags/%E5%90%83%E8%8B%A6/"/>
    
  </entry>
  
  <entry>
    <title>Oracle 上机实验手册</title>
    <link href="https://wadezhx.github.io/2018/11/15/oracle/"/>
    <id>https://wadezhx.github.io/2018/11/15/oracle/</id>
    <published>2018-11-15T02:22:22.000Z</published>
    <updated>2018-12-06T02:58:13.824Z</updated>
    
    <content type="html"><![CDATA[<p>Oracle上机实验手册</p><p>Oracle管理    2</p><ol><li>Oracle启动和关闭    3</li><li>Oracle用户和权限    4<br>SQL数据操作和查询    6</li><li>SQL简介    7</li><li>Oracle数据类型    7</li><li>创建表和约束    8</li><li>数据操纵语言（DML）    11</li><li>操作符    16</li><li>高级查询    17</li><li>本章总结    25</li><li>本章练习    26<br>子查询和常用函数    28</li><li>子查询    29</li><li>Oracle中的伪列    31</li><li>Oracle函数    34</li><li>本章总结    43</li><li>本章练习    44<br>表空间、数据库对象    46</li><li>Oracle数据库对象    47</li><li>同义词    47</li><li>序列    50</li><li>视图    52</li><li>索引    54</li><li>表空间    56</li><li>本章总结    60</li><li>本章练习    61<br>PL/SQL程序设计    63</li><li>PL/SQL简介    64</li><li>PL/SQL块    65</li><li>PL/SQL数据类型    69</li><li>PL/SQL条件控制和循环控制    71</li><li>PL/SQL中动态执行SQL语句    81</li><li>PL/SQL的异常处理    83</li><li>本章总结    89</li><li>本章练习    90<br>数据库导入导出    92</li><li>Oracle导入导出    93</li><li>EXP导出数据    93</li><li>IMP导入    96</li><li>常见问题    97</li></ol><p>Oracle管理</p><pre><code>主要内容    Oracle创建用户和角色</code></pre><p>    客户端链接Oracle服务器</p><ol><li>Oracle启动和关闭<br>Oracle的启动和关闭是最基本的命令，在SQL*Plus中，启动Oracle必须是sys用户，命令格式是：</li></ol><p>startup open</p><p>图24 Oracle服务启动</p><pre><code>Oracle服务关闭用命令：shutdown immediate</code></pre><p>图25 Oracle服务关闭</p><ol start="2"><li>Oracle用户和权限<br>Oracle中，一般不会轻易在一个服务器上创建多个数据库，在一个数据库中，不同的项目由不同的用户访问，每一个用户拥有自身创建的数据库对象，因此用户的概念在Oracle中非常重要。Oracle的用户可以用CREATE USER命令来创建。其语法是：</li></ol><p>语法结构：创建用户<br>CREATE USER 用户名 IDENTIFIED BY 口令 [ACCOUNT LOCK|UNLOCK]<br>语法解析：<br>    LOCK|UNLOCK创建用户时是否锁定，默认为锁定状态。锁定的用户无法正常的登录进行数据库操作。</p><p>代码演示：创建用户<br>SQL&gt; CREATE USER jerry<br>2  IDENTIFIED BY tom<br>3  ACCOUNT UNLOCK;</p><pre><code> Oracle在SQL*Plus中的命令以分号（；）结尾，代表命令完毕并执行，系统同时会把该命令保存在缓存中，缓存中只保存最近执行过的命令，如果重新执行缓存中的命令，直接使用左斜杠符号（/）。如果命令不以分号结尾，该命令只是写入缓存保存起来，但并不执行。尽管用户成功创建，但是还不能正常的登录Oracle数据库系统，因为该用户还没有任何权限。如果用户能够正常登录，至少需要CREATE SESSION系统权限。Oracle用户对数据库管理或对象操作的权利，分为系统权限和数据库对象权限。系统权限比如：CREATE SESSION，CREATE TABLE等，拥有系统权限的用户，允许拥有相应的系统操作。数据库对象权限，比如对表中的数据进行增删改操作等，拥有数据库对象权限的用户可以对所拥有的对象进行对应的操作。还有一个概念就是数据库角色（role），数据库角色就是若干个系统权限的集合。下面介绍几个常用角色：</code></pre><p>    CONNECT角色，主要应用在临时用户，特别是那些不需要建表的用户，通常只赋予他们CONNECT role。CONNECT是使用Oracle的简单权限，拥有CONNECT角色的用户，可以与服务器建立连接会话（session，客户端对服务器连接，称为会话）。<br>    RESOURCE角色，更可靠和正式的数据库用户可以授予RESOURCE role。RESOURCE提供给用户另外的权限以创建他们自己的表、序列、过程（procedure）、触发器（trigger）、索引（index）等。<br>    DBA角色，DBA role拥有所有的系统权限—-包括无限制的空间限额和给其他用户授予各种权限的能力。用户SYSTEM拥有DBA角色。</p><p>一般情况下，一个普通的用户（如SCOTT），拥有CONNECT和RESOURCE两个角色即可进行常规的数据库开发工作。</p><pre><code>可以把某个权限授予某个角色，可以把权限、角色授予某个用户。系统权限只能由DBA用户授权，对象权限由拥有该对象的用户授权，授权语法是： </code></pre><p>语法结构：授权<br>GRANT角色|权限 TO 用户（角色）</p><p>代码演示：授权<br>SQL&gt; GRANT CONNECT TO jerry;<br>授权成功。<br>SQL&gt; GRANT RESOURCE TO jerry;<br>授权成功。<br>SQL&gt;</p><p>语法结构：其他操作<br>//回收权限<br>REVOKE 角色|权限 FROM 用户（角色）<br>//修改用户的密码<br>ALTER USER 用户名 IDENTIFIED BY 新密码<br>//修改用户处于锁定（非锁定）状态<br>ALTER USER 用户名 ACCOUNT LOCK|UNLOCK</p><p>第2章</p><p>SQL数据操作和查询</p><pre><code>主要内容    Oracle数据类型</code></pre><p>    SQL建表和约束<br>    SQL对数据增删改<br>    SQL查询<br>    Oracle伪列</p><ol><li>SQL简介<br>在Oracle开发中，客户端把SQL语句发送给服务器，服务器对SQL语句进行编译、执行，把执行的结果返回给客户端。Oracle SQL语句由如下命令组成：<br>    数据定义语言（DDL），包括CREATE（创建）命令、ALTER（修改）命令、DROP（删除）命令等。<br>    数据操纵语言（DML），包括INSERT（插入）命令、UPDATE（更新）命令、DELETE（删除）命令、SELECT … FOR UPDATE（查询）等。<br>    数据查询语言（DQL），包括基本查询语句、Order By子句、Group By子句等。<br>    事务控制语言（TCL），包括COMMIT（提交）命令、SAVEPOINT（保存点）命令、ROLLBACK（回滚）命令。<br>    数据控制语言（DCL），GRANT（授权）命令、REVOKE（撤销）命令。</li></ol><p>目前主流的数据库产品（比如：SQL Server、Oracle）都支持标准的SQL语句。数据定义语言，表的增删改操作，数据的简单查询，事务的提交和回滚，权限的授权和撤销等，Oracle与SQL Server在操作上基本一致。</p><ol start="2"><li>Oracle数据类型<br>Oracle数据库的核心是表，表中的列使用到的常见数据类型如下：</li></ol><p>类型    含义<br>CHAR(length)    存储固定长度的字符串。参数length指定了长度，如果存储的字符串长度小于length，用空格填充。默认长度是1，最长不超过2000字节。<br>VARCHAR2(length)    存储可变长度的字符串。length指定了该字符串的最大长度。默认长度是1，最长不超过4000字符。<br>NUMBER(p，s)    既可以存储浮点数，也可以存储整数，p表示数字的最大位数（如果是小数包括整数部分和小数部分和小数点，p默认是38为），s是指小数位数。<br>DATE    存储日期和时间，存储纪元、4位年、月、日、时、分、秒，存储时间从公元前4712年1月1日到公元后4712年12月31日。<br>TIMESTAMP    不但存储日期的年月日，时分秒，以及秒后6位，同时包含时区。<br>CLOB    存储大的文本，比如存储非结构化的XML文档<br>BLOB    存储二进制对象，如图形、视频、声音等。<br>表1  Oracle的部分数据类型</p><pre><code>对应NUMBER类型的示例：</code></pre><p>格式    输入的数字    实际的存储<br>NUMBER    1234.567    1234.567<br>NUMBER（6，2）    123.4567    123.46<br>NUMBER（4，2）    12345.67    输入的数字超过了所指定的精度，数据库不能存储<br>表2  Number示例</p><pre><code>对于日期类型，可以使用sysdate内置函数可以获取当前的系统日期和时间，返回DATE类型，用systimestamp函数可以返回当前日期、时间和时区。</code></pre><p>图1  sysdate和sysTimestamp</p><pre><code>Oracle的查询中，必须使用“select 列… from 表”的完整语法，当查询单行函数的时候，from后面使用DUAL表，dual表在系统中只有一行一列，该表在输出单行函数时为了select…from的语法完整性而使用。</code></pre><ol start="3"><li>创建表和约束<br>Oracle创建表同SQL Server一样，使用CREATE TABLE命令来完成。创建约束则使用如下命令：<br>语法格式：ALTER TABLE命令<br>ALTER TABLE 表名 ADD CONSTRAINT 约束名 约束内容。</li></ol><p>不论创建表还是约束，与SQL Server基本相同，注意：在Oracle中default是一个值，而SQL Server中default是一个约束，因此Oracle的default设置可以在建表的时候创建。</p><p>案例1：创建一个学生信息（INFOS）表和约束</p><p>代码演示：Oracle创建表和约束<br>CREATE TABLE INFOS<br>(<br>  STUID VARCHAR2(7) NOT NULL,    –学号 学号=‘S’+班号+2位序号<br>  STUNAME VARCHAR2(10) NOT NULL,  –姓名<br>  GENDER VARCHAR2(2) NOT NULL,    –性别<br>  AGE NUMBER(2) NOT NULL,        –年龄<br>  SEAT NUMBER(2) NOT NULL,        –座号<br>  ENROLLDATE DATE,      –入学时间<br>  STUADDRESS VARCHAR2(50) DEFAULT ‘地址不详’,      –住址<br>  CLASSNO VARCHAR2(4) NOT NULL    –班号 班号=学期序号+班级序号<br>)<br>/  ①<br>ALTER TABLE INFOS ADD CONSTRAINT PK_INFOS PRIMARY KEY(STUID)  ②<br>/<br>ALTER TABLE INFOS ADD CONSTRAINT CK_INFOS_GENDER<br>CHECK(GENDER = ‘男’ OR GENDER = ‘女’)  ③<br>/<br>ALTER TABLE INFOS ADD CONSTRAINT CK_INFOS_SEAT<br>CHECK(SEAT &gt;=0 AND SEAT &lt;=50)  ④<br>/<br>ALTER TABLE INFOS ADD CONSTRAINT CK_INFOS_AGE<br>CHECK(AGE &gt;=0 AND AGE&lt;=100)  ⑤<br>/<br>ALTER TABLE INFOS ADD CONSTRAINT CK_INFOS_CLASSNO<br>CHECK((CLASSNO &gt;=’1001’ AND CLASSNO&lt;=’1999’) OR<br>(CLASSNO &gt;=’2001’ AND CLASSNO&lt;=’2999’))  ⑥<br>/<br>ALTER TABLE INFOS ADD CONSTRAINTS UN_STUNAME UNIQUE(STUNAME)  ⑦<br>/<br>代码解析：<br>①    在Oracle代码中，“/”执行缓存区中的语句，由于缓冲区中只存储一条刚刚保存过语句，由于每条语句没有用分号结尾，只是保存在缓冲区，因此每条语句后面都有单独一行“/”。<br>②    创建一个主键约束。<br>③    与 ④ ⑤ ⑥ ⑦一起创建各种check约束。其中⑦是唯一约束，表示该列值是唯一的，列中的值不能重复。</p><p>Oracle中创建外键约束与SQL Server相同。比如：现有成绩表定义如下：</p><p>案例2：创建一个成绩表（SCORES）表和约束</p><p>代码演示：Oracle创建表和约束<br>CREATE TABLE SCORES<br>(<br>     ID NUMBER ,        –ID  ①<br>     TERM VARCHAR2(2),                    –学期 S1或S2<br>      STUID VARCHAR2(7) NOT NULL,            –学号<br>      EXAMNO VARCHAR2(7) NOT NULL,            –考号 E+班号+序号<br>      WRITTENSCORE NUMBER(4,1) NOT NULL,    –笔试成绩<br>      LABSCORE NUMBER(4,1) NOT NULL        –机试成绩<br>)<br>ALTER TABLE SCORES<br>    ADD CONSTRAINT CK_SCORES_TERM CHECK(TERM = ‘S1’ OR TERM =’S2’)<br>/<br>ALTER TABLE SCORES<br>    ADD CONSTRAINT FK_SCORES_INFOS_STUID FOREIGN KEY(STUID) REFERENCES INFOS(STUID)  ②<br>/<br>代码解析：<br>①    SQL Server中可以使用identify创建自动增长列，但是Oracle中的自动增长需要借助序列（Sequence）完成，在后面章节中讲解。<br>②    Oracle中的外键约束定义。</p><ol start="4"><li>数据操纵语言（DML）<br>数据操纵语言（DML）用于对数据库的表中数据进行添加、修改、删除和SELECT…For UPDATE(后面专门学习该查询)操作。对比一期学习过的SQL Server操作，接下来一一介绍在Oracle中的操作。</li></ol><p>    简单查询</p><p>数据查询是用SELECT命令从数据库的表中提取信息。SELECT语句的语法是：</p><p>语法结构：简单查询<br>SELECT *|列名|表达式 FROM 表名 WHERE 条件 ORDER BY 列名<br>语法解析：</p><ol><li>*表示表中的所有列。</li><li>列名可以选择若干个表中的列名，各个列表中间用逗号分隔。</li><li>表达式可以是列名、函数、常数等组成的表达式。</li><li>WHERE子句是查询的条件。</li><li>ORDER BY 要求在查询的结果中排序，默认是升序。</li></ol><p>图2  数据查询</p><pre><code>Oracle中可以把查询的结果根据结果集中的表结构和数据形成一张新表。</code></pre><p>语法结构：根据结果集创建表<br>CREATE TABLE 表名 AS SELECT语句</p><p>代码演示：根据结果集创建表<br>SQL&gt; CREATE TABLE INFOS1 AS SELECT * FROM INFOS;<br>TABLE CREATED</p><pre><code>使用上面命令创建的新表中，不存在任何约束，并且把查询的数据一起插入到新表中。如果只复制表结构，只需使查询的条件不成立（比如where 1=2），就不会查询从出任何数据，从而复制一个表结构。</code></pre><p>代码演示：复制表结构<br>SQL&gt; CREATE TABLE INFOS2 AS SELECT * FROM INFOS WHERE 1=2;<br>TABLE CREATED</p><p>    数据插入</p><p>用INSERT命令完成对数据的插入。</p><p>语法结构：根据结果集创建表<br>INSERT INTO 表名(列名1，列名2……) VALUES (值1，值2……)<br>语法解析：</p><ol><li>列名可以省略。当省略列名时，默认是表中的所有列名，列名顺序为表定义中列的先后顺序。</li><li>值的数量和顺序要与列名的数量和顺序一致。值的类型与列名的类型一致。</li></ol><p>代码演示：向INFOS表和SCORES表中插入数据<br>SQL&gt; INSERT INTO INFOS VALUES (  ①<br>  2  ‘s100102’, ‘林冲’, ‘男’, 22, 2,<br>  3  TO_DATE(‘2009-8-9 06:30:10’,’ YYYY-MM-DD HH24:MI:SS ‘),  ②<br>  4  ‘西安’, ‘1001’<br>  5  )<br>  6  /<br>1 row inserted<br>SQL&gt; INSERT INTO INFOS VALUES (<br>‘s100104’,’阮小二’,’男’,26,3,SYSDATE,default,’1001’);  ③<br> 1 row inserted<br>SQL&gt;COMMIT;  ④<br>代码解析：<br>①    表名后面缺省了列名，默认是表Infos中的所有列名，values中的值要与表中列一一对应，包括顺序和数据类型的对应。在SQL*Plus中一条语句可以写在多行，那么从第二行开始，sqlplus会为每一行前面给出行号。<br>②    在Oracle中，日期是国际化的，不同的区域安装的数据库，默认的日期格式不同，因此为了程序便于移植，日期的输入要使用TO_DATE函数对日期格式化后输入，采用格式化字符串对日期进行格式化时，格式化字符串中字符不区分大小写，常见的格式化字符如下：</p><ol><li>yyyy表示四位年份</li><li>mm表示两位月份，比如3月表示为03</li><li>dd表示两位日期</li><li>hh24表示小时从0-23，hh12也表示小时从0-11。</li><li>mi 表示分钟</li><li>ss表示秒<br>③    在遇到存在默认值的列时，可以使用default值代替。<br>④    commit是把用户操作（添加、删除、修改操作）提交，只有提交操作后，数据才能真正更新到表中，否则其他用户无法查询到当前用户操作的结果。</li></ol><p>在Oracle中，一个INSERT命令可以把一个结果集一次性插入到一张表中。使用的语句是：INSERT INTO 表 SELECT子句，如下示例：</p><p>代码演示：INSERT向表中插入一个结果集<br>SQL&gt; INSERT INTO INFOS2 SELECT * FROM INFOS;<br>5 rows inserted </p><p>在这种语法下，要求结果集中每一列的数据类型必须与表中的每一列的数据类型一致，结果集中的列的数量与表中的列的数量一致。比如表INFOS2，该表的结构与INFO表一样，那么可以把INFO表中的所有记录一次性插入到INFOS2表中。</p><p>Oracle的简单查询和SQL Server一样都可以在查询列中使用常量，如图： </p><p>图3  Select中的常量</p><p>可以使用刚才的做法，把该结果集中的数据插入到表INFOS中。</p><p>代码演示：INSERT向表中插入一个常量结果集<br>SQL&gt; INSERT INTO INFOS<br>SELECT ‘s100106’,’卢俊义’,’男’,23,5,<br>               TO_DATE(‘2009-8-9 08:00:10’,’YYYY-MM-DD HH24:MI:SS’),<br>               ‘青龙寺’,’1001’<br>FROM DUAL;<br>1 rows inserted<br>SQL&gt;COMMIT;</p><p>    更新数据</p><p>Oracle在表中更新数据的语法是：</p><p>语法结构：UPDATE操作<br>UPDATE 表名 SET 列名1=值，列名2=值…… WHERE 条件</p><p>代码演示：UPDATE操作<br>SQL&gt; UPDATE INFOS SET CLASSNO=’1002’,STUADDRESS=’山东莱芜’<br>WHERE STUNAME=’阮小二’;<br>1 rows updated<br>SQL&gt; commit;</p><p>    删除数据</p><p>Oracle在表中删除数据的语法是：</p><p>语法结构：DELETE操作<br>DELETE FROM表名 WHERE 条件</p><p>代码演示：DELETE操作<br>SQL&gt; DELETE FROM INFOS WHERE STUID=’s100103’;<br>1 ROW DELETED<br>SQL&gt; COMMIT;</p><p>    TRUNCATE</p><p>在数据库操作中， TRUNCATE命令（是一个DDL命令）可以把表中的所有数据一次性全部删除，语法是：</p><p>语法结构：TRUNCATE<br>TRUNCATE TABLE 表名</p><p>TRUNCATE和DELETE都能把表中的数据全部删除，他们的区别是：</p><ol><li>TRUNCATE是DDL命令，删除的数据不能恢复；DELETE命令是DML命令，删除后的数据可以通过日志文件恢复。</li><li>如果一个表中数据记录很多，TRUNCATE相对DELETE速度快。</li></ol><p>由于TRUNCATE命令比较危险，因此在实际开发中，TRUNCATE命令慎用。</p><pre><code>Oracle默认安装中，已经创建了一个SCOTT用户，默认密码是：tiger，该用户下有四张表分别是：雇员表（EMP），部门表（DEPT），工资登记表和奖金表，请参考本章后面的附表。接下来很多操作都是在该用户下完成的。</code></pre><ol start="5"><li>操作符<br>Oracle开发中，依然存在算术运算，关系运算，和逻辑运算。</li></ol><p>    算术运算</p><p>Oracle中的算术运算符，没有C#中的算术运算符丰富，只有+、-、*、/四个，其中除号(/)的结果是浮点数。求余运算只能借助函数：MOD(x,y)：返回x除以y的余数。</p><p>案例3：每名员工年终奖是2000元，请显示基本工资在2000元以上的员工的月工资，年总工资。<br>该案例的表请参见本章练习的附表1、附表2、附表3，这三张表是ORACLE 10g自带的。</p><p>代码演示：查询中的算术运算<br>SQL&gt; SELECT ENAME,SAL,(SAL<em>12+2000) FROM EMP WHERE SAL&gt;2000;<br>ENAME     SAL     (SAL</em>12+2000)<br>JONES     2975     37700<br>BLAKE     2850     36200<br>CLARK     2450     31400<br>SCOTT     3000     38000<br>KING     5000     62000<br>FORD     3000     38000<br>6 rows selected</p><p>    关系运算和逻辑运算</p><p>Oracle中Where子句经中经常见到关系运算和逻辑运算，常见的关系运算有：</p><p>运算符    说明    运算符    说明<br>=    等于     &gt;    大于<br>&lt;&gt;或者!=    不等于    &lt;=    小于或者等于<br>&lt;    小于    &gt;=    大于或者等于<br>表3  Oracle的关系运算符</p><p>逻辑运算符有三个：AND、OR、NOT</p><p>关系运算和逻辑运算与前面SQL Server学习过的一致。</p><p>    字符串连接操作符（||）</p><p>在Oracle中，字符串的连接用双竖线（||）表示。比如，在EMP表中，查询工资在2000元以上的姓名以及工作。</p><p>代码演示：字符串连接<br>SQL&gt; SELECT (ENAME || ‘is a ‘ || JOB) AS “Employee Details”  ①<br>  2  FROM EMP<br>  3  WHERE SAL&gt;2000; </p><h2 id="Employee-Details"><a href="#Employee-Details" class="headerlink" title="Employee Details"></a>Employee Details</h2><p>JONESis a MANAGER<br>BLAKEis a MANAGER<br>CLARKis a MANAGER<br>SCOTTis a ANALYST<br>KINGis a PRESIDENT<br>FORDis a ANALYST<br>6 rows selected<br>代码解析：<br>①    Oracle中字符串可以用单引号，也可以用双引号，在别名中存在空格时，必须用双引号。在表名、列名时用双引号。</p><ol start="6"><li>高级查询<br>在第一期学习过SQL的简单查询和连接查询。现在学习一些新的SQL操作符。</li></ol><p>    消除重复行</p><p>在Oracle查询中结果中，可能出现若干行相同的情况，那么可以使用DISTINCT消除重复行。具体的用法如示例：</p><p>代码演示：DISTINCT消除重复行<br>SQL&gt; SELECT DISTINCT DEPTNO FROM EMP; </p><h2 id="DEPTNO"><a href="#DEPTNO" class="headerlink" title="DEPTNO"></a>DEPTNO</h2><pre><code>302010</code></pre><p>    NULL操作</p><p>如果某条记录中有缺少的数据值，就是空值（NULL值）。空值不等于0或者空格，空值是指未赋值、未知或不可用的值。任何数据类型的列都可以包括NULL值，除非该列被定义为非空或者主键。</p><p>代码演示：EMP中的NULL值<br>SQL&gt; SELECT ENAME,JOB,SAL,COMM FROM EMP WHERE SAL&lt;2000;<br>ENAME     JOB     SAL     COMM<br>SMITH     CLERK     800<br>ALLEN     SALESMAN     1600     300<br>WARD     SALESMAN     1250     500<br>MARTIN     SALESMAN     1250     1400<br>TURNER     SALESMAN     1500     0<br>ADAMS     CLERK     1100<br>JAMES     CLERK     950<br>7 rows selected</p><pre><code>在查询条件中NULL值用IS NULL作条件，非NULL值用NOT IS NULL做条件。    </code></pre><p>案例4：查询EMP表中没有发奖金的员工。</p><p>代码演示：NULL值查询<br>SQL&gt; SELECT ENAME,JOB,SAL,COMM FROM EMP<br>2   WHERE SAL&lt;2000 AND COMM IS NULL;<br> ENAME     JOB     SAL     COMM<br>SMITH     CLERK     800<br>ADAMS     CLERK     1100<br>JAMES     CLERK     950<br>MILLER     CLERK     1300     </p><p>    IN 操作</p><p>在Where子句中可以使用IN操作符来查询其列值在指定的列表中的行。比如：查询出工作职责是SALESMAN、PRESIDENT或者ANALYST的员工。条件有两种表示方法：</p><ol><li>WHERE job = ‘SALESMAN ‘ OR job = ‘PRESIDENT ‘ OR job = ‘ANALYST ‘</li><li>WHERE job IN (‘SALESMAN’, ‘PRESIDENT’, ‘ANALYST’)</li></ol><p>代码演示：IN操作<br>SQL&gt; SELECT ENAME,JOB,SAL FROM EMP<br>2  WHERE job IN (‘SALESMAN’, ‘PRESIDENT’, ‘ANALYST’);<br>ENAME     JOB     SAL<br>ALLEN     SALESMAN     1600<br>WARD     SALESMAN     1250<br>MARTIN     SALESMAN     1250<br>SCOTT     ANALYST     3000<br>KING     PRESIDENT     5000<br>TURNER     SALESMAN     1500<br>FORD     ANALYST     3000<br>7 rows selected</p><pre><code>对应IN操作的还有NOT IN，用法一样，结果相反。</code></pre><p>    BETWEEN…AND…</p><p>在WHERE子句中，可以使用BETWEEN操作符来查询列值包含在指定区间内的行。比如，查询工资从1000到2000之间的员工。可以使用传统方法：</p><pre><code>WHERE SAL&gt;=1000 AND SAL&lt;=2000也可以使用：    WHERE SAL BETWEEN 1000 AND 2000BWTWEEN操作所指定的范围也包括边界。</code></pre><p>代码演示：BETWEEN操作<br>SQL&gt; SELECT ename,job,sal FROM EMP WHERE sal BETWEEN 1000 AND 2000;<br>ENAME     JOB     SAL<br>ALLEN     SALESMAN     1600<br>WARD     SALESMAN     1250<br>MARTIN     SALESMAN     1250<br>TURNER     SALESMAN     1500<br>ADAMS     CLERK     1100<br>MILLER     CLERK     1300<br>6 rows selected</p><p>    LIKE模糊查询</p><p>在一些查询时，可能把握不准需要查询的确切值，比如百度搜索时输入关键字即可查询出相关的结果，这种查询称为模糊查询。模糊查询使用LIKE关键字通过字符匹配检索出所需要的数据行。字符匹配操作可以使用通配符“%”和“_”:<br>    %：表示零个或者多个任意字符。<br>    _：代表一个任意字符。</p><p>语法是：LIKE ‘字符串’[ESCAPE ‘字符’]。匹配的字符串中，ESCAPE后面的“字符”作为转义字符。与一期SQLServer中ESCAPE用法相同。</p><p>通配符表达式    说明<br>‘S%’    以S开头的字符串。<br>‘_S%’    第二个字符时S的字符串。<br>‘%30\%%’ escape ‘\’    包含“30%”的字符串，“\”指转义字符，“\%”在字符串中表示一个字符“%”。<br>表4  通配符示例</p><p>案例5：显示员工名称以J开头以S结尾的员工的姓名、工资和工资。</p><p>代码演示：LIKE操作<br>SQL&gt; SELECT ENAME,JOB,SAL FROM EMP WHERE ENAME LIKE ‘J%S’;</p><p>ENAME      JOB             SAL</p><hr><p>JONES      MANAGER     2975.00<br>JAMES      CLERK         950.00</p><p>    集合运算</p><p>集合运算就是将两个或者多个结果集组合成为一个结果集。集合运算包括：<br>    INTERSECT(交集)，返回两个查询共有的记录。<br>    UNION ALL(并集)，返回各个查询的所有记录，包括重复记录。<br>    UNION(并集)，返回各个查询的所有记录，不包括重复记录。<br>    MINUS(补集)，返回第一个查询检索出的记录减去第二个查询检索出的记录之后剩余的记录。</p><p>当使用集合操作的时候，要注意：查询所返回的列数以及列的类型必须匹配，列名可以不同。</p><pre><code>案例6：查询出dept表中哪个部门下没有员工。只需求出dept表中的部门号和emp表中的部门号的补集即可。</code></pre><p>代码演示：求补运算<br>SQL&gt; SELECT DEPTNO FROM DEPT<br>  2  MINUS<br>  3  SELECT DEPTNO FROM EMP; </p><h2 id="DEPTNO-1"><a href="#DEPTNO-1" class="headerlink" title="DEPTNO"></a>DEPTNO</h2><pre><code>40前面学习过可以通过insert into …select把一个结果集插入到另一张结构相同的表中，因此可以使用union把若干条记录一次性插入到一张表中。</code></pre><p>代码演示：用union插入多条数据<br>SQL&gt; INSERT INTO DEPT<br>  2  SELECT 50,’公关部’,’台湾’ FROM DUAL<br>  3  UNION<br>  4  SELECT 60,’研发部’,’西安’ FROM DUAL<br>  5  UNION<br>  6  SELECT 70,’培训部’,’西安’ FROM DUAL<br>  7  /<br>3 rows inserted</p><p>    连接查询</p><p>在SQL Server中已经学习过内联接(inner join)、外联接(outer join)，外联接又分为左外联接(left outer join)和右外联接(right outer join)。Oracle中对两个表或者若干表之间的外联接用（+）表示。</p><p>案例7：请查询出工资大于2000元的，员工姓名，部门，工作，工资。</p><p>由于部门名称在dept中，其他的信息在emp表中，需要内联接才能完成。</p><p>代码演示：内联接<br>SQL&gt; SELECT e.ENAME,e.JOB,e.SAL,d.DNAME<br>  2  FROM emp e,dept d<br>  3  WHERE e.deptno=d.deptno<br>  4  AND e.SAL&gt;2000;<br>ENAME     JOB     SAL     DNAME<br>JONES     MANAGER     2975     RESEARCH<br>BLAKE     MANAGER     2850     SALES<br>CLARK     MANAGER     2450     ACCOUNTING<br>SCOTT     ANALYST     3000     RESEARCH<br>KING     PRESIDENT     5000     ACCOUNTING<br>FORD     ANALYST     3000     RESEARCH<br>6 rows selected</p><pre><code>也可以使用SQL/92标准中的内联接：</code></pre><p>代码演示：内联接<br>SELECT e.ENAME,e.JOB,e.SAL,d.DNAME<br> FROM EMP e INNER JOIN DEPT d ON e.DEPTNO=d.DEPTNO<br>WHERE e.SAL&gt;2000        </p><p>这里INNER JOIN中，关键字INNER可以省略。</p><p>案例8：请查询出每个部门下的员工姓名，工资。<br>案例分析：<br>Emp表用外键deptno引用Dept表中的deptno，在Dept表中如果有某些部门没有员工，那么用内联接，没有员工的部门将无法显示，因此必须以Dept表为基准的外联接。</p><p>代码演示：外联接<br>SQL&gt; SELECT e.ENAME,e.JOB,e.SAL,d.DNAME<br>  2  FROM EMP e ,DEPT d<br>  3  WHERE  e.DEPTNO(+)=d.DEPTNO  ①<br>  4  /<br>ENAME     JOB     SAL     DNAME<br>SMITH     CLERK     800     RESEARCH<br>ALLEN     SALESMAN     1600     SALES<br>WARD     SALESMAN     1250     SALES<br>JONES     MANAGER     2975     RESEARCH<br>MARTIN     SALESMAN     1250     SALES<br>BLAKE     MANAGER     2850     SALES<br>CLARK     MANAGER     2450     ACCOUNTING<br>SCOTT     ANALYST     3000     RESEARCH<br>KING     PRESIDENT     5000     ACCOUNTING<br>TURNER     SALESMAN     1500     SALES<br>ADAMS     CLERK     1100     RESEARCH<br>JAMES     CLERK     950     SALES<br>FORD     ANALYST     3000     RESEARCH<br>MILLER     CLERK     1300     ACCOUNTING<br>                  公关部<br>                  研发部<br>                  培训部<br>                  OPERATIONS </p><p> 18 rows selected<br>代码解析：<br>①     (+)：Oracle专用的联接符，在条件中出现在左边指右外联接，出现在右边指左外联接。</p><pre><code>也可以使用SQL/92标准的写法：</code></pre><p>代码演示：外联接<br>SELECT e.ENAME,e.JOB,e.SAL,d.DNAME<br>FROM EMP e RIGHT OUTER JOIN DEPT d ON e.DEPTNO=d.DEPTNO</p><pre><code>这里RIGHT OUTER JOIN中，关键字OUTER可以省略。 虽然Oracle自身的联接查询语法比较好写，同时容易理解，但是为了程序便于移植，推荐使用SQL/92表中的联接查询。同时也可以与SQL Server获得一致。</code></pre><ol start="7"><li>本章总结<br>    Oracle SQL语句中有数据操纵语言（DML）、数据定义语言（DDL）、数据控制语言（DCL）、事务控制语言（TCL）等等。<br>    DML语句包括增删改查语句，DDL语句包括数据库对象创建、修改和删除语句，数据控制命令包括GRANT、REVOKE等，事务控制命令有COMMIT、ROLLBACK等。<br>    数据库中建表常用的类型有：数字类型number（p，s），可变字符串varchar2（length），日期date。<br>    Oracle中default是一个值，在Oracle中不存在default约束。<br>    Oracle的增删改语句与SQL Server基本一致，都是使用INSERT、UPDATE、DELETE完成。<br>    Oracle高级查询中要注意：DISTINCT、NULL、IN、BETWEEN…AND…。<br>    集合操作有：UNION、UNION ALL、INTESECT、MINUS。<br>    联接查询有内联接和外联接。</li></ol><ol start="8"><li>本章练习</li><li>创建一查询，显示与Blake在同一部门工作的雇员的项目和受雇日期，但是Blake不包含在内。</li><li>显示位置在Dallas的部门内的雇员姓名、变化以及工作。</li><li>显示被King直接管理的雇员的姓名以及工资。</li><li>创建一查询，显示能获得与Scott一样工资和奖金的其他雇员的姓名、受雇日期以及工资。</li></ol><p>附表1：Scott表中的EMP表：员工表<br>序号    列名    类型    说明<br>1    EMPNO    NUMBER(4)    员工编号，EMP表主键<br>2    ENAME    VARCHAR2(10)    员工姓名<br>3    JOB    VARCHAR2(9)    员工工作<br>4    MGR    NUMBER(4)    员工的领导编号，引用EMPNO<br>5    HIREDATE    DATE    入职日期<br>6    SAL    NUMBER(7,2)    员工工资<br>7    COMM    NUMBER(7,2)    员工奖金<br>8    DEPTNO    NUMBER(2)    员工部门编号，是表DEPT的外键。</p><p>附表2：Scott表中的DEPT表：部门表<br>序号    列名    类型    说明<br>1    DEPTNO    NUMBER(2)    部门编号，主键<br>2    DNAME    VARCHAR2(14)    部门名称<br>3    LOC    VARCHAR2(13)    部门位置</p><p>附表3：Scott表中的SALGRADE表：工资等级表<br>序号    列名    类型    说明<br>1    GRADE    NUMBER    等级<br>2    LOSAL    NUMBER    此等级下最低工资<br>3    HISAL    NUMBER    此等级下最高工资</p><p>章节知识结构图</p><p>第3章</p><p>子查询和常用函数</p><pre><code>主要内容    子查询</code></pre><p>    伪列<br>    锁的概念</p><ol><li>子查询<br>子查询在SELECT、UPDATE、DELETE语句内部可以出现SELECT语句。内部的SELECT语句结果可以作为外部语句中条件子句的一部分，也可以作为外部查询的临时表。子查询的类型有：</li><li>单行子查询：不向外部返回结果，或者只返回一行结果。</li><li>多行子查询：向外部返回零行、一行或者多行结果。</li></ol><p>案例1：查询出销售部（SALES）下面的员工姓名，工作，工资。<br>案例分析<br>该问题可以用联接查询实现，由于所需的结果信息都在Emp表中，可以先从Dept表中查询出销售部对应的部门号，然后根据当前部门号再到Emp表中查询出符合该部门的员工记录即可。从销售表中查询出的结果可以作为Emp表中查询的条件，SQL语句实现如下：</p><p>代码演示：单行子查询<br>SQL&gt; SELECT ENAME,JOB,SAL FROM EMP<br>  2  WHERE DEPTNO=(SELECT DEPTNO FROM DEPT WHERE DNAME=’SALES’)  ①<br>  3  /<br> ENAME     JOB     SAL<br>ALLEN     SALESMAN     1600<br>WARD     SALESMAN     1250<br>MARTIN     SALESMAN     1250<br>BLAKE     MANAGER     2850<br>TURNER     SALESMAN     1500<br>JAMES     CLERK     950<br> 6 rows selected<br>代码解析：<br>①    内部查询的结果作为外部查询的条件。</p><p>需要注意：<br>    如果内部查询不返回任何记录，则外部条件中字段DEPTNO与NULL比较永远为假，也就是说外部查询不返还任何结果。<br>    在单行子查询中外部查询可以使用=、&gt;、&lt;、&gt;=、&lt;=、&lt;&gt;等比较运算符。<br>    内部查询返回的结果必须与外部查询条件中的字段（DEPTNO）匹配。<br>    如果内部查询返回多行结果则出现错误。</p><p>案例2：查询出Emp表中比任意一个销售员(“SALESMAN”)工资低的员工姓名、工作、工资。<br>案例分析<br>销售员在Emp表中有很多条记录，每个人工资不相等，如果返回“比任意员工的工资还低”的条件，返回比“最高工资还低”即可。如果用子查询做，子查询中就会返回多条记录。用普通的关系符（&gt;、&lt;等）运行就会出错。这时候需要用关键字ANY。ANY放在比较运算符后面，表示“任意”的意思。</p><p>代码演示：ANY子查询<br>SQL&gt; SELECT ENAME,JOB,SAL FROM EMP<br>  2  WHERE SAL&lt;ANY (SELECT SAL FROM EMP WHERE JOB=’SALESMAN’)  ①<br>  3  /<br>ENAME     JOB     SAL<br>SMITH     CLERK     800<br>JAMES     CLERK     950<br>ADAMS     CLERK     1100<br>WARD     SALESMAN     1250<br>MARTIN     SALESMAN     1250<br>MILLER     CLERK     1300<br>TURNER     SALESMAN     1500<br> 7 rows selected<br>代码解析：<br>①    <a href="any:比子查询结果中任意的值都小，也就是说，比子查询结果中最大值还小，那么同理" target="_blank" rel="noopener">any:比子查询结果中任意的值都小，也就是说，比子查询结果中最大值还小，那么同理</a>any表示比子查询结果中最小的还大。</p><p>案例3：查询出比所有销售员的工资都高的员工姓名，工作，工资。</p><p>案例分析<br>ANY可以表示任意的，但本案例中要求比所有销售员工资都高，那么就要使用另外一个关键字ALL。ALL与关系操作符一起使用，表示与子查询中所有元素比较。</p><p>代码演示：ALL子查询<br>SQL&gt; SELECT ENAME,JOB,SAL FROM EMP<br>  2  WHERE SAL&gt;ALL (SELECT SAL FROM EMP WHERE JOB=’SALESMAN’)  ①<br>  3  /<br> ENAME     JOB     SAL<br>JONES     MANAGER     2975<br>BLAKE     MANAGER     2850<br>CLARK     MANAGER     2450<br>SCOTT     ANALYST     3000<br>KING     PRESIDENT     5000<br>FORD     ANALYST     3000<br>6 rows selected<br>代码解析：<br>①    &gt;ALL：比子查询结果中所有值还要大，也就是说，比子查询结果中最大值还要大。&lt;ALL表示比最小值还要小。</p><p>对于子查询还可以使用IN和NOT IN操作符进行操作。</p><ol start="2"><li>Oracle中的伪列<br>在Oracle的表的使用过程中，实际表中还有一些附加的列，称为伪列。伪列就像表中的列一样，但是在表中并不存储。伪列只能查询，不能进行增删改操作。接下来学习两个伪列：ROWID和ROWNUM。</li></ol><p>    ROWID</p><p>表中的每一行在数据文件中都有一个物理地址，ROWID伪列返回的就是该行的物理地址。使用ROWID可以快速的定位表中的某一行。ROWID值可以唯一的标识表中的一行。由于ROWID返回的是该行的物理地址，因此使用ROWID可以显示行是如何存储的。</p><p>代码演示：ROWID<br>SQL&gt; SELECT ROWID,ENAME FROM EMP WHERE SAL&gt;2000;<br>ROWID     ENAME<br>AAAMgzAAEAAAAAgAAD     JONES<br>AAAMgzAAEAAAAAgAAF     BLAKE<br>AAAMgzAAEAAAAAgAAG     CLARK<br>AAAMgzAAEAAAAAgAAH     SCOTT<br>AAAMgzAAEAAAAAgAAI     KING<br>AAAMgzAAEAAAAAgAAM     FORD<br>6 rows selected</p><p>    ROWNUM</p><p>在查询的结果集中，ROWNUM为结果集中每一行标识一个行号，第一行返回1，第二行返回2，以此类推。通过ROWNUM伪列可以限制查询结果集中返回的行数。</p><pre><code>ROWNUM与ROWID不同，ROWID是插入记录时生成，ROWNUM是查询数据时生成。ROWID标识的是行的物理地址。ROWNUM标识的是查询结果中的行的次序。</code></pre><p>案例4：查询出员工表中前5名员工的姓名，工作，工资。</p><p>代码演示：ROWNUM<br>SQL&gt; SELECT ROWNUM,ENAME,JOB,SAL FROM EMP WHERE ROWNUM&lt;=5;<br> ROWNUM     ENAME     JOB     SAL<br>1     SMITH     CLERK     800<br>2     ALLEN     SALESMAN     1600<br>3     WARD     SALESMAN     1250<br>4     JONES     MANAGER     2975<br>5     MARTIN     SALESMAN     1250</p><p>案例5：查询出工资最高的前5名员工的姓名、工资和工资。<br>案例分析<br>“工资最高的前5名”需要先降序排序，再取前5名，但是生成ROWNUM操作比排序要早，排序时已经连同ROWNUM一起排序了，因此不能直接在案例1的语句中直接加上Order by就行，而是需要对排序的结果重新做二次查询，产生新的ROWNUM才能作为查询的条件依据。</p><p>代码演示：ROWNUM应用<br>SQL&gt; SELECT ROWNUM,T.* FROM  ①<br>  2      (SELECT ENAME,JOB,SAL<br>  3       FROM EMP ORDER BY SAL DESC) T  ②<br>  4  WHERE ROWNUM&lt;=5<br>  5  /</p><p>ROWNUM     ENAME     JOB     SAL<br>1     KING     PRESIDENT     5000<br>2     SCOTT     ANALYST     3000<br>3     FORD     ANALYST     3000<br>4     JONES     MANAGER     2975<br>5     BLAKE     MANAGER     2850</p><p>代码解析：<br>①    T是子查询②的别名，这里的ROWNUM是第二次查询后的ROWNUM。</p><p>案例6：查询出表EMP中第5条到第10条之间的记录。<br>案例分析<br>这是分页的应用。在查询条件中，如果查询条件中ROWNUM大于某一正整数，则不返还任何结果。</p><p>代码演示：ROWNUM分页<br>SQL&gt; SELECT * FROM<br>  2     (SELECT ROWNUM R,ENAME,JOB,SAL  ①<br>  3      FROM EMP WHERE ROWNUM&lt;=10)  ②<br>  4  WHERE R&gt;5  ③<br>  5  /<br> R     ENAME     JOB     SAL<br>6     BLAKE     MANAGER     2850<br>7     CLARK     MANAGER     2450<br>8     SCOTT     ANALYST     3000<br>9     KING     PRESIDENT     5000<br>10     TURNER     SALESMAN     1500 </p><p>代码解析：<br>①    内部查询中得到ROWNUM 并且用别名R记录，供外层条件③使用。<br>②    内部查询的ROWNUM，与外出的ROWNUM列是平等的两列。<br>③    使用的R是内层产生的ROWNUM，在外层看来，内层查询的ROWNUM是正常的一列。</p><ol start="3"><li>Oracle函数<br>Oracle SQL提供了用于执行特定操作的专用函数。这些函数大大增强了SQL语言的功能。函数可以接受零个或者多个输入参数，并返回一个输出结果。Oracle数据库中主要使用两种类型的函数：</li><li>单行函数：对每一个函数应用在表的记录中时，只能输入一行结果，返回一个结果，比如：MOD(x,y)返回x除以y的余数（x和y可以是两个整数，也可以是表中的整数列）。常用的单行函数有：<br>    字符函数：对字符串操作。<br>    数字函数：对数字进行计算，返回一个数字。<br>    转换函数：可以将一种数据类型转换为另外一种数据类型。<br>    日期函数：对日期和时间进行处理。</li><li>聚合函数：聚合函数同时可以对多行数据进行操作，并返回一个结果。比如SUM(x)返回结果集中x列的总合。</li></ol><p>    字符函数</p><p>字符函数接受字符参数，这些参数可以是表中的列，也可以是一个字符串表达式。下表列出了常用的字符函数。</p><p>函数    说明<br>ASCII(x)    返回字符x的ASCII码。<br>CONCAT(x,y)    连接字符串x和y。<br>INSTR(x, str [,start] [,n)    在x中查找str，可以指定从start开始，也可以指定从第n次开始。<br>LENGTH(x)    返回x的长度。<br>LOWER(x)    x转换为小写。<br>UPPER(x)    x转换为大写。<br>LTRIM(x[,trim_str])    把x的左边截去trim_str字符串，缺省截去空格。<br>RTRIM(x[,trim_str])    把x的右边截去trim_str字符串，缺省截去空格。<br>TRIM([trim_str FROM] x)    把x的两边截去trim_str字符串，缺省截去空格。<br>REPLACE(x,old,new)    在x中查找old，并替换为new。<br>SUBSTR(x,start[,length])    返回x的字串，从staart处开始，截取length个字符，缺省length，默认到结尾。<br>表1  字符函数</p><p>示例    示例结果<br>SELECT ASCII(‘a’) FROM DUAL    97<br>SELECT CONCAT(‘Hello’, ‘ world’) FROM DUAL    Hello world<br>SELECT INSTR(‘Hello world’，’or’) FROM DUAL    8<br>SELECT LENGTH(‘Hello’) FROM DUAL    5<br>SELECT LOWER(‘hElLO’) FROM DUAL;    hello<br>SELECT UPPER(‘hello’) FROM DUAL    HELLO<br>SELECT LTRIM(‘===HELLO===’, ‘=’) FROM DUAL    HELLO===<br>SELECT ‘==’||LTRIM(‘   HELLO===’) FROM DUAL    ==HELLO===<br>SELECT RTRIM(‘===HELLO===’, ‘=’) FROM DUAL    ===HELLO<br>SELECT ‘=’||TRIM(‘   HELLO   ‘)||’=’ FROM DUAL    =HELLO=<br>SELECT TRIM(‘=’ FROM ‘===HELLO===’) FROM DUAL    HELLO<br>SELECT REPLACE(‘ABCDE’,’CD’,’AAA’) FROM DUAL    ABAAAE<br>SELECT SUBSTR(‘ABCDE’,2) FROM DUAL    BCDE<br>SELECT SUBSTR(‘ABCDE’,2,3) FROM DUAL    BCD<br>表2  字符函数示例</p><p>    数字函数</p><p>数字函数接受数字参数，参数可以来自表中的一列，也可以是一个数字表达式。</p><p>函数    说明    示例<br>ABS(x)    x绝对值    ABS(-3)=3<br>ACOS(x)    x的反余弦    ACOS(1)=0<br>COS(x)    余弦    COS(1)=1.57079633<br>CEIL(x)    大于或等于x的最小值    CEIL(5.4)=6<br>FLOOR(x)    小于或等于x的最大值    FLOOR(5.8)=5<br>LOG(x,y)    x为底y的对数    LOG(2,4)=2<br>MOD(x,y)    x除以y的余数    MOD(8,3)=2<br>POWER(x,y)    x的y次幂    POWER(2,3)=8<br>ROUND(x[,y])    x在第y位四舍五入    ROUND(3.456,2)=3.46<br>SQRT(x)    x的平方根    SQRT(4)=2<br>TRUNC(x[,y])    x在第y位截断    TRUNC(3.456,2)=3.45<br>表3  数字函数</p><p>说明：</p><ol><li><p>ROUND(X[,Y])，四舍五入。<br>在缺省y时，默认y=0；比如：ROUND(3.56)=4。<br>y是正整数，就是四舍五入到小数点后y位。ROUND(5.654,2)=5.65。<br>y是负整数，四舍五入到小数点左边|y|位。ROUND(351.654,-2)=400。</p></li><li><p>TRUNC(x[,y])，直接截取，不四舍五入。<br>在缺省y时，默认y=0；比如：TRUNC (3.56)=3。<br>y是正整数，就是四舍五入到小数点后y位。TRUNC (5.654,2)=5.65。<br>y是负整数，四舍五入到小数点左边|y|位。TRUNC (351.654,-2)=300。</p></li></ol><p>    日期函数</p><p>日期函数对日期进行运算。常用的日期函数有：</p><ol><li>ADD_MONTHS(d,n)，在某一个日期d上，加上指定的月数n，返回计算后的新日期。d表示日期，n表示要加的月数。</li></ol><p>图1  ADD_MONTHS函数示例</p><ol start="2"><li>LAST_DAY(d)，返回指定日期当月的最后一天。</li></ol><p>图2  LAST_DAY函数示例</p><ol start="3"><li>ROUND(d[,fmt])，返回一个以fmt为格式的四舍五入日期值，d是日期，fmt是格式模型。默认fmt为DDD，即月中的某一天。<br>    如果fmt为“YEAR”则舍入到某年的1月1日，即前半年舍去，后半年作为下一年。<br>    如果fmt为“MONTH”则舍入到某月的1日，即前月舍去，后半月作为下一月。<br>    默认为“DDD”，即月中的某一天，最靠近的天，前半天舍去，后半天作为第二天。<br>    如果fmt为“DAY”则舍入到最近的周的周日，即上半周舍去，下半周作为下一周周日。</li></ol><p>图3  ROUND函数示例</p><p>与ROUND对应的函数时TRUNC(d[,fmt])对日期的操作，TRUNC与ROUND非常相似，只是不对日期进行舍入，直接截取到对应格式的第一天。</p><ol start="4"><li>EXTRACT(fmt FROM d)，提取日期中的特定部分。</li></ol><p>fmt为：YEAR、MONTH、DAY、HOUR、MINUTE、SECOND。其中YEAR、MONTH、DAY可以为DATE类型匹配，也可以与TIMESTAMP类型匹配；但是HOUR、MINUTE、SECOND必须与TIMESTAMP类型匹配。</p><p>HOUR匹配的结果中没有加上时区，因此在中国运行的结果小8小时。</p><p>图4  EXTRACT函数示例</p><p>    转换函数</p><p>转换函数将值从一种数据类型转换为另外一种数据类型。常用的转换函数有：</p><ol><li>TO_CHAR(d|n[,fmt])</li></ol><p>把日期和数字转换为制定格式的字符串。fmt是格式化字符串，日期的格式化字符串前面已经学习过。</p><p>代码演示：TO_CHAR对日期的处理<br>SQL&gt; SELECT TO_CHAR(SYSDATE,’YYYY”年”MM”月”DD”日” HH24:MI:SS’) “date”  ①<br>  2  FROM DUAL;</p><h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><p>2009年08月11日 12:06:00<br>代码解析：<br>①    在格式化字符串中，使用双引号对非格式化字符进行引用。</p><p>针对数字的格式化，格式化字符有：</p><p>参数    示例    说明<br>9    999    指定位置处显示数字。<br>.    9.9    指定位置返回小数点<br>,    99,99    指定位置返回一个逗号<br>$    $999    数字开头返回一个美元符号<br>EEEE    9.99EEEE    科学计数法表示<br>L    L999    数字前加一个本地货币符号<br>PR    999PR    如果数字式负数则用尖括号进行表示<br>表4  数字格式化字符</p><p>代码演示：TO_CHAR对数字的处理<br>SQL&gt; SELECT TO_CHAR(-123123.45,’L9.9EEEEPR’) “date”<br>  2  FROM DUAL<br>  3  /</p><h2 id="date-1"><a href="#date-1" class="headerlink" title="date"></a>date</h2><p> &lt;￥1.2E+05&gt;</p><ol start="2"><li><p>TO_DATE(x [,fmt])<br>把一个字符串以fmt格式转换为一个日期类型，前面已经学习过。</p></li><li><p>TO_NUMBER(x[,fmt])<br>把一个字符串以fmt格式转换为一个数字。fmt格式字符参考表3。</p></li></ol><p>代码演示：TO_NUM函数<br>SQL&gt; SELECT TO_NUMBER(‘-$12,345.67’,’$99,999.99’) “NUM”<br>  2  FROM DUAL<br>  3  / </p><h2 id="NUM"><a href="#NUM" class="headerlink" title="   NUM"></a>   NUM</h2><p> -12345.67</p><p>    其他单行函数</p><ol><li><p>NVL(x,value)<br>如果x为空，返回value，否则返回x。</p><p>案例7：对工资是2000元以下的员工，如果没有发奖金，每人奖金100元。</p></li></ol><p>代码演示：NVL函数<br>SQL&gt; SELECT ENAME,JOB,SAL,NVL(COMM,100) FROM EMP WHERE SAL&lt;2000;<br>ENAME     JOB     SAL     NVL(COMM,100)<br>SMITH     CLERK     800     100<br>ALLEN     SALESMAN     1600     300<br>WARD     SALESMAN     1250     500<br>MARTIN     SALESMAN     1250     1400<br>TURNER     SALESMAN     1500     50<br>ADAMS     CLERK     1100     100<br>JAMES     CLERK     950     100 </p><p>7 rows selected</p><ol start="2"><li>NVL2(x,value1,value2)<br>如果x非空，返回value1，否则返回value2。</li></ol><p>案例8：对EMP表中工资为2000元以下的员工，如果没有奖金，则奖金为200元，如果有奖金，则在原来的奖金基础上加100元。</p><p>代码演示：NVL2函数<br>SQL&gt; SELECT ENAME,JOB,SAL,NVL2(COMM,comm+100,200) “comm”<br>  2  FROM EMP WHERE SAL&lt;2000;<br> ENAME     JOB     SAL     comm<br>SMITH     CLERK     800     200<br>ALLEN     SALESMAN     1600     400<br>WARD     SALESMAN     1250     600<br>MARTIN     SALESMAN     1250     1500<br>TURNER     SALESMAN     1500     150<br>ADAMS     CLERK     1100     200<br>JAMES     CLERK     950     200<br>MILLER     CLERK     1300     200<br>8 rows selected</p><p>    聚合函数</p><p>聚合函数同时对一组数据进行操作，返回一行结果，比如计算一组数据的总和，平均值等。</p><p>名称    作用    语法<br>AVG    平均值    AVG(表达式)<br>SUM    求和    SUM(表达式)<br>MIN、MAX    最小值、最大值    MIN(表达式)、MAX(表达式)<br>COUNT    数据统计    COUNT(表达式)<br>表 5  聚合函数</p><p>案例9：求本月所有员工的基本工资总和。</p><p>代码演示：SUM函数<br>SQL&gt; select sum(sal) from emp; </p><h2 id="SUM-SAL"><a href="#SUM-SAL" class="headerlink" title="  SUM(SAL)"></a>  SUM(SAL)</h2><pre><code>29025</code></pre><p>案例10：求不同部门的平均工资。</p><p>代码演示：AVG函数下的分组查询<br>SQL&gt; SELECT DEPTNO,AVG(SAL) FROM EMP GROUP BY DEPTNO; </p><p>DEPTNO   AVG(SAL)</p><hr><pre><code>30    1566.6666620    217510    2916.66666</code></pre><ol start="4"><li>本章总结<br>    Oracle常用函数有字符相关的函数、数字相关的函数、日期相关的函数、转换函数等。<br>    EXTRACT函数能够获取日期中的某个字段的值。<br>    TO_CHAR函数能够把数字和日期转换成固定的字符串格式。TO_DATE    函数能够把固定格式的字符串转换为日期类型。<br>    子查询中有返回单行的子查询和返回多行的子查询。<br>    Oracle中存在ROWID、ROWNUM等伪列。</li></ol><ol start="5"><li>本章练习</li><li>描述TO_CHAR和TO_DATE函数的用法。</li><li>描述EXTRACT函数的用法。</li><li>你知道有哪些关于日期函数的用法？</li></ol><p>章节知识结构图</p><p>第4章</p><p>表空间、数据库对象</p><pre><code>主要内容    同义词概念</code></pre><p>    序列的应用<br>    视图的概念<br>    索引的概念<br>    表空间的概念</p><ol><li>Oracle数据库对象<br>数据库对象是数据库的组成部分，常常用CREATE命令进行创建，可以使用ALTER命令修改，用DROP执行删除操作。前面已经接触过的数据库对象有表、用户等。</li></ol><p>本次学习更多的Oracle数据库对象：<br>    同义词：就是给数据库对象一个别名。<br>    序列：Oracle中实现增长的对象。<br>    视图：预定义的查询，作为表一样的查询使用，是一张虚拟表。<br>    索引：对数据库表中的某些列进行排序，便于提高查询效率。</p><ol start="2"><li><p>同义词<br>同义词（Synonym）是数据库对象的一个别名，Oracle可以为表、视图、序列、过程、函数、程序包等指定一个别名。同义词有两种类型：<br>    私有同义词：拥有CREATE SYNONYM权限的用户（包括非管理员用户）即可创建私有同义词，创建的私有同义词只能由当前用户使用。<br>    公有同义词：系统管理员可以创建公有同义词，公有同义词可以被所有用户访问。</p><p>创建同义词的语法是：</p></li></ol><p>语法结构：同义词<br>CREATE [OR REPLACE] [PUBLIC] SYSNONYM [schema.]synonym_name<br>FOR [schema.]object_name<br>语法解析：<br>①    CREATE [OR REPLACE：]表示在创建同义词时，如果该同义词已经存在，那么就用新创建的同义词代替旧同义词。<br>②    PULBIC：创建公有同义词时使用的关键字，一般情况下不需要创建公有同义词。<br>③    Oracle中一个用户可以创建表、视图等多种数据库对象，一个用户和该用户下的所有数据库对象的集合称为Schema（中文称为模式或者方案），用户名就是Schema名。一个数据库对象的全称是：用户名.对象名，即schema.object_name。</p><p>如果一个用户有权限访问其他用户对象时，就可以使用全称来访问。比如：</p><p>代码演示：System用户访问Scott用户的Emp表<br>SQL&gt; conn system/manager@orcl;<br>Connected to Oracle Database 10g Enterprise Edition Release 10.2.0.3.0<br>Connected as system</p><p>SQL&gt;  SELECT ENAME,JOB,SAL FROM SCOTT.EMP WHERE SAL&gt;2000;  ①<br> ENAME     JOB     SAL<br>JONES     MANAGER     2975<br>BLAKE     MANAGER     2850<br>CLARK     MANAGER     2450<br>SCOTT     ANALYST     3000<br>KING     PRESIDENT     5000<br>FORD     ANALYST     3000<br> 6 rows selected<br>代码解析：<br>①    管理员用户可以访问任何用户的数据库对象，SYSTEM用户访问SCOTT用户的EMP表时，必须使用SCOTT.EMP。</p><p>案例1：创建一个用户XiaoMei，该用户拥有CONNECT角色和RESOURCE角色。为SCOTT用户的EMP表创建同义词，并通过同义词访问该EMP表。</p><p>代码演示：创建同义词并访问<br>SQL&gt; CONN system/manager@orcl;<br>Connected to Oracle Database 10g Enterprise Edition Release 10.2.0.3.0<br>Connected as system<br>SQL&gt; CREATE USER XiaoMei IDENTIFIED BY XiaoMei;  ①<br>User created<br>SQL&gt; GRANT CONNECT TO XiaoMei;<br>Grant succeeded<br>SQL&gt; GRANT RESOURCE TO XiaoMei;<br>Grant succeeded<br>SQL&gt; GRANT CREATE SYNONYM TO XiaoMei;<br>Grant succeeded</p><p>SQL&gt; CONN XiaoMei/XiaoMei@ORCL;<br>Connected to Oracle Database 10g Enterprise Edition Release 10.2.0.3.0<br>Connected as XiaoMei </p><p>SQL&gt; CREATE SYNONYM MyEmp FOR SCOTT.EMP;  ②<br>Synonym created<br>SQL&gt; SELECT <em> FROM MYEMP;  ③<br>SELECT </em> FROM MYEMP<br>ORA-00942: 表或视图不存在 </p><p>SQL&gt; CONNECT SCOTT/tiger@ORCL<br>Connected to Oracle Database 10g Enterprise Edition Release 10.2.0.3.0<br>Connected as SCOTT </p><p>SQL&gt; GRANT ALL ON EMP TO XiaoMei;  ④<br>Grant succeeded </p><p>SQL&gt; CONNECT XiaoMei/XiaoMei@ORCL;<br>Connected to Oracle Database 10g Enterprise Edition Release 10.2.0.3.0<br>Connected as XiaoMei</p><p>SQL&gt;  SELECT ENAME,JOB,SAL FROM MyEmp WHERE SAL&gt;2000;  ⑤<br> ENAME     JOB     SAL<br>JONES     MANAGER     2975<br>BLAKE     MANAGER     2850<br>CLARK     MANAGER     2450<br>SCOTT     ANALYST     3000<br>KING     PRESIDENT     5000<br>FORD     ANALYST     3000<br> 6 rows selected<br>代码解析：<br>①    在管理员用户下创建用户XiaoMei，对用户XiaoMei授予CONNECT和RESOURCE角色。为了XiaoMei能够创建序列，必须授予系统权限：CREATE SYNONYM。<br>②    在XiaoMei用户下，为SCOTT.EMP创建私有同义词MyEmp，同义词MyEmp只能在XiaoMei用户下使用。访问MyEmp就是访问SCOTT.EMP对象。<br>③    访问MyEmp对象出错：对象不存在。因为XiaoMei如果访问MyEmp，就相当于访问SCOTT.EMP对象，那么SCOTT用户必须对XiaoMei授予相应的权限。<br>④    SCOTT用户下，把EMP表的所有权限（增删改查）授予XiaoMei。<br>⑤    对MyEmp执行查询操作。MyEmp就可以像在本地的表一样使用。</p><p>删除同义词使用的语法是：</p><p>语法结构：删除同义词<br>DROP [PUBLIC] SYNONYM [schema.]sysnonym_name<br>语法解析：<br>①    PUBLIC：删除公共同义词。<br>②    同义词的删除只能被拥有同义词对象的用户或者管理员删除。<br>③    此命令只能删除同义词，不能删除同义词下的源对象。</p><ol start="3"><li>序列<br>序列(Sequence)是用来生成连续的整数数据的对象。序列常常用来作为主键中增长列，序列中的可以升序生成，也可以降序生成。创建序列的语法是：</li></ol><p>语法结构：创建序列<br>CREATE SEQUENCE sequence_name<br>[START WITH num]<br>[INCREMENT BY increment]<br>[MAXVALUE num|NOMAXVALUE]<br>[MINVALUE num|NOMINVALUE]<br>[CYCLE|NOCYCLE]<br>[CACHE num|NOCACHE]<br>语法解析：<br>①    START WITH：从某一个整数开始，升序默认值是1，降序默认值是-1。<br>②    INCREMENT BY：增长数。如果是正数则升序生成，如果是负数则降序生成。升序默认值是1，降序默认值是-1。<br>③    MAXVALUE：指最大值。<br>④    NOMAXVALUE：这是最大值的默认选项，升序的最大值是：1027，降序默认值是-1。<br>⑤    MINVALUE：指最小值。<br>⑥    NOMINVALUE：这是默认值选项，升序默认值是1，降序默认值是-1026。<br>⑦    CYCLE：表示如果升序达到最大值后，从最小值重新开始；如果是降序序列，达到最小值后，从最大值重新开始。<br>⑧    NOCYCLE：表示不重新开始，序列升序达到最大值、降序达到最小值后就报错。默认NOCYCLE。<br>⑨    CACHE：使用CACHE选项时，该序列会根据序列规则预生成一组序列号。保留在内存中，当使用下一个序列号时，可以更快的响应。当内存中的序列号用完时，系统再生成一组新的序列号，并保存在缓存中，这样可以提高生成序列号的效率。Oracle默认会生产20个序列号。<br>⑩    NOCACHE：不预先在内存中生成序列号。</p><p>案例2：创建一个从1开始，默认最大值，每次增长1的序列，要求NOCYCLE，缓存中有30个预先分配好的序列号。</p><p>代码演示：生成序列号<br>SQL&gt; CREATE SEQUENCE MYSEQ<br>  2  MINVALUE 1<br>  3  START WITH 1<br>  4  NOMAXVALUE<br>  5  INCREMENT BY 1<br>  6  NOCYCLE<br>  7  CACHE 30<br>  8  /</p><p>Sequence created</p><p>序列创建之后，可以通过序列对象的CURRVAL和NEXTVAL两个“伪列”分别访问该序列的当前值和下一个值。</p><p>代码演示：序列使用<br>SQL&gt; SELECT MYSEQ.NEXTVAL FROM DUAL; </p><h2 id="NEXTVAL"><a href="#NEXTVAL" class="headerlink" title="NEXTVAL"></a>NEXTVAL</h2><p>   1<br>SQL&gt; SELECT MYSEQ.NEXTVAL FROM DUAL; </p><h2 id="NEXTVAL-1"><a href="#NEXTVAL-1" class="headerlink" title="NEXTVAL"></a>NEXTVAL</h2><p>2<br>SQL&gt; SELECT MYSEQ.CURRVAL FROM DUAL; </p><h2 id="CURRVAL"><a href="#CURRVAL" class="headerlink" title="CURRVAL"></a>CURRVAL</h2><p>   2</p><pre><code>使用ALTER SEQUENCE可以修改序列，在修改序列时有如下限制：</code></pre><ol><li>不能修改序列的初始值。</li><li>最小值不能大于当前值。</li><li>最大值不能小于当前值。</li></ol><p>使用DROP SEQUENCE命令可以删除一个序列对象。</p><p>代码演示：序列修改和删除<br>SQL&gt; ALTER SEQUENCE MYSEQ<br>  2  MAXVALUE 10000<br>  3  MINVALUE -300<br>  4  /<br>SEQUENCE ALTERED<br>SQL&gt; DROP SEQUENCE MYSEQ;<br>SEQUENCE DROPPED</p><ol start="4"><li>视图<br>视图（View）实际上是一张或者多张表上的预定义查询，这些表称为基表。从视图中查询信息与从表中查询信息的方法完全相同。只需要简单的SELECT…FROM即可。</li></ol><p>视图具有以下优点：</p><ol><li>可以限制用户只能通过视图检索数据。这样就可以对最终用户屏蔽建表时底层的基表。</li><li>可以将复杂的查询保存为视图。可以对最终用户屏蔽一定的复杂性。</li><li>限制某个视图只能访问基表中的部分列或者部分行的特定数据。这样可以实现一定的安全性。</li><li>从多张基表中按一定的业务逻辑抽出用户关心的部分，形成一张虚拟表。</li></ol><p>语法结构：创建视图<br>CREATE [OR REPLACE] [{FORCE|NOFORCE}] VIEW view_name<br>AS<br>SELECT查询<br>[WITH READ ONLY CONSTRAINT]<br>语法解析：</p><ol><li>OR REPLACE：如果视图已经存在，则替换旧视图。</li><li>FORCE：即使基表不存在，也可以创建该视图，但是该视图不能正常使用，当基表创建成功后，视图才能正常使用。</li><li>NOFORCE：如果基表不存在，无法创建视图，该项是默认选项。</li><li>WITH READ ONLY：默认可以通过视图对基表执行增删改操作，但是有很多在基表上的限制（比如：基表中某列不能为空，但是该列没有出现在视图中，则不能通过视图执行insert操作），WITH READ ONLY说明视图是只读视图，不能通过该视图进行增删改操作。现实开发中，基本上不通过视图对表中的数据进行增删改操作。</li></ol><p>案例3：基于EMP表和DEPT表创建视图</p><p>代码演示：视图<br>SQL&gt; CREATE OR REPLACE VIEW EMPDETAIL<br>  2  AS<br>  3  SELECT EMPNO,ENAME,JOB,HIREDATE,EMP.DEPTNO,DNAME<br>  4  FROM EMP JOIN DEPT ON EMP.DEPTNO=DEPT.DEPTNO<br>  5  WITH READ ONLY<br>  6  / </p><p>VIEW CREATED </p><p>SQL&gt; SELECT * FROM EMPDETAIL;  ①<br> EMPNO     ENAME     JOB     HIREDATE     DEPTNO     DNAME<br>7369     SMITH     CLERK     17-12月-80     20     RESEARCH<br>7499     ALLEN     SALESMAN     20-2月 -81     30     SALES<br>7521     WARD     SALESMAN     22-2月 -81     30     SALES<br>7566     JONES     MANAGER     02-4月 -81     20     RESEARCH<br>7654     MARTIN     SALESMAN     28-9月 -81     30     SALES<br>7698     BLAKE     MANAGER     01-5月 -81     30     SALES<br>7782     CLARK     MANAGER     09-6月 -81     10     ACCOUNTING<br>7788     SCOTT     ANALYST     19-4月 -87     20     RESEARCH<br>7839     KING     PRESIDENT     17-11月-81     10     ACCOUNTING<br>7844     TURNER     SALESMAN     08-9月 -81     30     SALES<br>7876     ADAMS     CLERK     23-5月 -87     20     RESEARCH<br>7900     JAMES     CLERK     03-12月-81     30     SALES<br>7902     FORD     ANALYST     03-12月-81     20     RESEARCH<br>7934     MILLER     CLERK     23-1月 -82     10     ACCOUNTING<br>14 ROWS SELECTED<br>代码解析：<br>①     对视图可以像表一样进行查询。该视图中隐藏了员工的工资。</p><p>删除视图可以使用“DROP VIEW 视图名称”，删除视图不会影响基表的数据。</p><ol start="5"><li>索引<br>当我们在某本书中查找特定的章节内容时，可以先从书的目录着手，找到该章节所在的页码，然后快速的定位到该页。这种做法的前提是页面编号是有序的。如果页码无序，就只能从第一页开始，一页页的查找了。</li></ol><p>数据库中索引（Index）的概念与目录的概念非常类似。如果某列出现在查询的条件中，而该列的数据是无序的，查询时只能从第一行开始一行一行的匹配。创建索引就是对某些特定列中的数据排序，生成独立的索引表。在某列上创建索引后，如果该列出现在查询条件中，Oracle会自动的引用该索引，先从索引表中查询出符合条件记录的ROWID，由于ROWID是记录的物理地址，因此可以根据ROWID快速的定位到具体的记录，表中的数据非常多时，引用索引带来的查询效率非常可观。</p><pre><code>    如果表中的某些字段经常被查询并作为查询的条件出现时，就应该考虑为该列创建索引。</code></pre><p>    当从很多行的表中查询少数行时，也要考虑创建索引。有一条基本的准则是：当任何单个查询要检索的行少于或者等于整个表行数的10%时，索引就非常有用。</p><p>Oracle数据库会为表的主键和包含唯一约束的列自动创建索引。索引可以提高查询的效率，但是在数据增删改时需要更新索引，因此索引对增删改时会有负面影响。</p><p>语法结构：创建索引<br>CREATE [UNIQUE] INDEX index_name ON table_name(column_name[,column_name…])<br>语法解析：</p><ol><li>UNIQUE:指定索引列上的值必须是唯一的。称为唯一索引。</li><li>index_name：指定索引名。</li><li>tabl_name：指定要为哪个表创建索引。</li><li>column_name：指定要对哪个列创建索引。我们也可以对多列创建索引；这种索引称为组合索引。</li></ol><p>案例4：为EMP表的ENAME列创建创建唯一索引，为EMP表的工资列创建普通索引，把JOB列先变为小写再创建索引。</p><p>代码演示：创建索引<br>SQL&gt; CREATE UNIQUE INDEX UQ_ENAME_IDX ON EMP(ENAME);  ①<br>Index created<br>SQL&gt; CREATE INDEX IDX_SAL ON EMP(SAL);  ②<br>Index created<br>SQL&gt; CREATE INDEX IDX_JOB_LOWER ON EMP(LOWER(JOB));  ③<br>Index created<br>代码解析：<br>①    为SCOTT.EMP表的ENAME列创建唯一索引。<br>②    为SCOTT.EMP表的SAL列创建索引。<br>③    在查询中可能经常使用job的小写作为条件的表达式，因此创建索引时，可以先对JOB列中的所有值转换为小写后创建索引，而这时需要使用lower函数，这种索引称为基于函数的索引。</p><p>在select语句查询时，Oracle系统会自动为查询条件上的列应用索引。索引就是对某一列进行排序，因此在索引列上，重复值越少，索引的效果越明显。<br>Oracle可以为一些列值重复非常多且值有限的列（比如性别列）上创建位图索引。关于Oracle更多的索引类型（比如反向键索引等），请参考Oracle官方文档。</p><ol start="6"><li>表空间<br>在数据库系统中，存储空间是较为重要的资源，合理利用空间，不但能节省空间，还可以提高系统的效率和工作性能。Oracle可以存放海量数据，所有数据都在数据文件中存储。而数据文件大小受操作系统限制，并且过大的数据文件对数据的存取性能影响非常大。同时Oracle是跨平台的数据库，Oracle数据可以轻松的在不同平台上移植，那么如何才能提供统一存取格式的大容量呢？Oracle采用表空间来解决。</li></ol><p>表空间只是一个逻辑概念，若干操作系统文件（文件可以不是很大）可以组成一个表空间。表空间统一管理空间中的数据文件，一个数据文件只能属于一个表空间。一个数据库空间由若干个表空间组成。如图所示：</p><p>图1  数据空间、表空间和数据文件</p><pre><code>Oracle中所有的数据（包括系统数据），全部保存在表空间中，常见的表空间有：</code></pre><p>    系统表空间：存放系统数据，系统表空间在数据库创建时创建。表空间名称为SYSTEM。存放数据字典和视图以及数据库结构等重要系统数据信息，在运行时如果SYSTEM空间不足，对数据库影响会比较大，虽然在系统运行过程中可以通过命令扩充空间，但还是会影响数据库的性能，因此有必要在创建数据库时适当的把数据文件设置大一些。<br>    TMEP表空间：临时表空间，安装数据库时创建，可以在运行时通过命令增大临时表空间。临时表空间的重要作用是数据排序。比如当用户执行了诸如Order by等命令后，服务器需要对所选取数据进行排序，如果数据很大，内存的排序区可能装不下太大数据，就需要把一些中间的排序结果写在硬盘的临时表空间中。<br>    用户表自定义空间：用户可以通过CREATE TABLESPACE命令创建表空间。</p><p>创建表空间需要考虑数据库对分区（Extent，一个Oracle分区是数据库文件中一段连续的空间，Oracle分区是Oracle管理中最小的单位）的管理，比如当一个表创建后先申请一个分区，在Insert执行过程中，如果分区数据已满，需要重新申请另外的分区。如果一个数据库中的分区大小不一，创建表空间时需要考虑一系列问题。因此在Oracle8i之后，创建表空间都推荐使用“本地管理表空间”，这种表空间中的分区是一个固定大小的值，创建表空间的语法是：</p><p>语法结构：创建表空间<br>CREATE TABLESPACE 空间名称<br>DATAFILE ‘文件名1’ SIZE 数字M<br>[,’文件名2’ SIZE 数字….]<br>EXTENT MANAGEMENT LOCAL<br>UNIFORM SIZE 数字M<br>语法解析：</p><ol><li>文件名包括完整路径和文件名，每个数据文件定义了文件的初始大小，初始大小一般以“M”为单位。一个表空间中可以有多个数据文件。</li><li>EXTENT MANAGEMENT LOCAL指明表空间类型是：本地管理表空间。本地管理表空间要求Oracle中的数据分区（Extent）大小统一。</li><li>UNIFORM SIZE：指定每个分区的统一大小。</li></ol><p>案例5：创建一个表空间，包含两个数据文件大小分别是10MB，5MB，要求extent的大小统一为1M。</p><p>代码演示：创建表空间<br>SQL&gt; CREATE TABLESPACE MYSPACE<br>  2  DATAFILE ‘D:/A.ORA’ SIZE 10M,<br>  3             ‘D:/B.ORA’ SIZE 5M<br>  4  EXTENT MANAGEMENT LOCAL<br>  5  UNIFORM SIZE 1M<br>  6  /</p><p>Tablespace created</p><p>必须是管理员用户才能创建表空间，当表空间的空间不足时可以使用ALTER TABLESPACE命令向表空间中追加数据文件扩充表空间。</p><p>代码演示：扩充表空间<br>SQL&gt; ALTER TABLESPACE MYSPACE<br>  2  ADD DATAFILE ‘D:/C.ORA’ SIZE 10M<br>  3  / </p><p>Tablespace altered</p><pre><code>表空间可以在不使用时删除，使用DROP TABLESPACE命令。数据库的所有数据全部在某一表空间中存放，在创建用户时，可以为用户指定某一表空间，那么该用户下的所有数据库对象（比如表）默认都存储在该空间中。</code></pre><p>代码演示：为某一用户指定默认表空间<br>SQL&gt; CREATE USER ACONG IDENTIFIED BY ACONG<br>  2   DEFAULT TABLESPACE MYSPACE<br>  3  / </p><p>User created</p><pre><code>在创建表时，表中数据存放在用户的默认表空间中，也可以通过tablespace子句为表指定表中数据存放在其他表空间中。</code></pre><p>代码演示：为表指定表空间<br>SQL&gt; CREATE TABLE SCORES<br>  2  (<br>  3          ID NUMBER ,<br>  4          TERM VARCHAR2(2),<br>  5          STUID VARCHAR2(7) NOT NULL,<br>  6          EXAMNO VARCHAR2(7) NOT NULL,<br>  7          WRITTENSCORE NUMBER(4,1) NOT NULL,<br>  8          LABSCORE NUMBER(4,1) NOT NULL<br>  9  )<br> 10  TABLESPACE MYSPACE<br> 11  / </p><p>Table created</p><pre><code>创建索引时也可以为索引指定表空间。</code></pre><p>代码演示：为索引指定表空间<br>SQL&gt; CREATE INDEX UQ_ID ON SCORES(ID)<br>  2  TABLESPACE MYSPACE;</p><p>Index created</p><pre><code>表和索引一旦创建，表空间无法修改。</code></pre><ol start="7"><li>本章总结<br>    Oracle数据库对象都是使用CREATE命令创建的。<br>    同义词就是数据库对象的一个别名。同义词的类型有公有同义词和私有同义词。只有管理员可以创建共有同义词。创建同义词的命令是：CREATE SYNONYM。<br>    序列能够产生一个连续不重复的整数。经常作为数据库的主键生成器。创建序列的命令是CREATE SEQUENCE。<br>    序列的访问使用两个“伪列”，CURRVAL表示序列的当前值，NEXTVAL表示序列的下一个值。<br>    视图就是一个预处理的查询语句，可以从若干表中过滤数据。<br>    索引就是在查询中经常使用的列进行排序。常见的索引有：普通索引、唯一序列、组合索引以及基于函数的索引。此外还有位图索引、反向键索引等。<br>    表空间是数据库的一个逻辑概念，表空间由若干个数据文件组成。为数据库对象和数据提供统一的空间管理。</li></ol><ol start="8"><li>本章练习</li><li>产生一个用于DEPT表的主键值的序列，序列起始值是100，最大值是500，增长步长是10。</li><li>用序列产生DEPT表的主键，向DEPT表中插入3条记录。</li><li>为DEPT表创建一个同义词。</li><li>创建一个视图包括EMP表的EMPNO,ENAME,JOB，部门表的DNAME列，只能包含销售部的记录。</li><li>为EMP表的ENAME列创建唯一索引。</li><li>为EMP表的SAL列创建一个普通索引。</li><li>以学期和学生姓名为名称比如（S2XiaoMei）创建一个表空间，该表空间是以学生姓名为用户的默认表空间。</li></ol><p>章节知识结构图</p><p>第5章</p><p>PL/SQL程序设计</p><pre><code>主要内容    PL/SQL数据类型</code></pre><p>    PL/SQL条件和循环控制<br>    动态执行SQL<br>    PL/SQL中的异常处理</p><ol><li><p>PL/SQL简介<br>Oracle PL/SQL语言（Procedural Language/SQL）是结合了结构化查询与Oracle自身过程控制为一体的强大语言，PL/SQL不但支持更多的数据类型，拥有自身的变量声明、赋值语句，而且还有条件、循环等流程控制语句。过程控制结构与SQL数据处理能力无缝的结合形成了强大的编程语言，可以创建过程和函数以及程序包。</p><p>PL/SQL是一种块结构的语言，它将一组语句放在一个块中，一次性发送给服务器，PL/SQL引擎分析收到PL/SQL语句块中的内容，把其中的过程控制语句由PL/SQL引擎自身去执行，把PL/SQL块中的SQL语句交给服务器的SQL语句执行器执行。如图所示：</p></li></ol><p>图1  PL/SQL体系结构</p><pre><code>PL/SQL块发送给服务器后，先被编译然后执行，对于有名称的PL/SQL块（如子程序）可以单独编译，永久的存储在数据库中，随时准备执行。PL/SQL的优点还有：</code></pre><p>    支持SQL</p><p>SQL是访问数据库的标准语言，通过SQL命令，用户可以操纵数据库中的数据。PL/SQL支持所有的SQL数据操纵命令、游标控制命令、事务控制命令、SQL函数、运算符和伪列。同时PL/SQL和SQL语言紧密集成，PL/SQL支持所有的SQL数据类型和NULL值。</p><p>    支持面向对象编程</p><p>PL/SQL支持面向对象的编程，在PL/SQL中可以创建类型，可以对类型进行继承，可以在子程序中重载方法等。</p><p>    更好的性能</p><p>SQL是非过程语言，只能一条一条执行，而PL/SQL把一个PL/SQL块统一进行编译后执行，同时还可以把编译好的PL/SQL块存储起来，以备重用，减少了应用程序和服务器之间的通信时间，PL/SQL是快速而高效的。</p><p>    可移植性</p><p>使用PL/SQL编写的应用程序，可以移植到任何操作系统平台上的Oracle服务器，同时还可以编写可移植程序库，在不同环境中重用。</p><p>    安全性</p><p>可以通过存储过程对客户机和服务器之间的应用程序逻辑进行分隔，这样可以限制对Oracle数据库的访问，数据库还可以授权和撤销其他用户访问的能力。</p><ol start="2"><li>PL/SQL块<br>PL/SQL是一种块结构的语言，一个PL/SQL程序包含了一个或者多个逻辑块，逻辑块中可以声明变量，变量在使用之前必须先声明。除了正常的执行程序外，PL/SQL还提供了专门的异常处理部分进行异常处理。每个逻辑块分为三个部分，语法是：</li></ol><p>语法结构：PL/SQL块的语法<br>[DECLARE<br>     –declaration statements]  ①<br>BEGIN<br>     –executable statements  ②<br>[EXCEPTION<br>     –exception statements]  ③<br>END;<br>语法解析：<br>①    声明部分：声明部分包含了变量和常量的定义。这个部分由关键字DECLARE开始，如果不声明变量或者常量，可以省略这部分。<br>②    执行部分：执行部分是 PL/SQL块的指令部分，由关键字BEGIN开始，关键字END结尾。所有的可执行PL/SQL语句都放在这一部分，该部分执行命令并操作变量。其他的PL/SQL块可以作为子块嵌套在该部分。PL/SQL块的执行部分是必选的。注意END关键字后面用分号结尾。<br>③    异常处理部分：该部分是可选的，该部分用EXCEPTION关键字把可执行部分分成两个小部分，之前的程序是正常运行的程序，一旦出现异常就跳转到异常部分执行。</p><p>PL/SQL是一种编程语言，与Java和C#一样，除了有自身独有的数据类型、变量声明和赋值以及流程控制语句外，PL/SQL还有自身的语言特性：</p><p>PL/SQL对大小写不敏感，为了良好的程序风格，开发团队都会选择一个合适的编码标准。比如有的团队规定：关键字全部大些，其余的部分小写。</p><p>PL/SQL块中的每一条语句都必须以分号结束，SQL语句可以是多行的，但分号表示该语句结束。一行中可以有多条SQL语句，他们之间以分号分隔，但是不推荐一行中写多条语句。</p><p>PL/SQL中的特殊符号说明：</p><p>类型    符号    说明<br>赋值运算符    :=    Java和C#中都是等号，PL/SQL的赋值是：=<br>特殊字符    ||    字符串连接操作符。<br>    –    PL/SQL中的单行注释。<br>    /<em>,</em>/    PL/SQL中的多行注释，多行注释不能嵌套。<br>    &lt;&lt;,&gt;&gt;    标签分隔符。只为了标识程序特殊位置。<br>    ..    范围操作符，比如：1..5 标识从１到５<br>算术运算符    +，-，*，/    基本算术运算符。<br>    <strong>    求幂操作，比如：3</strong>2=9<br>关系运算符    &gt;，&lt;,&gt;=,&lt;=,=    基本关系运算符，=表示相等关系，不是赋值。<br>    &lt;&gt;,!=    不等关系。<br>逻辑运算符    AND,OR,NOT    逻辑运算符。<br>表1  PL/SQL中的特殊符号和运算符</p><p>    变量声明</p><p>PL/SQL支持SQL中的数据类型，PL/SQL中正常支持NUMBER,VARCHAR2,DATE等Oracle SQL数据类型。声明变量必须指明变量的数据类型，也可以声明变量时对变量初始化，变量声明必须在声明部分。声明变量的语法是：</p><p>语法格式：声明变量<br>变量名 数据类型[ :=初始值]<br>语法解析：<br>数据类型如果需要长度，可以用括号指明长度，比如：varchar2(20)。</p><p>代码演示：声明变量<br>SQL&gt; DECLARE<br>  2       sname VARCHAR2(20) :=’jerry’;  ①<br>  3  BEGIN<br>  4       sname:=sname||’ and tom’;  ②<br>  5       dbms_output.put_line(sname);  ③<br>  6  END;<br>  7  /jerry<br>PL/SQL procedure successfully completed<br>代码解析：<br>①    声明一个变量sname，初始化值是“jerry”。字符串用单引号，如果字符串中出现单引号可以使用两个单引号（’’）来表示，即单引号同时也具有转义的作用。<br>②    对变量sname重新赋值，赋值运算符是“:=”。<br>③    dbms_output.put_line是输出语句，可以把一个变量的值输出，在SQL<em>Plus中输出数据时，可能没有结果显示，可以使用命令：set serveroutput on设置输出到SQL</em>Plus控制台上。</p><p>对变量赋值还可以使用SELECT…INTO 语句从数据库中查询数据对变量进行赋值。但是查询的结果只能是一行记录，不能是零行或者多行记录。</p><p>代码演示：变量赋值<br>SQL&gt; DECLARE<br>  2       sname VARCHAR2(20) DEFAULT ‘jerry’;  ①<br>  3  BEGIN<br>  4       SELECT ename INTO sname FROM emp WHERE empno=7934;  ②<br>  5       dbms_output.put_line(sname);<br>  6  END;<br>  7  /<br>MILLER<br>PL/SQL procedure successfully completed<br>代码解析：<br>①    变量初始化时，可以使用DEFAULT关键字对变量进行初始化。<br>②    使用select…into语句对变量sname赋值，要求查询的结果必须是一行，不能是多行或者没有记录。</p><p>    声明常量</p><p>常量在声明时赋予初值，并且在运行时不允许重新赋值。使用CONSTANT关键字声明常量。</p><p>代码演示：声明常量<br>SQL&gt; DECLARE<br>  2       pi CONSTANT number :=3.14;   –圆周率长值  ①<br>  3       r number DEFAULT 3;   –圆的半径默认值3  ②<br>  4       area number;   –面积。<br>  5  BEGIN<br>  6       area:=pi<em>r</em>r;   –计算面积<br>  7       dbms_output.put_line(area);  –输出圆的面积<br>  8  END;<br>  9  /</p><p>28.26</p><p>PL/SQL procedure successfully completed<br>代码解析：<br>①    声明常量时使用关键字CONSTANT，常量初值可以使用赋值运算符（:=）赋值，也可以使用DEFAULT关键字赋值。</p><p>在SQL*Plus中还可以声明Session（会话，也就是一个客户端从连接到退出的过程称为当前用户的会话。）全局级变量，该变量在整个会话过程中均起作用，类似的这种变量称为宿主变量。宿主变量在PL/SQL引用时要用“:变量名”引用。</p><p>代码演示：宿主常量<br>SQL&gt; var emp_name varchar(30);  ①<br>SQL&gt; BEGIN<br>  2  SELECT ename INTO :emp_name FROM emp WHERE empno=7499;  ②<br>  3  END;<br>  4  /<br>PL/SQL procedure successfully completed</p><h2 id="emp-name"><a href="#emp-name" class="headerlink" title="emp_name"></a>emp_name</h2><p>ALLEN</p><p>SQL&gt; print emp_name;  ③</p><h2 id="emp-name-1"><a href="#emp-name-1" class="headerlink" title="emp_name"></a>emp_name</h2><p>ALLEN<br>代码解析：<br>①    可以使用var声明宿主变量。<br>②    PL/SQL中访问宿主变量时要在变量前加“:”。<br>③    在SQL*Plus中，使用print可以输出变量中的结果。</p><ol start="3"><li>PL/SQL数据类型<br>前面在建表时，学习过Oracle SQL的数据类型，PL/SQL不但支持这些数据类型，还具备自身的数据类型。PL/SQL的数据类型包括标量数据类型，引用数据类型和存储文本、图像、视频、声音等非结构化的大数据类型（LOB数据类型）等。下面列举一些常用的类型。</li></ol><p>    标量数据类型</p><p>标量数据类型的变量只有一个值，且内部没有分量。标量数据类型包括数字型，字符型，日期型和布尔型。这些类型有的是Oracle SQL中定义的数据类型，有的是PL/SQL自身附加的数据类型。字符型和数字型又有子类型，子类型只与限定的范围有关，比如NUMBER类型可以表示整数，也可以表示小数，而其子类型POSITIVE只表示正整数。</p><p>类型    说明<br>VARCHAR2(长度)    可变长度字符串，Oracle SQL定义的数据类型，在PL/SQL中使用时最常32767字节。在PL/SQL中使用没有默认长度，因此必须指定。<br>NUMBER(精度，小数)    Oracle SQL定义的数据类型，见第二章。<br>DATE    Oracle SQL定义的日期类型，见第二章。<br>TIMESTAMP    Oracle SQL定义的日期类型，见第二章。<br>CHAR(长度)    Oracle SQL定义的日期类型，固定长度字符，最长32767字节，默认长度是1，如果内容不够用空格代替。<br>LONG    Oracle SQL定义的数据类型，变长字符串基本类型，最长32760字节。在Oracle SQL中最长2147483647字节。<br>BOOLEAN    PL/SQL附加的数据类型，逻辑值为TRUE、FALSE、NULL<br>BINARY_INTEGER    PL/SQL附加的数据类型，介于-231和231之间的整数。<br>PLS_INTEGER    PL/SQL附加的数据类型，介于-231和231之间的整数。类似于BINARY_INTEGER，只是PLS_INTEGER值上的运行速度更快。<br>NATURAL    PL/SQL附加的数据类型，BINARY_INTEGER子类型，表示从0开始的自然数。<br>NATURALN    与NATURAL一样，只是要求NATURALN类型变量值不能为NULL。<br>POSITIVE    PL/SQL附加的数据类型，BINARY_INTEGER子类型，正整数。<br>POSITIVEN    与POSITIVE一样，只是要求POSITIVE的变量值不能为NULL。<br>REAL    Oracle SQL定义的数据类型，18位精度的浮点数<br>INT,INTEGER,SMALLINT    Oracle SQL定义的数据类型，NUMBERDE的子类型，38位精度整数。<br>SIGNTYPE    PL/SQL附加的数据类型，BINARY_INTEGER子类型。值有：1、-1、0。<br>STRING    与VARCHAR2相同。<br>表2  PL/SQL中标量数据类型。</p><p>    属性数据类型</p><p>当声明一个变量的值是数据库中的一行或者是数据库中某列时，可以直接使用属性类型来声明。Oracle中存在两种属性类型：%TYPE和%ROWTYPE。</p><p>    % ROWTYPE<br>引用数据库表中的一行作为数据类型，即RECORD类型（记录类型），是PL/SQL附加的数据类型。表示一条记录，就相当于C#中的一个对象。可以使用“.”来访问记录中的属性。</p><p>代码演示：<br>SQL&gt; DECLARE<br>  2       myemp EMP%ROWTYPE;  ①<br>  3  BEGIN<br>  4       SELECT * INTO myemp FROM emp WHERE empno=7934;  ②<br>  5       dbms_output.put_line(myemp.ename);  ③<br>  6  END;<br>  7  /<br>MILLER<br>PL/SQL procedure successfully completed<br>代码解析：<br>①    声明一个myemp对象，该对象表示EMP表中的一行。<br>②    从EMP表中查询一条记录放入myemp对象中。<br>③    访问该对象的属性可以使用“.”。</p><p>    %TYPE<br>引用某个变量或者数据库的列的类型作为某变量的数据类型。</p><p>代码演示：%TYPE应用<br>SQL&gt; DECLARE<br>  2       sal emp.sal%TYPE;  ①<br>  3       mysal number(4):=3000;<br>  4       totalsal mysal%TYPE;  ②<br>  5  BEGIN<br>  6       SELECT SAL INTO sal FROM emp WHERE empno=7934;<br>  7       totalsal:=sal+mysal;<br>  8       dbms_output.put_line(totalsal);<br> 9  END;<br> 10  /<br>4300<br>PL/SQL procedure successfully completed<br>代码解析：<br>①    定义变量sal为emp表中sal列的类型。<br>②    定义totalsal是变量mysal的类型。</p><p>%TYPE可以引用表中的某列作的类型为变量的数据类型，也可以引用某变量的类型作为新变量的数据类型。</p><ol start="4"><li>PL/SQL条件控制和循环控制<br>PL/SQL程序可通过条件或循环结构来控制命令执行的流程。PL/SQL提供了丰富的流程控制语句，与C#一样也有三种控制结构：<br>    顺序结构<br>    条件结构<br>    循环结构</li></ol><p>    条件控制</p><p>C#中的条件控制使用关键字if和switch。PL/SQL中关于条件控制的关键字有IF-THEN、IF-THEN-ELSE、IF-THEN-ELSIF和多分枝条件CASE。</p><p>    IF-THEN<br>该结构先判断一个条件是否为TRUE，条件成立则执行对应的语句块，与C#中的if语句很相似，具体语法是：</p><p>C#中if语法    PL/SQL中IF语法<br>if (条件){<br>     //条件结构体<br>}    IF 条件 THEN<br>     –条件结构体<br>END IF;<br>表3  PL/SQL中条件语法</p><p>说明：<br>①    用IF关键字开始，END IF关键字结束，注意END IF后面有一个分号。<br>②    条件部分可以不使用括号，但是必须以关键字THEN来标识条件结束，如果条件成立，则执行THEN后到对应END IF之间的语句块内容。如果条件不成立，则不执行条件语句块的内容。<br>③    C#结构用一对大括号来包含条件结构体的内容。PL/SQL中关键字THEN到END IF之间的内容是条件结构体内容。<br>④    条件可以使用关系运算符合逻辑运算符。</p><p>案例1：查询JAMES的工资，如果大于900元，则发奖金800元。</p><p>代码演示：IF-THEN应用<br>DECLARE<br>      newSal emp.sal % TYPE;<br> BEGIN<br>      SELECT sal INTO newSal FROM emp<br>      WHERE ename=’JAMES’;<br>      IF newSal&gt;900 THEN  ①<br>           UPDATE emp<br>           SET comm=800<br>           WHERE ename=’JAMES’;<br>      END IF;<br>      COMMIT ;  ②<br>END;<br>代码解析：<br>①    先判断条件，如果条件为TRUE，则执行条件结构体内部的内容。<br>②    在PL/SQL块中可以使用事务控制语句，该COMMIT同时也能把PL/SQL块外没有提交的数据一并提交，使用时需要注意。</p><p>    IF-THEN-ELSE</p><p>语法格式：IF-THEN-ELSE<br>C#中if语法    PL/SQL中IF语法<br>if (条件){<br>     //条件成立结构体<br>}<br>else{<br>    //条件不成立结构体<br>}    IF 条件 THEN<br>     –条件成立结构体<br>ELSE<br>     –条件不成立结构体<br>END IF;<br>表4  PL/SQL中条件语法</p><p>语法解析：<br>把ELSE与IF-THEN连在一起使用，如果IF条件不成立则执行就会执行ELSE部分的语句。</p><p>案例2：查询JAMES的工资，如果大于900元，则发奖金800元，否则发奖金400元。</p><p>代码演示：IF-THEN-ELSE应用<br>DECLARE<br>      newSal emp.sal % TYPE;<br>BEGIN<br>      SELECT sal INTO newSal FROM emp<br>      WHERE ename=’JAMES’;<br>      IF newSal&gt;900 THEN<br>           UPDATE emp<br>           SET comm=800<br>           WHERE ename=’JAMES’;<br>      ELSE<br>           UPDATE emp<br>           SET comm=400<br>           WHERE ename=’JAMES’;<br>      END IF;<br>END;</p><p>    IF-THEN-ELSIF</p><p>语法格式：IF-THEN-ELSIF<br>C#中if语法    PL/SQL中IF语法<br>if (条件2){<br>     //条件成立结构体<br>}<br>else if(条件2){<br>    //条件不成立结构体<br>}<br>else{<br>    //以上条件都不成立结构体<br>}    IF 条件1 THEN<br>     –条件1成立结构体<br>ELSIF 条件2 THEN<br>     –条件2成立结构体<br>ELSE<br>     –以上条件都不成立结构体<br>END IF;<br>表5  PL/SQL中多分枝条件语法<br>语法解析：<br>PL/SQL中的再次条件判断中使用关键字ELSIF，而C#使用else if。</p><p>案例3：查询JAMES的工资，如果大于1500元，则发放奖金100元，如果工作大于900元，则发奖金800元，否则发奖金400元。</p><p>代码演示：IF-THEN-ELSIF应用<br>DECLARE<br>      newSal emp.sal % TYPE;<br>BEGIN<br>      SELECT sal INTO newSal FROM emp<br>      WHERE ename=’JAMES’;<br>      IF newSal&gt;1500 THEN<br>           UPDATE emp<br>           SET comm=1000<br>           WHERE ename=’JAMES’;<br>      ELSIF newSal&gt;1500 THEN<br>           UPDATE emp<br>           SET comm=800<br>           WHERE ename=’JAMES’;<br>      ELSE<br>           UPDATE emp<br>           SET comm=400<br>           WHERE ename=’JAMES’;<br>      END IF;<br>END;</p><p>    CASE</p><p>CASE是一种选择结构的控制语句，可以根据条件从多个执行分支中选择相应的执行动作。也可以作为表达式使用，返回一个值。类似于C#中的switch语句。语法是：</p><p>语法格式：CASE<br>CASE [selector]<br>WHEN 表达式1 THEN 语句序列1；<br>WHEN 表达式2 THEN 语句序列2；<br>WHEN 表达式3 THEN 语句序列3；<br>……<br>[ELSE 语句序列N]；<br>END CASE;<br>语法解析：<br>    如果存在选择器selector，选择器selector与WHEN后面的表达式匹配，匹配成功就执行THEN后面的语句。如果所有表达式都与selector不匹配，则执行ELSE后面的语句。</p><p>案例4：输入一个字母A、B、C分别输出对应的级别信息。</p><p>代码演示：CASE中存在selector，不返回值<br>DECLARE<br>      v_grade CHAR(1):=UPPER(‘&amp;p_grade’);  ①<br>BEGIN<br>      CASE v_grade  ②<br>           WHEN ‘A’ THEN<br>               dbms_output.put_line(‘Excellent’);<br>           WHEN ‘B’ THEN<br>               dbms_output.put_line(‘Very Good’);<br>           WHEN ‘C’ THEN<br>               dbms_output.put_line(‘Good’);<br>           ELSE<br>               dbms_output.put_line(‘No such grade’);<br>      END CASE;<br>END;<br>代码解析：<br>①    &amp; grade表示在运行时由键盘输入字符串到grade变量中。<br>②    v_grade分别于WHEN后面的值匹配，如果成功就执行WHEN后的程序序列。</p><p>CASE语句还可以作为表达式使用，返回一个值。</p><p>代码演示：CASE中存在selector，作为表达式使用<br>DECLARE<br>      v_grade CHAR(1):=UPPER(‘&amp;grade’);<br>      p_grade VARCHAR(20) ;<br>BEGIN<br>      p_grade :=  ①<br>      CASE v_grade<br>           WHEN ‘A’ THEN<br>               ‘Excellent’<br>           WHEN ‘B’ THEN<br>               ‘Very Good’<br>           WHEN ‘C’ THEN<br>               ‘Good’<br>           ELSE<br>               ‘No such grade’<br>      END;<br>      dbms_output.put_line(‘Grade:’ ||v_grade||’,the result is ‘||p_grade);<br>END;<br>代码解析：<br>①    CASE语句可以返回一个结果给变量p_grade</p><p>PL/SQL还提供了搜索CASE语句。也就是说，不使用CASE中的选择器，直接在WHEN后面判断条件，第一个条件为真时，执行对应THEN后面的语句序列。</p><p>代码演示：搜索CASE<br>DECLARE<br>      v_grade CHAR(1):=UPPER(‘&amp;grade’);<br>      p_grade VARCHAR(20) ;<br>BEGIN<br>      p_grade :=<br>      CASE<br>           WHEN v_grade=’A’ THEN<br>               ‘Excellent’<br>           WHEN v_grade=’B’ THEN<br>               ‘Very Good’<br>           WHEN v_grade=’C’ THEN<br>               ‘Good’<br>           ELSE<br>               ‘No such grade’<br>      END;<br>      dbms_output.put_line(‘Grade:’ ||v_grade||’,the result is ‘||p_grade);<br>END;</p><p>    循环结构</p><p>PL/SQL提供了丰富的循环结构来重复执行一些列语句。Oracle提供的循环类型有：</p><ol><li>无条件循环LOOP-END LOOP语句</li><li>WHILE循环语句</li><li>FOR循环语句</li></ol><p>在上面的三类循环中EXIT用来强制结束循环，相当于C#循环中的break。</p><p>    LOOP循环</p><p>LOOP循环是最简单的循环，也称为无限循环，LOOP和END LOOP是关键字。</p><p>语法格式：LOOP循环<br>LOOP<br>    –循环体<br>END LOOP；<br>语法格式：</p><ol><li>循环体在LOOP和END LOOP之间，在每个LOOP循环体中，首先执行循环体中的语句序列，执行完后再重新开始执行。</li><li>在LOOP循环中可以使用EXIT或者[EXIT WHEN 条件]的形式终止循环。否则该循环就是死循环。</li></ol><p>案例5：执行1+2+3+…+100的值</p><p>代码演示：LOOP循环<br>DECLARE<br>      counter number(3):=0;<br>      sumResult number:=0;<br>BEGIN<br>      LOOP<br>          counter := counter+1;<br>          sumResult := sumResult+counter;<br>          IF counter&gt;=100 THEN  ①<br>              EXIT;<br>          END IF;<br>          – EXIT WHEN counter&gt;=100;  ②<br>      END LOOP;<br>       dbms_output.put_line(‘result is :’||to_char(sumResult));<br>END;<br>代码解析：<br>①    LOOP循环中可以使用IF结构嵌套EXIT关键字退出循环<br>②    注释行，该行可以代替①中的循环结构，WHEN后面的条件成立时跳出循环。</p><p>    WHILE循环</p><p>与C#中的while循环很类似。先判断条件，条件成立再执行循环体。</p><p>语法格式：WHILE<br>C#中while语法    PL/SQL中WHILE语法<br>while (条件){<br>     //循环体体<br>}    WHILE 条件 LOOP<br>    –循环体<br>END LOOP;<br>表5  PL/SQL中LOOP语法</p><p>案例6：WHILE循环</p><p>代码演示：WHILE循环<br>DECLARE<br>      counter number(3):=0;<br>      sumResult number:=0;<br>BEGIN<br>      WHILE counter&lt;100 LOOP<br>          counter := counter+1;<br>          sumResult := sumResult+counter;<br>      END LOOP;<br>       dbms_output.put_line(‘result is :’||sumResult);<br>END;</p><p>    FOR循环</p><p>FOR循环需要预先确定的循环次数，可通过给循环变量指定下限和上限来确定循环运行的次数，然后循环变量在每次循环中递增（或者递减）。FOR循环的语法是：</p><p>语法格式：FOR循环<br>FOR 循环变量 IN [REVERSE] 循环下限..循环上限 LOOP LOOP<br>–循环体<br>END LOOP；<br>语法解析：<br>循环变量：该变量的值每次循环根据上下限的REVERSE关键字进行加1或者减1。<br>REVERSE：指明循环从上限向下限依次循环。</p><p>案例7：FOR循环</p><p>代码演示：FOR循环<br>DECLARE<br>      counter number(3):=0;<br>      sumResult number:=0;<br>BEGIN<br>      FOR counter IN 1..100 LOOP<br>          sumResult := sumResult+counter;<br>      END LOOP;<br>       dbms_output.put_line(‘result is :’||sumResult);<br>END;</p><p>    顺序结构</p><p>在程序顺序结构中有两个特殊的语句。GOTO和NULL</p><p>    GOTO语句</p><p>GOTO语句将无条件的跳转到标签指定的语句去执行。标签是用双尖括号括起来的标示符，在PL/SQL块中必须具有唯一的名称，标签后必须紧跟可执行语句或者PL/SQL块。GOTO不能跳转到IF语句、CASE语句、LOOP语句、或者子块中。</p><p>    NULL语句</p><p>NULL语句什么都不做，只是将控制权转到下一行语句。NULL语句是可执行语句。NULL语句在IF或者其他语句语法要求至少需要一条可执行语句，但又不需要具体操作的地方。比如GOTO的目标地方不需要执行任何语句时。</p><p>案例8：GOGO 和 NULL</p><p>代码演示：GOTO和NULL<br>DECLARE<br>    sumsal emp.sal%TYPE;<br>BEGIN<br>    SELECT SUM(sal) INTO sumsal FROM EMP;<br>    IF sumsal&gt;20000 THEN<br>        GOTO first_label;  ①<br>    ELSE<br>        GOTO second_label;  ②<br>    END IF;<br>    &lt;&lt;first_label&gt;&gt;  ③<br>    dbms_output.put_line(‘ABOVE 20000:’ || sumsal);<br>    &lt;&lt;second_label&gt;&gt;  ④<br>    NULL;<br>END;<br>代码解析：<br>①    跳转到程序first_label位置，就是②的位置，first_label是一个标签，用两个尖括号包含。<br>②    无条件跳转到sedond_label位置，就是④的位置。④处不执行任何内容，因此是一个NULL语句。</p><p>与C#一样，在PL/SQL中，各种循环之间可以相互嵌套。</p><ol start="5"><li>PL/SQL中动态执行SQL语句<br>在PL/SQL程序开发中，可以使用DML语句和事务控制语句，但是还有很多语句（比如DDL语句）不能直接在PL/SQL中执行。这些语句可以使用动态SQL来实现。</li></ol><p>PL/SQL块先编译然后再执行，动态SQL语句在编译时不能确定，只有在程序执行时把SQL语句作为字符串的形式由动态SQL命令来执行。在编译阶段SQL语句作为字符串存在，程序不会对字符串中的内容进行编译，在运行阶段再对字符串中的SQL语句进行编译和执行，动态SQL的语法是：</p><p>语法格式：动态SQL<br>EXECUTE IMMEDIATE 动态语句字符串<br>[INTO 变量列表]<br>[USING 参数列表]<br>语法解析：<br>    如果动态语句是SELECT语句，可以把查询的结果保存到INTO后面的变量中。如果动态语句中存在参数，USING为语句中的参数传值。<br>    动态SQL中的参数格式是：[:参数名]，参数在运行时需要使用USING传值。<br>    案例9：动态SQL</p><p>代码演示：动态SQL<br>DECLARE<br>   sql_stmt    VARCHAR2(200);  –动态SQL语句<br>   emp_id      NUMBER(4) := 7566;<br>   salary      NUMBER(7,2);<br>   dept_id     NUMBER(2) := 90;<br>   dept_name   VARCHAR2(14) := ‘PERSONNEL’;<br>   location    VARCHAR2(13) := ‘DALLAS’;<br>   emp_rec     emp%ROWTYPE;<br>BEGIN<br>   –无子句的execute immediate<br>   EXECUTE IMMEDIATE ‘CREATE TABLE bonus1 (id NUMBER, amt NUMBER)’;  ①<br>   —-using子句的execute immediate<br>   sql_stmt := ‘INSERT INTO dept VALUES (:1, :2, :3)’;<br>   EXECUTE IMMEDIATE sql_stmt USING dept_id, dept_name, location;  ②<br>   —-into子句的execute immediate<br>   sql_stmt := ‘SELECT * FROM emp WHERE empno = :id’;<br>   EXECUTE IMMEDIATE sql_stmt INTO emp_rec USING emp_id;  ③</p><p>   —-returning into子句的execute immediate<br>   sql_stmt := ‘UPDATE emp SET sal = 2000 WHERE empno = :1<br>      RETURNING sal INTO :2’;<br>   EXECUTE IMMEDIATE sql_stmt USING emp_id RETURNING INTO salary;  ④</p><p>   EXECUTE IMMEDIATE ‘DELETE FROM dept WHERE deptno = :num’<br>      USING dept_id;  ⑤<br>END;<br>代码解析：<br>①    动态执行一个完整的SQL语句。<br>②    SQL语句中存在3个参数分别标识为：[:1、:2、:3]，因此需要用USING关键字对三个参数分别赋值。<br>③    对动态查询语句可以使用INTO子句把查询的结果保存到一个变量中，要求该结果只能是单行。<br>④    在Oracle的insert，update，delete语句都可以使用RETURNING子句把操作影响的行中的数据返回，对SQL语句中存在RETURNING子句时，在动态执行时可以使用RETURNING INTO来接收。<br>⑤    动态执行参数中可以是：[:数字]也可以是[:字符串]。</p><ol start="6"><li>PL/SQL的异常处理<br>在程序运行时出现的错误，称为异常。发生异常后，语句将停止执行，PL/SQL引擎立即将控制权转到PL/SQL块的异常处理部分。异常处理机制简化了代码中的错误检测。PL/SQL中任何异常出现时，每一个异常都对应一个异常码和异常信息。比如：</li></ol><p>图1  PL/SQL中的异常</p><p>    预定义异常</p><p>为了Oracle开发和维护的方便，在Oracle异常中，为常见的异常码定义了对应的异常名称，称为预定义异常，常见的预定义异常有：</p><p>异常名称    异常码    描述<br>DUP_VAL_ON_INDEX    ORA-00001    试图向唯一索引列插入重复值<br>INVALID_CURSOR    ORA-01001    试图进行非法游标操作。<br>INVALID_NUMBER    ORA-01722    试图将字符串转换为数字<br>NO_DATA_FOUND    ORA-01403    SELECT INTO语句中没有返回任何记录。<br>TOO_MANY_ROWS    ORA-01422    SELECT INTO语句中返回多于1条记录。<br>ZERO_DIVIDE    ORA-01476    试图用0作为除数。<br>CURSOR_ALREADY_OPEN    ORA-06511    试图打开一个已经打开的游标<br>表6  PL/SQL中预定义异常</p><pre><code>PL/SQL中用EXCEPTION关键字开始异常处理。具体语法是：</code></pre><p>语法格式：异常处理<br>BEGIN<br>    –可执行部分<br>    EXCEPTION   – 异常处理开始<br>        WHEN 异常名1 THEN<br>             –对应异常处理<br>        WHEN 异常名2 THEN<br>             –对应异常处理<br>         ……<br>        WHEN OTHERS THEN<br>             –其他异常处理<br>    END;<br>语法解析：<br>    异常发生时，进入异常处理部分，具体的异常与若干个WHEN子句中指明的异常名匹配，匹配成功就进入对应的异常处理部分，如果对应不成功，则进入OTHERS进行处理。</p><pre><code>案例10 ：异常处理</code></pre><p>代码演示：异常处理<br>SQL&gt; DECLARE<br>  2        newSal emp.sal % TYPE;<br>  3  BEGIN<br>  4        SELECT sal INTO newSal FROM emp;<br>  5  EXCEPTION<br>  6        WHEN TOO_MANY_ROWS THEN<br>  7            dbms_output.put_line(‘返回的记录太多了’);<br>  8        WHEN OTHERS THEN<br>  9            dbms_output.put_line(‘未知异常’);<br> 10  END;<br> 11  /<br>返回的记录太多了<br>PL/SQL procedure successfully completed</p><p>    自定义异常。</p><pre><code>除了预定义异常外，用户还可以在开发中自定义异常，自定义异常可以让用户采用与PL/SQL引擎处理错误相同的方式进行处理，用户自定义异常的两个关键点：</code></pre><p>    异常定义：在PL/SQL块的声明部分采用EXCEPTION关键字声明异常，定义方法与定义变量相同。比如声明一个myexception异常方法是：<br>myexception EXCEPTION；<br>    异常引发：在程序可执行区域，使用RAISE关键字进行引发。比如引发myexception方法是：<br>RAISE myexception;</p><pre><code>案例11：自定义异常</code></pre><p>代码演示：自定义异常<br>SQL&gt; DECLARE<br>  2      sal emp.sal%TYPE;<br>  3      myexp EXCEPTION;  ①<br>  4  BEGIN<br>  5      SELECT sal INTO sal FROM emp WHERE ename=’JAMES’;<br>  6      IF sal&lt;5000 THEN<br>  7         RAISE myexp;  ②<br>  8      END IF;<br>  9  EXCEPTION<br> 10      WHEN NO_DATA_FOUND THEN<br> 11           dbms_output.put_line(‘NO RECORDSET FIND!’);<br> 12      WHEN MYEXP THEN  ③<br> 13           dbms_output.put_line(‘SAL IS TO LESS!’);<br> 14  END;<br> 15  /<br>SAL IS TO LESS!<br>PL/SQL procedure successfully completed<br>代码解析：<br>①    用EXCEPTION定义一个异常变量myexp<br>②    在一定条件下用RAISE引发异常myexp<br>③    在异常处理部分，捕获异常，如果不处理异常，该异常就抛给程序执行者。</p><p>    引发应用程序异常</p><p>在Oracle开发中，遇到的系统异常都有对应的异常码，在应用系统开发中，用户自定义的异常也可以指定一个异常码和异常信息，Oracle系统为用户预留了自定义异常码，其范围介于-20000到-20999之间的负整数。引发应用程序异常的语法是：<br>RAISE_APPLICATION_ERROR(异常码，异常信息)</p><p>案例12：引发系统异常</p><p>代码演示：引发应用系统异常<br>SQL&gt; DECLARE<br>  2      sal emp.sal%TYPE;<br>  3      myexp EXCEPTION;<br>  4  BEGIN<br>  5      SELECT sal INTO sal FROM emp WHERE ename=’JAMES’;<br>  6      IF sal&lt;5000 THEN<br>  7         RAISE myexp;<br>  8      END IF;<br>  9  EXCEPTION<br> 10      WHEN NO_DATA_FOUND THEN<br> 11           dbms_output.put_line(‘NO RECORDSET FIND!’);<br> 12      WHEN MYEXP THEN<br> 13           RAISE_APPLICATION_ERROR(-20001,’SAL IS TO LESS!’);  ①<br> 14  END;<br> 15  /<br>ORA-20001: SAL IS TO LESS!  ②<br>ORA-06512: 在 line 14<br>代码解析：<br>①    引发应用系统异常，指明异常码和异常信息。<br>②    在控制台上显示异常码和异常信息。</p><p>如果要处理未命名的内部异常，必须使用OTHERS异常处理器。也可以利用PRAGMA EXCEPTION_INIT把一个异常码与异常名绑定。</p><p>PRAGMA由编译器控制，PRAGMA在编译时处理，而不是在运行时处理。EXCEPTION_INIT告诉编译器将异常名与ORACLE错误码绑定起来，这样可以通过异常名引用任意的内部异常，并且可以通过异常名为异常编写适当的异常处理器。PRAGMA EXCEPTION_INIT的语法是：<br>PRAGMA EXCEPTION_INIT(异常名,异常码)</p><p>这里的异常码可以是用户自定义的异常码，也可以是Oracle系统的异常码。</p><p>案例13：PRAGMA EXCEPTION_INIT异常</p><p>代码演示：PRAGMA EXCEPTION_INIT异常<br>&lt;<outterseg>&gt;<br>DECLARE<br>  null_salary EXCEPTION;<br>  PRAGMA EXCEPTION_INIT(null_salary, -20101);  ①<br>BEGIN<br>  &lt;<innerstart>&gt;  ②<br>  DECLARE<br>    curr_comm NUMBER;<br>  BEGIN<br>    SELECT comm INTO curr_comm FROM emp WHERE empno = &empno;<br>    IF curr_comm IS NULL THEN<br>         RAISE_APPLICATION_ERROR(-20101, ‘Salary is missing’);  ③<br>    ELSE<br>      dbms_output.put_line(‘有津贴’);<br>    END IF;<br>  END;<br>EXCEPTION<br>  WHEN NO_DATA_FOUND THEN<br>          dbms_output.put_line(‘没有发现行’);<br>  WHEN null_salary THEN<br>          dbms_output.put_line(‘津贴未知’);  ④<br>  WHEN OTHERS THEN<br>           dbms_output.put_line(‘未知异常’);<br>END;<br>代码解析：<br>①    把异常名称null_salary与异常码-20101关联，该语句由于是预编译语句，必须放在声明部分。也就是说-20101的异常名称就是null_salary。<br>②    嵌套PL/SQL语句块<br>③    在内部PL/SQL语句块中引发应用系统异常-20101。<br>④    在外部的PL/SQL语句块中就可以用异常名null_salary进行捕获。</innerstart></outterseg></p><ol start="7"><li>本章总结<br>    PL/SQL是一种块结构的语言，它将一组语句放在一个块中，一次性发送给服务器，PL/SQL引擎把接收到PL/SQL语句块中的内容进行分析，把其中的过程控制语句由PL/SQL引擎自身去执行，把PL/SQL语句块中的SQL语句交给服务器的SQL语句执行器执行。<br>    PL/SQL的数据类型包括标量数据类型，引用数据类型和存储文本、图像、视频、声音等非结构化得大数据类型（LOB数据类型）等。<br>    Oracle中存在两种属性类型：%TYPE和%ROWTYPE。<br>    PL/SQL程序可通过控制结构来控制命令执行的流程。PL/SQL中提供三种程序结构：顺序结构、条件结构和循环结构。<br>    在PL/SQL程序开发中，可以使用DML语句和事务控制语句，还可以动态执行SQL语句，动态执行SQL语句的命令是：EXECUTE IMMEDIATE。<br>    在程序运行时出现的错误，称为异常。发生异常后，语句将停止执行，PL/SQL引擎立即将控制权转到PL/SQL块的异常处理部分。PL/SQL中任何异常出现时，每一个异常都对应一个异常码和异常信息。</li></ol><ol start="8"><li>本章练习</li><li>PL/SQL有哪些优点？</li><li>请描述PL/SQL块的结构。</li><li>请描述多分枝判断CASE的用法。</li><li>PL/SQL中有哪些循环控制语句？如何使用它们？</li><li>如何执行动态SQL语句？</li><li>如何自定义异常，如何把自定义异常与异常码绑定？</li><li>编写一个程序，输入一个整数，使用循环结构将该数字左右翻转，输出翻转后的结果。</li><li>编写一个程序，在EMP表查找姓名为ALLEN员工，并获取TOO_MANY_ROWS和NO_DATA_FOUND异常。</li><li>编写一个过程为班级每位同学创建一个用户，用户名和密码都是：“班级号+学号”，并为每位用户授权：CONNECT和RESOURCE。</li></ol><p>章节知识结构图</p><p>附录</p><p>数据库导入导出</p><pre><code>主要内容    导出</code></pre><p>    导入</p><ol><li>Oracle导入导出<br>Oracle的备份是Oracle操作中常见的工作，常见的备份方案有：逻辑备份（IMP&amp;EXP命令进行备份）、物理文件备份（脱机及联机备份）、利用RMAN(Recovery Manager)的增量物理文件系统备份。ORACLE数据库的逻辑备份分为四种模式：表空间备份(tablespace)、表备份(table)、用户备份(user)和完全备份(full)。Oracle的逻辑备份是使用IMP&amp;EXP命令进行数据导入导出的操作。使用EXP命令导出或者使用IMP命令导入时，需要Create Session系统权限，但是如果要导出其他的表，必须拥有权限：EXP_FULL_DATABASE。</li></ol><p>调用导入导出命令时，首先要估计所需的空间。EXP命令导出的文件是二进制文件（*.dmp）只能由对应的IMP命令进行读取恢复。导入导出的用途是：<br>    备份与恢复<br>    Oracle平台更换：可以在相同版本之间进行备份与恢复，Oracle较低版本的export数据文件可以import到高版本的Oracle数据库中，但是Oracle的版本只能是相邻的，不能垮版本。</p><ol start="2"><li>EXP导出数据<br>EXP命令可以在交互环境下导出数据库中的数据，也可以在非交互环境下执行命令。交互环境下的命令执行，是一步一步执行的过程。</li></ol><p>代码演示：exp的交互环境<br>D:>exp scott/tiger@my_orcl  ①<br>Export: Release 10.2.0.3.0 - Production on 星期一 10月 19 17:04:14 2009<br>Copyright (c) 1982, 2005, Oracle.  All rights reserved.<br>连接到: Oracle Database 10g Enterprise Edition Release 10.2.0.3.0 - Production<br>With the Partitioning, OLAP and Data Mining options<br>输入数组提取缓冲区大小: 4096 &gt;  ②<br> 导出文件: EXPDAT.DMP &gt; scott.dmp  ③<br>(2)U(用户), 或 (3)T(表): (2)U &gt; 2  ④<br>导出权限 (yes/no): yes &gt; yes  ⑤<br>导出表数据 (yes/no): yes &gt; yes  ⑥<br>压缩区 (yes/no): yes &gt; no  ⑦<br>已导出 ZHS16GBK 字符集和 AL16UTF16 NCHAR 字符集<br>. 正在导出 pre-schema 过程对象和操作<br>. 正在导出用户 SCOTT 的外部函数库名<br>. 导出 PUBLIC 类型同义词<br>. 正在导出专用类型同义词<br>. 正在导出用户 SCOTT 的对象类型定义<br>即将导出 SCOTT 的对象…<br>. 正在导出数据库链接<br>. 正在导出序号<br>. 正在导出簇定义<br>. 即将导出 SCOTT 的表通过常规路径…<br>. . 正在导出表                           BONUS导出了           0 行<br>. . 正在导出表                            DEPT导出了            10 行<br>. . 正在导出表                             EMP导出了            14 行<br>. . 正在导出表                        SALGRADE导出了           5 行<br>. . 正在导出表                      TBLSTUDENT导出了           3 行<br>. 正在导出同义词<br>. 正在导出视图<br>. 正在导出存储过程<br>. 正在导出运算符<br>. 正在导出引用完整性约束条件<br>. 正在导出触发器<br>. 正在导出索引类型<br>. 正在导出位图, 功能性索引和可扩展索引<br>. 正在导出后期表活动<br>. 正在导出实体化视图<br>. 正在导出快照日志<br>. 正在导出作业队列<br>. 正在导出刷新组和子组<br>. 正在导出维<br>. 正在导出 post-schema 过程对象和操作<br>. 正在导出统计信息<br>成功终止导出, 没有出现警告。<br>D:><br>代码解析：<br>①    Exp是导出命令，该命令后面紧跟“用户名/密码@服务器网络连接”。<br>②    Exp程序导出时使用的缓冲区大小，缓冲区越大，导出速度越快。直接回车代表使用默认值4096B。<br>③    Exp命令会把所有要到处的数据导出到一个Dmp文件中，该步骤是Exp询问导出的数据文件名称。<br>④    Exp程序询问导出整个用户还是导出某个表。默认导出整个用户。<br>⑤    Exp程序询问是否导出每张表的访问权限。默认导出访问权限。<br>⑥    Exp程序询问是否导出表中的数据。默认导出数据库表中的数据。<br>⑦    Oracle表中的数据可能来自不同的分区中的数据块，默认导出时会把所有的数据压缩在一个数据块上，IMP导入时，如果不存在连续一个大数据块，则会导入失败。</p><p>也可以使用Exp命令时，设置各种参数，使准备就绪的Exp命令不需要与用户交互，按照参数的要求，Exp命令会一次性执行导出工作。要指定参数，您可以使用关键字:</p><p>EXP KEYWORD=value 或 KEYWORD=(value1,value2,…,valueN)</p><p>例如: EXP SCOTT/TIGER GRANTS=Y TABLES=(EMP,DEPT,MGR)</p><p>参数名    说明<br>USERID    表示“用户名/密码”。<br>BUFFER    数据缓冲区大小。以字节为单位，一般在64000以上。<br>FILE    指定输出文件的路径和文件名。一般以.dmp为后缀名，注意该文件包括完整路径，但是路径必须存在，导出命令不能自动创建路径。<br>COMPRESS    是否压缩导出，默认yes。<br>GRANTS    是否导出权限，默认yes<br>INDEXES    是否导出索引，默认yes<br>DIRECT    是否直接导出，默认情况，数据先经过Oracle的数据缓冲区，然后再导出数据。<br>LOG    指定导出命令的日志所在的日志文件的位置。<br>ROWS    是否导出数据行，默认导出所有数据。<br>CONSTRAINTS    是否导出表的约束条件，默认yes<br>PARFILE    可以把各种参数配置为一个文本键值形式的文件，该参数可以指定参数文件的位置。<br>TRIGGERS    是否导出触发器，默认值是yes。<br>TABLES    表的名称列表，导出多个表可以使用逗号隔开。<br>TABLESPACES    导出某一个表空间的数据。<br>Owner    导出某一用户的数据。<br>Full    导出数据库的所有数据。默认值是no。<br>QUERY    把查询的结果导出。<br>表1  EXP参数说明</p><p>代码演示：exp的非交互环境<br>D:>exp scott/tiger file=employee.dmp tables=(emp,dept)<br>Export: Release 10.2.0.3.0 - Production on 星期一 10月 19 17:38:25 2009<br>Copyright (c) 1982, 2005, Oracle.  All rights reserved.<br>连接到: Oracle Database 10g Enterprise Edition Release 10.2.0.3.0 - Production<br>With the Partitioning, OLAP and Data Mining options<br>已导出 ZHS16GBK 字符集和 AL16UTF16 NCHAR 字符集<br>即将导出指定的表通过常规路径…<br>. . 正在导出表                             EMP导出了          14 行<br>. . 正在导出表                            DEPT导出了          10 行<br>成功终止导出, 没有出现警告。<br>D:></p><ol start="3"><li>IMP导入<br>IMP程序导入就是把Exp导出的文件重新导入到数据库的过程。导入时也有一些重要的参数：<br>    Fromuser:指出导出时dmp文件中记载的用户信息。<br>    Touser:dmp文件要导入到什么目标用户中。<br>    Commit:默认是N,在缓冲区满时是否需要commit,如果设为N,需要较大的回滚段。<br>    Igore: Oracle在恢复数据的过程中，当恢复某个表时，该表已经存在，就要根据ignore参数的设置来决定如何操作。若ignore=y，Oracle不执行CREATE TABLE语句，直接将数据插入到表中，如果插入的记录违背了约束条件，比如主键约束，则出错的记录不会插入，但合法的记录会添加到表中。若ignore=n，Oracle不执行CREATE TABLE语句，同时也不会将数据插入到表中，而是忽略该表的错误，继续恢复下一个表。</li></ol><p>代码演示：Imp导入<br>D:>imp system/manager file=employee.dmp fromuser=scott touser=employee commit=y<br>Import: Release 10.2.0.3.0 - Production on 星期一 10月 19 17:54:51 2009<br>Copyright (c) 1982, 2005, Oracle.  All rights reserved.<br>连接到: Oracle Database 10g Enterprise Edition Release 10.2.0.3.0 - Production<br>With the Partitioning, OLAP and Data Mining options<br>经由常规路径由 EXPORT:V10.02.01 创建的导出文件<br>警告: 这些对象由 SCOTT 导出, 而不是当前用户<br>已经完成 ZHS16GBK 字符集和 AL16UTF16 NCHAR 字符集中的导入<br>. 正在将 SCOTT 的对象导入到 EMPLOYEE<br>. . 正在导入表                           “EMP”导入了          14 行<br>. . 正在导入表                          “DEPT”导入了          10 行<br>即将启用约束条件…<br>成功终止导入, 没有出现警告。<br>D:></p><ol start="4"><li>常见问题<br>    数据库对象已经存在<br>一般情况, 导入数据前应该彻底删除目标数据下的表，序列，函数/过程,触发器等。<br>数据库对象已经存在, 按缺省的imp参数，则会导入失败。<br>如果用了参数ignore=y，会把exp文件内的数据内容导入。<br>如果表有唯一关键字的约束条件，不合条件将不被导入。<br>如果表没有唯一关键字的约束条件，将引起记录重复。</li></ol><p>    数据库对象有主外键约束<br>不符合主外键约束时，数据会导入失败。<br>解决办法: 先导入主表，再导入依存表。<br>disable目标导入对象的主外键约束，导入数据后，再enable它们。</p><p>    权限不够<br>如果要把A用户的数据导入B用户下， A用户需要有imp_full_database权限。</p><p>    导入大表( 大于80M ) 时，存储分配失败<br>默认的EXP时，compress = Y，也就是把所有的数据压缩在一个数据块上。<br>导入时，如果不存在连续一个大数据块，则会导入失败。<br>导出80M以上的大表时，记得compress= N，则不会引起这种错误。</p><p>    Imp和Exp使用的字符集不同<br>如果字符集不同，导入会失败，可以改变unix环境变量或者NT注册表里NLS_LANG相关信息。</p><p>    Imp和Exp版本不能往上兼容<br>Imp可以成功导入低版本Exp生成的文件, 不能导入高版本Exp生成的文件根据情况我们可以用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Oracle上机实验手册&lt;/p&gt;
&lt;p&gt;Oracle管理    2&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Oracle启动和关闭    3&lt;/li&gt;
&lt;li&gt;Oracle用户和权限    4&lt;br&gt;SQL数据操作和查询    6&lt;/li&gt;
&lt;li&gt;SQL简介    7&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="oracle" scheme="https://wadezhx.github.io/tags/oracle/"/>
    
  </entry>
  
</feed>
