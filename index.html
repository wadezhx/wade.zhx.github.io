<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://wadezhx.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://wadezhx.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-数据结构中各种树" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/数据结构中各种树/" class="article-date">
  <time datetime="2018-12-06T02:48:13.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/数据结构中各种树/">数据结构中各种树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="数据结构中各种树"><a href="#数据结构中各种树" class="headerlink" title="数据结构中各种树"></a>数据结构中各种树</h1><p>原文出处： Poll的笔记<br>数据结构中有很多树的结构，其中包括二叉树、二叉搜索树、2-3树、红黑树等等。本文中对数据结构中常见的几种树的概念和用途进行了汇总，不求严格精准，但求简单易懂。1. 二叉树<br>二叉树是数据结构中一种重要的数据结构，也是树表家族最为基础的结构。<br>二叉树的定义：二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2i-1个结点；深度为k的二叉树至多有2k-1个结点；对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。<br>二叉树的示例：</p>
<p>满二叉树和完全二叉树：<br>满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上。<br>满二叉树的性质：<br>1) 一颗树深度为h，最大层数为k，深度与最大层数相同，k=h;<br>2) 叶子数为2h;<br>3) 第k层的结点数是：2k-1;<br>4) 总结点数是：2k-1，且总节点数一定是奇数。<br>完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。<br>注：完全二叉树是效率很高的数据结构，堆是一种完全二叉树或者近似完全二叉树，所以效率极高，像十分常用的排序算法、Dijkstra算法、Prim算法等都要用堆才能优化，二叉排序树的效率也要借助平衡性来提高，而平衡性基于完全二叉树。</p>
<p>二叉树的性质：<br>1) 在非空二叉树中，第i层的结点总数不超过2i-1, i&gt;=1;<br>2) 深度为h的二叉树最多有2h-1个结点(h&gt;=1)，最少有h个结点;<br>3) 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1;<br>4) 具有n个结点的完全二叉树的深度为log2(n+1);<br>5)有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系：<br>若I为结点编号则 如果I&gt;1，则其父结点的编号为I/2；<br>如果2I&lt;=N，则其左儿子（即左子树的根结点）的编号为2I；若2I&gt;N，则无左儿子；<br>如果2I+1&lt;=N，则其右儿子的结点编号为2I+1；若2I+1&gt;N，则无右儿子。<br>6)给定N个节点，能构成h(N)种不同的二叉树，其中h(N)为卡特兰数的第N项，h(n)=C(2*n, n)/(n+1)。<br>7)设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和J=I+2i。2. 二叉查找树<br>二叉查找树定义：又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：<br>1) 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>2) 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；<br>3) 左、右子树也分别为二叉排序树；<br>4) 没有键值相等的节点。<br>二叉查找树的性质：对二叉查找树进行中序遍历，即可得到有序的数列。<br>二叉查找树的时间复杂度：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。<br>二叉查找树的高度决定了二叉查找树的查找效率。<br>二叉查找树的插入过程如下：<br>1) 若当前的二叉查找树为空，则插入的元素为根节点;<br>2) 若插入的元素值小于根节点值，则将元素插入到左子树中;<br>3) 若插入的元素值不小于根节点值，则将元素插入到右子树中。<br>二叉查找树的删除，分三种情况进行处理：<br>1) p为叶子节点，直接删除该节点，再修改其父节点的指针（注意分是根节点和不是根节点），如图a;<br>2) p为单支节点（即只有左子树或右子树）。让p的子树与p的父亲节点相连，删除p即可（注意分是根节点和不是根节点），如图b;<br>3) p的左子树和右子树均不空。找到p的后继y，因为y一定没有左子树，所以可以删除y，并让y的父亲节点成为y的右子树的父亲节点，并用y的值代替p的值；或者方法二是找到p的前驱x，x一定没有右子树，所以可以删除x，并让x的父亲节点成为y的左子树的父亲节点。如图c。</p>
<p>二叉树相关实现源码：<br>插入操作：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60</p>
<p>struct node<br>{<br>    int val;<br>    pnode lchild;<br>    pnode rchild;<br>};</p>
<p>pnode BT = NULL;</p>
<p>//递归方法插入节点<br>pnode insert(pnode root, int x)<br>{<br>    pnode p = (pnode)malloc(LEN);<br>    p-&gt;val = x;<br>    p-&gt;lchild = NULL;<br>    p-&gt;rchild = NULL;<br>    if(root == NULL){<br>        root = p;<br>    }<br>    else if(x &lt; root-&gt;val){<br>        root-&gt;lchild = insert(root-&gt;lchild, x);<br>    }<br>    else{<br>        root-&gt;rchild = insert(root-&gt;rchild, x);<br>    }<br>    return root;<br>}</p>
<p>//非递归方法插入节点<br>void insert_BST(pnode q, int x)<br>{<br>    pnode p = (pnode)malloc(LEN);<br>    p-&gt;val = x;<br>    p-&gt;lchild = NULL;<br>    p-&gt;rchild = NULL;<br>    if(q == NULL){<br>        BT = p;<br>        return ;<br>    }<br>    while(q-&gt;lchild != p &amp;&amp; q-&gt;rchild != p){<br>        if(x &lt; q-&gt;val){<br>            if(q-&gt;lchild){<br>                q = q-&gt;lchild;<br>            }<br>            else{<br>                q-&gt;lchild = p;<br>            }<br>        }<br>        else{<br>            if(q-&gt;rchild){<br>                q = q-&gt;rchild;<br>            }<br>            else{<br>                q-&gt;rchild = p;<br>            }<br>        }<br>    }<br>    return;<br>}</p>
<p>删除操作：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77</p>
<p>bool delete_BST(pnode p, int x) //返回一个标志，表示是否找到被删元素<br>{<br>    bool find = false;<br>    pnode q;<br>    p = BT;<br>    while(p &amp;&amp; !find){  //寻找被删元素<br>        if(x == p-&gt;val){  //找到被删元素<br>            find = true;<br>        }<br>        else if(x &lt; p-&gt;val){ //沿左子树找<br>            q = p;<br>            p = p-&gt;lchild;<br>        }<br>        else{   //沿右子树找<br>            q = p;<br>            p = p-&gt;rchild;<br>        }<br>    }<br>    if(p == NULL){   //没找到<br>        cout &lt;&lt; “没有找到” &lt;&lt; x &lt;&lt; endl;<br>    }</p>
<pre><code>if(p-&gt;lchild == NULL &amp;&amp; p-&gt;rchild == NULL){  //p为叶子节点
    if(p == BT){  //p为根节点
        BT = NULL;    
    }
    else if(q-&gt;lchild == p){  
        q-&gt;lchild = NULL;
    }        
    else{
        q-&gt;rchild = NULL;    
    }
    free(p);  //释放节点p
}
else if(p-&gt;lchild == NULL || p-&gt;rchild == NULL){ //p为单支子树
    if(p == BT){  //p为根节点
        if(p-&gt;lchild == NULL){
            BT = p-&gt;rchild;    
        }    
        else{
            BT = p-&gt;lchild;    
        }
    }    
    else{
        if(q-&gt;lchild == p &amp;&amp; p-&gt;lchild){ //p是q的左子树且p有左子树
            q-&gt;lchild = p-&gt;lchild;    //将p的左子树链接到q的左指针上
        }    
        else if(q-&gt;lchild == p &amp;&amp; p-&gt;rchild){
            q-&gt;lchild = p-&gt;rchild;    
        }
        else if(q-&gt;rchild == p &amp;&amp; p-&gt;lchild){
            q-&gt;rchild = p-&gt;lchild;    
        }
        else{
            q-&gt;rchild = p-&gt;rchild;
        }
    }
    free(p);
}
else{ //p的左右子树均不为空
    pnode t = p;
    pnode s = p-&gt;lchild;  //从p的左子节点开始
    while(s-&gt;rchild){  //找到p的前驱，即p左子树中值最大的节点
        t = s;  
        s = s-&gt;rchild;    
    }
    p-&gt;val = s-&gt;val;   //把节点s的值赋给p
    if(t == p){
        p-&gt;lchild = s-&gt;lchild;    
    }    
    else{
        t-&gt;rchild = s-&gt;lchild;    
    }
    free(s);
}
return find;
</code></pre><p>}</p>
<p>查找操作：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19</p>
<p>pnode search_BST(pnode p, int x)<br>{<br>    bool solve = false;<br>    while(p &amp;&amp; !solve){<br>        if(x == p-&gt;val){<br>            solve = true;<br>        }<br>        else if(x &lt; p-&gt;val){<br>            p = p-&gt;lchild;<br>        }<br>        else{<br>            p = p-&gt;rchild;<br>        }<br>    }<br>    if(p == NULL){<br>        cout &lt;&lt; “没有找到” &lt;&lt; x &lt;&lt; endl;<br>    }<br>    return p;<br>}</p>
<ol start="3">
<li>平衡二叉树<br>我们知道，对于一般的二叉搜索树（Binary Search Tree），其期望高度（即为一棵平衡树时）为log2n，其各操作的时间复杂度O(log2n)同时也由此而决定。但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即O(n)。我们可以通过随机化建立二叉搜索树来尽量的避免这种情况，但是在进行了多次的操作之后，由于在删除时，我们总是选择将待删除节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于树向左偏沉。这同时也会造成树的平衡性受到破坏，提高它的操作的时间复杂度。于是就有了我们下边介绍的平衡二叉树。<br>平衡二叉树定义：平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用算法有红黑树、AVL树等。在平衡二叉搜索树中，我们可以看到，其高度一般都良好地维持在O(log2n)，大大降低了操作的时间复杂度。<br>最小二叉平衡树的节点的公式如下：<br>F(n)=F(n-1)+F(n-2)+1<br>这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。3.1 平衡查找树之AVL树<br>有关AVL树的具体实现，可以参考C小加的博客《一步一步写平衡二叉树（AVL）》。<br>AVL树定义：AVL树是最先发明的自平衡二叉查找树。AVL树得名于它的发明者 G.M. Adelson-Velsky 和 E.M. Landis，他们在 1962 年的论文 “An algorithm for the organization of information” 中发表了它。在AVL中任何节点的两个儿子子树的高度最大差别为1，所以它也被称为高度平衡树，n个结点的AVL树最大深度约1.44log2n。查找、插入和删除在平均和最坏情况下都是O(logn)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。<br>AVL树的自平衡操作——旋转：<br>AVL树最关键的也是最难的一步操作就是旋转。旋转主要是为了实现AVL树在实施了插入和删除操作以后，树重新回到平衡的方法。下面我们重点研究一下AVL树的旋转。<br>对于一个平衡的节点，由于任意节点最多有两个儿子，因此高度不平衡时，此节点的两颗子树的高度差2.容易看出，这种不平衡出现在下面四种情况：</li>
</ol>
<p>1) 6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为左左。<br>2) 6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为左右。<br>3) 2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为右左。<br>4) 2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为右右。<br>从图2中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，我们称之为单旋转。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，我们称之为双旋转。<br>单旋转<br>单旋转是针对于左左和右右这两种情况的解决方案，这两种情况是对称的，只要解决了左左这种情况，右右就很好办了。图3是左左情况的解决方案，节点k2不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的左子树X子树，所以属于左左情况。</p>
<p>为使树恢复平衡，我们把k2变成这棵树的根节点，因为k2大于k1，把k2置于k1的右子树上，而原本在k1右子树的Y大于k1，小于k2，就把Y置于k2的左子树上，这样既满足了二叉查找树的性质，又满足了平衡二叉树的性质。<br>这样的操作只需要一部分指针改变，结果我们得到另外一颗二叉查找树，它是一棵AVL树，因为X向上一移动了一层，Y还停留在原来的层面上，Z向下移动了一层。整棵树的新高度和之前没有在左子树上插入的高度相同，插入操作使得X高度长高了。因此，由于这颗子树高度没有变化，所以通往根节点的路径就不需要继续旋转了。<br>双旋转<br>对于左右和右左这两种情况，单旋转不能使它达到一个平衡状态，要经过两次旋转。双旋转是针对于这两种情况的解决方案，同样的，这样两种情况也是对称的，只要解决了左右这种情况，右左就很好办了。图4是左右情况的解决方案，节点k3不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的右子树k2子树，所以属于左右情况。</p>
<p>为使树恢复平衡，我们需要进行两步，第一步，把k1作为根，进行一次右右旋转，旋转之后就变成了左左情况，所以第二步再进行一次左左旋转，最后得到了一棵以k2为根的平衡二叉树。<br>AVL树实现源码：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148<br>149<br>150<br>151<br>152<br>153<br>154<br>155<br>156<br>157<br>158<br>159<br>160<br>161<br>162<br>163<br>164<br>165<br>166<br>167<br>168<br>169<br>170<br>171<br>172<br>173<br>174<br>175<br>176<br>177<br>178<br>179<br>180<br>181<br>182<br>183<br>184<br>185<br>186<br>187<br>188<br>189<br>190<br>191<br>192<br>193<br>194<br>195<br>196<br>197<br>198<br>199<br>200<br>201<br>202<br>203<br>204<br>205<br>206<br>207<br>208<br>209<br>210<br>211<br>212<br>213<br>214<br>215<br>216<br>217<br>218<br>219<br>220<br>221<br>222<br>223<br>224<br>225<br>226<br>227<br>228<br>229</p>
<p>//AVL树节点信息<br>template<class t=""><br>class TreeNode<br>{<br>    public:<br>        TreeNode():lson(NULL),rson(NULL),freq(1),hgt(0){}<br>        T data;//值<br>        int hgt;//高度<br>        unsigned int freq;//频率<br>        TreeNode<em> lson;//指向左儿子的地址<br>        TreeNode</em> rson;//指向右儿子的地址<br>};<br>//AVL树类的属性和方法声明<br>template<class t=""><br>class AVLTree<br>{<br>    private:<br>        TreeNode<t><em> root;//根节点<br>        void insertpri(TreeNode<t></t></em> &amp;node,T x);//插入<br>        TreeNode<t><em> findpri(TreeNode<t></t></em> node,T x);//查找<br>        void insubtree(TreeNode<t><em> node);//中序遍历<br>        void Deletepri(TreeNode<t></t></em> &amp;node,T x);//删除<br>        int height(TreeNode<t><em> node);//求树的高度<br>        void SingRotateLeft(TreeNode<t></t></em> &amp;k2);//左左情况下的旋转<br>        void SingRotateRight(TreeNode<t><em> &amp;k2);//右右情况下的旋转<br>        void DoubleRotateLR(TreeNode<t></t></em> &amp;k3);//左右情况下的旋转<br>        void DoubleRotateRL(TreeNode<t>* &amp;k3);//右左情况下的旋转<br>        int Max(int cmpa,int cmpb);//求最大值</t></t></t></t></t></t></class></class></p>
<pre><code>public:
    AVLTree():root(NULL){}
    void insert(T x);//插入接口
    TreeNode&lt;T&gt;* find(T x);//查找接口
    void Delete(T x);//删除接口
    void traversal();//遍历接口
</code></pre><p>};<br>//计算节点的高度<br>template<class t=""><br>int AVLTree<t>::height(TreeNode<t><em> node)<br>{<br>    if(node!=NULL)<br>        return node-&gt;hgt;<br>    return -1;<br>}<br>//求最大值<br>template<class t=""><br>int AVLTree<t>::Max(int cmpa,int cmpb)<br>{<br>    return cmpa&gt;cmpb?cmpa:cmpb;<br>}<br>//左左情况下的旋转<br>template<class t=""><br>void AVLTree<t>::SingRotateLeft(TreeNode<t></t></t></class></t></class></em> &amp;k2)<br>{<br>    TreeNode<t>* k1;<br>    k1=k2-&gt;lson;<br>    k2-&gt;lson=k1-&gt;rson;<br>    k1-&gt;rson=k2;</t></t></t></class></p>
<pre><code>k2-&gt;hgt=Max(height(k2-&gt;lson),height(k2-&gt;rson))+1;
k1-&gt;hgt=Max(height(k1-&gt;lson),k2-&gt;hgt)+1;
</code></pre><p>}<br>//右右情况下的旋转<br>template<class t=""><br>void AVLTree<t>::SingRotateRight(TreeNode<t><em> &amp;k2)<br>{<br>    TreeNode<t></t></em> k1;<br>    k1=k2-&gt;rson;<br>    k2-&gt;rson=k1-&gt;lson;<br>    k1-&gt;lson=k2;</t></t></class></p>
<pre><code>k2-&gt;hgt=Max(height(k2-&gt;lson),height(k2-&gt;rson))+1;
k1-&gt;hgt=Max(height(k1-&gt;rson),k2-&gt;hgt)+1;
</code></pre><p>}<br>//左右情况的旋转<br>template<class t=""><br>void AVLTree<t>::DoubleRotateLR(TreeNode<t><em> &amp;k3)<br>{<br>    SingRotateRight(k3-&gt;lson);<br>    SingRotateLeft(k3);<br>}<br>//右左情况的旋转<br>template<class t=""><br>void AVLTree<t>::DoubleRotateRL(TreeNode<t></t></t></class></em> &amp;k3)<br>{<br>    SingRotateLeft(k3-&gt;rson);<br>    SingRotateRight(k3);<br>}<br>//插入<br>template<class t=""><br>void AVLTree<t>::insertpri(TreeNode<t><em> &amp;node,T x)<br>{<br>    if(node==NULL)//如果节点为空,就在此节点处加入x信息<br>    {<br>        node=new TreeNode<t>();<br>        node-&gt;data=x;<br>        return;<br>    }<br>    if(node-&gt;data&gt;x)//如果x小于节点的值,就继续在节点的左子树中插入x<br>    {<br>        insertpri(node-&gt;lson,x);<br>        if(2==height(node-&gt;lson)-height(node-&gt;rson))<br>            if(x<node->lson-&gt;data)<br>                SingRotateLeft(node);<br>            else<br>                DoubleRotateLR(node);<br>    }<br>    else if(node-&gt;data&lt;x)//如果x大于节点的值,就继续在节点的右子树中插入x<br>    {<br>        insertpri(node-&gt;rson,x);<br>        if(2==height(node-&gt;rson)-height(node-&gt;lson))//如果高度之差为2的话就失去了平衡,需要旋转<br>            if(x&gt;node-&gt;rson-&gt;data)<br>                SingRotateRight(node);<br>            else<br>                DoubleRotateRL(node);<br>    }<br>    else ++(node-&gt;freq);//如果相等,就把频率加1<br>    node-&gt;hgt=Max(height(node-&gt;lson),height(node-&gt;rson));<br>}<br>//插入接口<br>template<class t=""><br>void AVLTree<t>::insert(T x)<br>{<br>    insertpri(root,x);<br>}<br>//查找<br>template<class t=""><br>TreeNode<t></t></class></t></class></node-></t></em> AVLTree<t>::findpri(TreeNode<t><em> node,T x)<br>{<br>    if(node==NULL)//如果节点为空说明没找到,返回NULL<br>    {<br>        return NULL;<br>    }<br>    if(node-&gt;data&gt;x)//如果x小于节点的值,就继续在节点的左子树中查找x<br>    {<br>        return findpri(node-&gt;lson,x);<br>    }<br>    else if(node-&gt;data&lt;x)//如果x大于节点的值,就继续在节点的左子树中查找x<br>    {<br>        return findpri(node-&gt;rson,x);<br>    }<br>    else return node;//如果相等,就找到了此节点<br>}<br>//查找接口<br>template<class t=""><br>TreeNode<t></t></class></em> AVLTree<t>::find(T x)<br>{<br>    return findpri(root,x);<br>}<br>//删除<br>template<class t=""><br>void AVLTree<t>::Deletepri(TreeNode<t>* &amp;node,T x)<br>{<br>    if(node==NULL) return ;//没有找到值是x的节点<br>    if(x &lt; node-&gt;data)<br>    {<br>         Deletepri(node-&gt;lson,x);//如果x小于节点的值,就继续在节点的左子树中删除x<br>         if(2==height(node-&gt;rson)-height(node-&gt;lson))<br>            if(node-&gt;rson-&gt;lson!=NULL&amp;&amp;(height(node-&gt;rson-&gt;lson)&gt;height(node-&gt;rson-&gt;rson)) )<br>                DoubleRotateRL(node);<br>            else<br>                SingRotateRight(node);<br>    }</t></t></class></t></t></t></t></t></class></t></t></class></p>
<pre><code>else if(x &gt; node-&gt;data)
{
     Deletepri(node-&gt;rson,x);//如果x大于节点的值,就继续在节点的右子树中删除x
     if(2==height(node-&gt;lson)-height(node-&gt;rson))
        if(node-&gt;lson-&gt;rson!=NULL&amp;&amp; (height(node-&gt;lson-&gt;rson)&gt;height(node-&gt;lson-&gt;lson) ))
            DoubleRotateLR(node);
        else
            SingRotateLeft(node);
}

else//如果相等,此节点就是要删除的节点
{
    if(node-&gt;lson&amp;&amp;node-&gt;rson)//此节点有两个儿子
    {
        TreeNode&lt;T&gt;* temp=node-&gt;rson;//temp指向节点的右儿子
        while(temp-&gt;lson!=NULL) temp=temp-&gt;lson;//找到右子树中值最小的节点
        //把右子树中最小节点的值赋值给本节点
        node-&gt;data=temp-&gt;data;
        node-&gt;freq=temp-&gt;freq;
        Deletepri(node-&gt;rson,temp-&gt;data);//删除右子树中最小值的节点
        if(2==height(node-&gt;lson)-height(node-&gt;rson))
        {
            if(node-&gt;lson-&gt;rson!=NULL&amp;&amp; (height(node-&gt;lson-&gt;rson)&gt;height(node-&gt;lson-&gt;lson) ))
                DoubleRotateLR(node);
            else
                SingRotateLeft(node);
        }
    }
    else//此节点有1个或0个儿子
    {
        TreeNode&lt;T&gt;* temp=node;
        if(node-&gt;lson==NULL)//有右儿子或者没有儿子
        node=node-&gt;rson;
        else if(node-&gt;rson==NULL)//有左儿子
        node=node-&gt;lson;
        delete(temp);
        temp=NULL;
    }
}
if(node==NULL) return;
node-&gt;hgt=Max(height(node-&gt;lson),height(node-&gt;rson))+1;
return;
</code></pre><p>}<br>//删除接口<br>template<class t=""><br>void AVLTree<t>::Delete(T x)<br>{<br>    Deletepri(root,x);<br>}<br>//中序遍历函数<br>template<class t=""><br>void AVLTree<t>::insubtree(TreeNode<t>* node)<br>{<br>    if(node==NULL) return;<br>    insubtree(node-&gt;lson);//先遍历左子树<br>    cout&lt;<node->data&lt;&lt;” “;//输出根节点<br>    insubtree(node-&gt;rson);//再遍历右子树<br>}<br>//中序遍历接口<br>template<class t=""><br>void AVLTree<t>::traversal()<br>{<br>    insubtree(root);<br>}</t></class></node-></t></t></class></t></class></p>
<p>3.2 平衡二叉树之红黑树<br>红黑树的定义：红黑树是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它是在1972年由鲁道夫·贝尔发明的，称之为”对称二叉B树”，它现代的名字是在 Leo J. Guibas 和 Robert Sedgewick 于1978年写的一篇论文中获得的。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(logn)时间内做查找，插入和删除，这里的n是树中元素的数目。<br>红黑树和AVL树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。这不只是使它们在时间敏感的应用如实时应用（real time application）中有价值，而且使它们有在提供最坏情况担保的其他数据结构中作为建造板块的价值；例如，在计算几何中使用的很多数据结构都可以基于红黑树。此外，红黑树还是2-3-4树的一种等同，它们的思想是一样的，只不过红黑树是2-3-4树用二叉树的形式表示的。<br>红黑树的性质：<br>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制的一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:<br>性质1. 节点是红色或黑色。<br>性质2. 根是黑色。<br>性质3. 所有叶子都是黑色（叶子是NIL节点）。<br>性质4. 每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。)<br>性质5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。<br>下面是一个具体的红黑树的图例：</p>
<p>这些约束确保了红黑树的关键特性: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。<br>要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。<br>以下内容整理自wiki百科之红黑树。<br>红黑树的自平衡操作：<br>因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。然而，在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量(O(logn))的颜色变更(实际是非常快速的)和不超过三次树旋转(对于插入操作是两次)。虽然插入和删除很复杂，但操作时间仍可以保持为O(logn) 次。<br>我们首先以二叉查找树的方法增加节点并标记它为红色。如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的（违背性质5）。但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整。下面要进行什么操作取决于其他临近节点的颜色。同人类的家族树中一样，我们将使用术语叔父节点来指一个节点的父节点的兄弟节点。注意:</p>
<pre><code>* 
</code></pre><p>性质1和性质3总是保持着。</p>
<pre><code>* 
</code></pre><p>性质4只在增加红色节点、重绘黑色节点为红色，或做旋转时受到威胁。</p>
<pre><code>* 
</code></pre><p>性质5只在增加黑色节点、重绘红色节点为黑色，或做旋转时受到威胁。</p>
<p>插入操作：<br>假设，将要插入的节点标为N，N的父节点标为P，N的祖父节点标为G，N的叔父节点标为U。在图中展示的任何颜色要么是由它所处情形这些所作的假定，要么是假定所暗含的。<br>情形1: 该树为空树，直接插入根结点的位置，违反性质1，把节点颜色有红改为黑即可。<br>情形2: 插入节点N的父节点P为黑色，不违反任何性质，无需做任何修改。在这种情形下，树仍是有效的。性质5也未受到威胁，尽管新节点N有两个黑色叶子子节点；但由于新节点N是红色，通过它的每个子节点的路径就都有同通过它所取代的黑色的叶子的路径同样数目的黑色节点，所以依然满足这个性质。<br>注： 情形1很简单，情形2中P为黑色，一切安然无事，但P为红就不一样了，下边是P为红的各种情况，也是真正难懂的地方。<br>情形3: 如果父节点P和叔父节点U二者都是红色，(此时新插入节点N做为P的左子节点或右子节点都属于情形3,这里右图仅显示N做为P左子的情形)则我们可以将它们两个重绘为黑色并重绘祖父节点G为红色(用来保持性质4)。现在我们的新节点N有了一个黑色的父节点P。因为通过父节点P或叔父节点U的任何路径都必定通过祖父节点G，在这些路径上的黑节点数目没有改变。但是，红色的祖父节点G的父节点也有可能是红色的，这就违反了性质4。为了解决这个问题，我们在祖父节点G上递归地进行上述情形的整个过程（把G当成是新加入的节点进行各种情形的检查）。比如，G为根节点，那我们就直接将G变为黑色（情形1）；如果G不是根节点，而它的父节点为黑色，那符合所有的性质，直接插入即可（情形2）；如果G不是根节点，而它的父节点为红色，则递归上述过程（情形3）。</p>
<p>情形4: 父节点P是红色而叔父节点U是黑色或缺少，新节点N是其父节点的左子节点，而父节点P又是其父节点G的左子节点。在这种情形下，我们进行针对祖父节点G的一次右旋转; 在旋转产生的树中，以前的父节点P现在是新节点N和以前的祖父节点G的父节点。我们知道以前的祖父节点G是黑色，否则父节点P就不可能是红色(如果P和G都是红色就违反了性质4，所以G必须是黑色)。我们切换以前的父节点P和祖父节点G的颜色，结果的树满足性质4。性质5也仍然保持满足，因为通过这三个节点中任何一个的所有路径以前都通过祖父节点G，现在它们都通过以前的父节点P。在各自的情形下，这都是三个节点中唯一的黑色节点。</p>
<p>情形5: 父节点P是红色而叔父节点U是黑色或缺少，并且新节点N是其父节点P的右子节点而父节点P又是其父节点的左子节点。在这种情形下，我们进行一次左旋转调换新节点和其父节点的角色; 接着，我们按情形4处理以前的父节点P以解决仍然失效的性质4。注意这个改变会导致某些路径通过它们以前不通过的新节点N（比如图中1号叶子节点）或不通过节点P（比如图中3号叶子节点），但由于这两个节点都是红色的，所以性质5仍有效。</p>
<p>注: 插入实际上是原地算法，因为上述所有调用都使用了尾部递归。<br>删除操作：<br>如果需要删除的节点有两个儿子，那么问题可以被转化成删除另一个只有一个儿子的节点的问题。对于二叉查找树，在删除带有两个非叶子儿子的节点的时候，我们找到要么在它的左子树中的最大元素、要么在它的右子树中的最小元素，并把它的值转移到要删除的节点中。我们接着删除我们从中复制出值的那个节点，它必定有少于两个非叶子的儿子。因为只是复制了一个值，不违反任何性质，这就把问题简化为如何删除最多有一个儿子的节点的问题。它不关心这个节点是最初要删除的节点还是我们从中复制出值的那个节点。<br>我们只需要讨论删除只有一个儿子的节点(如果它两个儿子都为空，即均为叶子，我们任意将其中一个看作它的儿子)。如果我们删除一个红色节点（此时该节点的儿子将都为叶子节点），它的父亲和儿子一定是黑色的。所以我们可以简单的用它的黑色儿子替换它，并不会破坏性质3和性质4。通过被删除节点的所有路径只是少了一个红色节点，这样可以继续保证性质5。另一种简单情况是在被删除节点是黑色而它的儿子是红色的时候。如果只是去除这个黑色节点，用它的红色儿子顶替上来的话，会破坏性质5，但是如果我们重绘它的儿子为黑色，则曾经通过它的所有路径将通过它的黑色儿子，这样可以继续保持性质5。<br>需要进一步讨论的是在要删除的节点和它的儿子二者都是黑色的时候，这是一种复杂的情况。我们首先把要删除的节点替换为它的儿子。出于方便，称呼这个儿子为N(在新的位置上)，称呼它的兄弟(它父亲的另一个儿子)为S。在下面的示意图中，我们还是使用P称呼N的父亲，SL称呼S的左儿子，SR称呼S的右儿子。<br>如果N和它初始的父亲是黑色，则删除它的父亲导致通过N的路径都比不通过它的路径少了一个黑色节点。因为这违反了性质5，树需要被重新平衡。有几种情形需要考虑:<br>情形1: N是新的根。在这种情形下，我们就做完了。我们从所有路径去除了一个黑色节点，而新根是黑色的，所以性质都保持着。<br>注意: 在情形2、5和6下，我们假定N是它父亲的左儿子。如果它是右儿子，则在这些情形下的左和右应当对调。<br>情形2: S是红色。在这种情形下我们在N的父亲上做左旋转，把红色兄弟转换成N的祖父，我们接着对调N的父亲和祖父的颜色。完成这两个操作后，尽管所有路径上黑色节点的数目没有改变，但现在N有了一个黑色的兄弟和一个红色的父亲（它的新兄弟是黑色因为它是红色S的一个儿子），所以我们可以接下去按情形4、情形5或情形6来处理。</p>
<p>情形3: N的父亲、S和S的儿子都是黑色的。在这种情形下，我们简单的重绘S为红色。结果是通过S的所有路径，它们就是以前不通过N的那些路径，都少了一个黑色节点。因为删除N的初始的父亲使通过N的所有路径少了一个黑色节点，这使事情都平衡了起来。但是，通过P的所有路径现在比不通过P的路径少了一个黑色节点，所以仍然违反性质5。要修正这个问题，我们要从情形1开始，在P上做重新平衡处理。</p>
<p>情形4: S和S的儿子都是黑色，但是N的父亲是红色。在这种情形下，我们简单的交换N的兄弟和父亲的颜色。这不影响不通过N的路径的黑色节点的数目，但是它在通过N的路径上对黑色节点数目增加了一，添补了在这些路径上删除的黑色节点。</p>
<p>情形5: S是黑色，S的左儿子是红色，S的右儿子是黑色，而N是它父亲的左儿子。在这种情形下我们在S上做右旋转，这样S的左儿子成为S的父亲和N的新兄弟。我们接着交换S和它的新父亲的颜色。所有路径仍有同样数目的黑色节点，但是现在N有了一个黑色兄弟，他的右儿子是红色的，所以我们进入了情形6。N和它的父亲都不受这个变换的影响。</p>
<p>情形6: S是黑色，S的右儿子是红色，而N是它父亲的左儿子。在这种情形下我们在N的父亲上做左旋转，这样S成为N的父亲（P）和S的右儿子的父亲。我们接着交换N的父亲和S的颜色，并使S的右儿子为黑色。子树在它的根上的仍是同样的颜色，所以性质3没有被违反。但是，N现在增加了一个黑色祖先: 要么N的父亲变成黑色，要么它是黑色而S被增加为一个黑色祖父。所以，通过N的路径都增加了一个黑色节点。<br>此时，如果一个路径不通过N，则有两种可能性:</p>
<pre><code>* 
</code></pre><p>它通过N的新兄弟。那么它以前和现在都必定通过S和N的父亲，而它们只是交换了颜色。所以路径保持了同样数目的黑色节点。</p>
<pre><code>* 
</code></pre><p>它通过N的新叔父，S的右儿子。那么它以前通过S、S的父亲和S的右儿子，但是现在只通过S，它被假定为它以前的父亲的颜色，和S的右儿子，它被从红色改变为黑色。合成效果是这个路径通过了同样数目的黑色节点。</p>
<p>在任何情况下，在这些路径上的黑色节点数目都没有改变。所以我们恢复了性质4。在示意图中的白色节点可以是红色或黑色，但是在变换前后都必须指定相同的颜色。</p>
<p>红黑树实现源码：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148<br>149<br>150<br>151<br>152<br>153<br>154<br>155<br>156<br>157<br>158<br>159<br>160<br>161<br>162<br>163<br>164<br>165<br>166<br>167<br>168<br>169<br>170<br>171<br>172<br>173<br>174<br>175<br>176<br>177<br>178<br>179<br>180<br>181<br>182<br>183<br>184<br>185<br>186<br>187<br>188<br>189<br>190<br>191<br>192<br>193<br>194<br>195<br>196<br>197<br>198<br>199<br>200<br>201<br>202<br>203<br>204<br>205<br>206<br>207<br>208<br>209<br>210<br>211<br>212<br>213<br>214<br>215<br>216<br>217<br>218<br>219<br>220<br>221<br>222<br>223<br>224<br>225<br>226<br>227<br>228<br>229<br>230<br>231<br>232<br>233<br>234<br>235<br>236<br>237<br>238<br>239<br>240<br>241<br>242<br>243<br>244<br>245<br>246<br>247<br>248<br>249<br>250<br>251<br>252<br>253<br>254<br>255<br>256<br>257<br>258<br>259<br>260<br>261<br>262<br>263<br>264<br>265<br>266<br>267<br>268<br>269<br>270<br>271<br>272<br>273<br>274<br>275<br>276<br>277<br>278<br>279<br>280<br>281<br>282<br>283<br>284<br>285<br>286<br>287<br>288<br>289<br>290<br>291<br>292<br>293<br>294<br>295<br>296<br>297<br>298<br>299<br>300<br>301<br>302<br>303<br>304<br>305<br>306<br>307<br>308<br>309<br>310<br>311<br>312<br>313<br>314<br>315<br>316<br>317<br>318<br>319<br>320<br>321<br>322<br>323<br>324<br>325<br>326<br>327<br>328<br>329<br>330<br>331<br>332<br>333</p>
<p>#define BLACK 1</p>
<p>#define RED 0</p>
<p>using namespace std;</p>
<p>class bst {<br>private:</p>
<pre><code>struct Node {
    int value;
    bool color;
    Node *leftTree, *rightTree, *parent;

    Node() {
        color = RED;
        leftTree = NULL;
        rightTree = NULL;
        parent = NULL;
        value = 0;
    }

    Node* grandparent() {
        if (parent == NULL) {
            return NULL;
        }
        return parent-&gt;parent;
    }

    Node* uncle() {
        if (grandparent() == NULL) {
            return NULL;
        }
        if (parent == grandparent()-&gt;rightTree)
            return grandparent()-&gt;leftTree;
        else
            return grandparent()-&gt;rightTree;
    }

    Node* sibling() {
        if (parent-&gt;leftTree == this)
            return parent-&gt;rightTree;
        else
            return parent-&gt;leftTree;
    }
};

void rotate_right(Node *p) {
    Node *gp = p-&gt;grandparent();
    Node *fa = p-&gt;parent;
    Node *y = p-&gt;rightTree;

    fa-&gt;leftTree = y;

    if (y != NIL)
        y-&gt;parent = fa;
    p-&gt;rightTree = fa;
    fa-&gt;parent = p;

    if (root == fa)
        root = p;
    p-&gt;parent = gp;

    if (gp != NULL) {
        if (gp-&gt;leftTree == fa)
            gp-&gt;leftTree = p;
        else
            gp-&gt;rightTree = p;
    }

}

void rotate_left(Node *p) {
    if (p-&gt;parent == NULL) {
        root = p;
        return;
    }
    Node *gp = p-&gt;grandparent();
    Node *fa = p-&gt;parent;
    Node *y = p-&gt;leftTree;

    fa-&gt;rightTree = y;

    if (y != NIL)
        y-&gt;parent = fa;
    p-&gt;leftTree = fa;
    fa-&gt;parent = p;

    if (root == fa)
        root = p;
    p-&gt;parent = gp;

    if (gp != NULL) {
        if (gp-&gt;leftTree == fa)
            gp-&gt;leftTree = p;
        else
            gp-&gt;rightTree = p;
    }
}

void inorder(Node *p) {
    if (p == NIL)
        return;

    if (p-&gt;leftTree)
        inorder(p-&gt;leftTree);

    cout &lt;&lt; p-&gt;value &lt;&lt; &quot; &quot;;

    if (p-&gt;rightTree)
        inorder(p-&gt;rightTree);
}

string outputColor(bool color) {
    return color ? &quot;BLACK&quot; : &quot;RED&quot;;
}

Node* getSmallestChild(Node *p) {
    if (p-&gt;leftTree == NIL)
        return p;
    return getSmallestChild(p-&gt;leftTree);
}

bool delete_child(Node *p, int data) {
    if (p-&gt;value &gt; data) {
        if (p-&gt;leftTree == NIL) {
            return false;
        }
        return delete_child(p-&gt;leftTree, data);
    } else if (p-&gt;value &lt; data) {
        if (p-&gt;rightTree == NIL) {
            return false;
        }
        return delete_child(p-&gt;rightTree, data);
    } else if (p-&gt;value == data) {
        if (p-&gt;rightTree == NIL) {
            delete_one_child(p);
            return true;
        }
        Node *smallest = getSmallestChild(p-&gt;rightTree);
        swap(p-&gt;value, smallest-&gt;value);
        delete_one_child(smallest);

        return true;
    }
}

void delete_one_child(Node *p) {
    Node *child = p-&gt;leftTree == NIL ? p-&gt;rightTree : p-&gt;leftTree;
    if (p-&gt;parent == NULL &amp;&amp; p-&gt;leftTree == NIL &amp;&amp; p-&gt;rightTree == NIL) {
        p = NULL;
        root = p;
        return;
    }

    if (p-&gt;parent == NULL) {
        delete  p;
        child-&gt;parent = NULL;
        root = child;
        root-&gt;color = BLACK;
        return;
    }

    if (p-&gt;parent-&gt;leftTree == p) {
        p-&gt;parent-&gt;leftTree = child;
    } else {
        p-&gt;parent-&gt;rightTree = child;
    }
    child-&gt;parent = p-&gt;parent;

    if (p-&gt;color == BLACK) {
        if (child-&gt;color == RED) {
            child-&gt;color = BLACK;
        } else
            delete_case(child);
    }

    delete p;
}

void delete_case(Node *p) {
    if (p-&gt;parent == NULL) {
        p-&gt;color = BLACK;
        return;
    }
    if (p-&gt;sibling()-&gt;color == RED) {
        p-&gt;parent-&gt;color = RED;
        p-&gt;sibling()-&gt;color = BLACK;
        if (p == p-&gt;parent-&gt;leftTree)
            rotate_left(p-&gt;sibling());
        else
            rotate_right(p-&gt;sibling());
    }
    if (p-&gt;parent-&gt;color == BLACK &amp;&amp; p-&gt;sibling()-&gt;color == BLACK
            &amp;&amp; p-&gt;sibling()-&gt;leftTree-&gt;color == BLACK &amp;&amp; p-&gt;sibling()-&gt;rightTree-&gt;color == BLACK) {
        p-&gt;sibling()-&gt;color = RED;
        delete_case(p-&gt;parent);
    } else if (p-&gt;parent-&gt;color == RED &amp;&amp; p-&gt;sibling()-&gt;color == BLACK
            &amp;&amp; p-&gt;sibling()-&gt;leftTree-&gt;color == BLACK &amp;&amp; p-&gt;sibling()-&gt;rightTree-&gt;color == BLACK) {
        p-&gt;sibling()-&gt;color = RED;
        p-&gt;parent-&gt;color = BLACK;
    } else {
        if (p-&gt;sibling()-&gt;color == BLACK) {
            if (p == p-&gt;parent-&gt;leftTree &amp;&amp; p-&gt;sibling()-&gt;leftTree-&gt;color == RED
                    &amp;&amp; p-&gt;sibling()-&gt;rightTree-&gt;color == BLACK) {
                p-&gt;sibling()-&gt;color = RED;
                p-&gt;sibling()-&gt;leftTree-&gt;color = BLACK;
                rotate_right(p-&gt;sibling()-&gt;leftTree);
            } else if (p == p-&gt;parent-&gt;rightTree &amp;&amp; p-&gt;sibling()-&gt;leftTree-&gt;color == BLACK
                    &amp;&amp; p-&gt;sibling()-&gt;rightTree-&gt;color == RED) {
                p-&gt;sibling()-&gt;color = RED;
                p-&gt;sibling()-&gt;rightTree-&gt;color = BLACK;
                rotate_left(p-&gt;sibling()-&gt;rightTree);
            }
        }
        p-&gt;sibling()-&gt;color = p-&gt;parent-&gt;color;
        p-&gt;parent-&gt;color = BLACK;
        if (p == p-&gt;parent-&gt;leftTree) {
            p-&gt;sibling()-&gt;rightTree-&gt;color = BLACK;
            rotate_left(p-&gt;sibling());
        } else {
            p-&gt;sibling()-&gt;leftTree-&gt;color = BLACK;
            rotate_right(p-&gt;sibling());
        }
    }
}

void insert(Node *p, int data) {
    if (p-&gt;value &gt;= data) {
        if (p-&gt;leftTree != NIL)
            insert(p-&gt;leftTree, data);
        else {
            Node *tmp = new Node();
            tmp-&gt;value = data;
            tmp-&gt;leftTree = tmp-&gt;rightTree = NIL;
            tmp-&gt;parent = p;
            p-&gt;leftTree = tmp;
            insert_case(tmp);
        }
    } else {
        if (p-&gt;rightTree != NIL)
            insert(p-&gt;rightTree, data);
        else {
            Node *tmp = new Node();
            tmp-&gt;value = data;
            tmp-&gt;leftTree = tmp-&gt;rightTree = NIL;
            tmp-&gt;parent = p;
            p-&gt;rightTree = tmp;
            insert_case(tmp);
        }
    }
}

void insert_case(Node *p) {
    if (p-&gt;parent == NULL) {
        root = p;
        p-&gt;color = BLACK;
        return;
    }
    if (p-&gt;parent-&gt;color == RED) {
        if (p-&gt;uncle()-&gt;color == RED) {
            p-&gt;parent-&gt;color = p-&gt;uncle()-&gt;color = BLACK;
            p-&gt;grandparent()-&gt;color = RED;
            insert_case(p-&gt;grandparent());
        } else {
            if (p-&gt;parent-&gt;rightTree == p &amp;&amp; p-&gt;grandparent()-&gt;leftTree == p-&gt;parent) {
                rotate_left(p);
                rotate_right(p);
                p-&gt;color = BLACK;
                p-&gt;leftTree-&gt;color = p-&gt;rightTree-&gt;color = RED;
            } else if (p-&gt;parent-&gt;leftTree == p &amp;&amp; p-&gt;grandparent()-&gt;rightTree == p-&gt;parent) {
                rotate_right(p);
                rotate_left(p);
                p-&gt;color = BLACK;
                p-&gt;leftTree-&gt;color = p-&gt;rightTree-&gt;color = RED;
            } else if (p-&gt;parent-&gt;leftTree == p &amp;&amp; p-&gt;grandparent()-&gt;leftTree == p-&gt;parent) {
                p-&gt;parent-&gt;color = BLACK;
                p-&gt;grandparent()-&gt;color = RED;
                rotate_right(p-&gt;parent);
            } else if (p-&gt;parent-&gt;rightTree == p &amp;&amp; p-&gt;grandparent()-&gt;rightTree == p-&gt;parent) {
                p-&gt;parent-&gt;color = BLACK;
                p-&gt;grandparent()-&gt;color = RED;
                rotate_left(p-&gt;parent);
            }
        }
    }
}

void DeleteTree(Node *p) {
    if (!p || p == NIL) {
        return;
    }
    DeleteTree(p-&gt;leftTree);
    DeleteTree(p-&gt;rightTree);
    delete p;
}
</code></pre><p>public:</p>
<pre><code>bst() {
    NIL = new Node();
    NIL-&gt;color = BLACK;
    root = NULL;
}

~bst() {
    if (root)
        DeleteTree(root);
    delete NIL;
}

void inorder() {
    if (root == NULL)
        return;
    inorder(root);
    cout &lt;&lt; endl;
}

void insert(int x) {
    if (root == NULL) {
        root = new Node();
        root-&gt;color = BLACK;
        root-&gt;leftTree = root-&gt;rightTree = NIL;
        root-&gt;value = x;
    } else {
        insert(root, x);
    }
}

bool delete_value(int data) {
    return delete_child(root, data);
}
</code></pre><p>private:<br>    Node <em>root, </em>NIL;<br>};</p>
<ol start="4">
<li>B树<br>B树也是一种用于查找的平衡树，但是它不是二叉树。<br>B树的定义：B树（B-tree）是一种树状数据结构，能够用来存储排序后的数据。这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树，可以拥有多于2个子节点。与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。这种数据结构常被应用在数据库和文件系统的实作上。<br>在B树中查找给定关键字的方法是，首先把根结点取来，在根结点所包含的关键字K1,…,Kn查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查找的关键字在Ki与Ki+1之间，Pi为指向子树根节点的指针，此时取指针Pi所指的结点继续查找，直至找到，或指针Pi为空时查找失败。<br>B树作为一种多路搜索树（并不是二叉的）：<br>1) 定义任意非叶子结点最多只有M个儿子；且M&gt;2；<br>2) 根结点的儿子数为[2, M]；<br>3) 除根结点以外的非叶子结点的儿子数为[M/2, M]；<br>4) 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）<br>5) 非叶子结点的关键字个数=指向儿子的指针个数-1；<br>6) 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；<br>7) 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；<br>8) 所有叶子结点位于同一层；<br>如下图为一个M=3的B树示例：</li>
</ol>
<p>B树创建的示意图：</p>
<ol start="5">
<li>B+树<br>B+树是B树的变体，也是一种多路搜索树：<br>1) 其定义基本与B-树相同，除了：<br>2) 非叶子结点的子树指针与关键字个数相同；<br>3) 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；<br>4) 为所有叶子结点增加一个链指针；<br>5) 所有关键字都在叶子结点出现；<br>下图为M=3的B+树的示意图：</li>
</ol>
<p>B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；<br>B+的性质：<br>1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；<br>2.不可能在非叶子结点命中；<br>3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；<br>4.更适合文件索引系统。<br>下面为一个B+树创建的示意图：</p>
<ol start="6">
<li>B<em>树<br>B</em>树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针，将结点的最低利用率从1/2提高到2/3。<br>B*树如下图所示：</li>
</ol>
<p>B<em>树定义了非叶子结点关键字个数至少为(2/3)</em>M，即块的最低使用率为2/3（代替B+树的1/2）；<br>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；<br>B<em>树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；<br>所以，B</em>树分配新结点的概率比B+树要低，空间使用率更高。7. Trie树<br>Tire树称为字典树，又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。<br>Tire树的三个基本性质：<br>1) 根节点不包含字符，除根节点外每一个节点都只包含一个字符；<br>2) 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；<br>3) 每个节点的所有子节点包含的字符都不相同。<br>Tire树的应用：<br>1) 串的快速检索<br>给出N个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。在这道题中，我们可以用数组枚举，用哈希，用字典树，先把熟词建一棵树，然后读入文章进行比较，这种方法效率是比较高的。<br>2) “串”排序<br>给定N个互不相同的仅由一个单词构成的英文名，让你将他们按字典序从小到大输出。用字典树进行排序，采用数组的方式创建字典树，这棵树的每个结点的所有儿子很显然地按照其字母大小排序。对这棵树进行先序遍历即可。<br>3) 最长公共前缀<br>对所有串建立字典树，对于两个串的最长公共前缀的长度即他们所在的结点的公共祖先个数，于是，问题就转化为求公共祖先的问题。<br> 1 赞  12 收藏  3 评论</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wadezhx.github.io/2018/12/06/数据结构中各种树/" data-id="cjpc0m9pt000lgorqh4w4m2g9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-经典排序算法总结与实现" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/经典排序算法总结与实现/" class="article-date">
  <time datetime="2018-12-06T02:46:37.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/经典排序算法总结与实现/">经典排序算法总结与实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="经典排序算法总结与实现"><a href="#经典排序算法总结与实现" class="headerlink" title="经典排序算法总结与实现"></a>经典排序算法总结与实现</h1><p>by WuChong, wuchong.me</p>
<p>经典排序算法在面试中占有很大的比重，也是基础，为了未雨绸缪，在寒假里整理并用Python实现了七大经典排序算法，包括冒泡排序，插入排序，选择排序，希尔排序，归并排序，快速排序，堆排序。希望能帮助到有需要的同学。之所以用Python实现，主要是因为它更接近伪代码，能用更少的代码实现算法，更利于理解。<br>本篇博客所有排序实现均默认从小到大。一、冒泡排序 BubbleSort<br>介绍：<br>冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。<br>步骤：</p>
<pre><code>1. 
</code></pre><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
<pre><code>2. 
</code></pre><p>对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。</p>
<pre><code>3. 
</code></pre><p>针对所有的元素重复以上的步骤，除了最后一个。</p>
<pre><code>4. 
</code></pre><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<p>源代码：(python实现)</p>
<p>def bubble_sort(arry):<br>n = len(arry) #获得数组的长度<br>for i in range(n):<br>for j in range(1,n-i):<br>if arry[j-1] &gt; arry[j] : #如果前者比后者大<br>arry[j-1],arry[j] = arry[j],arry[j-1] #则交换两者<br>return arry<br>不过针对上述代码还有两种优化方案。</p>
<p>优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。用一个标记记录这个状态即可。<br>优化2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。<br>这两种优化方案的实现可以详见这里。二、选择排序 SelectionSort<br>介绍：<br>选择排序无疑是最简单直观的排序。它的工作原理如下。<br>步骤：</p>
<pre><code>1. 
</code></pre><p>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p>
<pre><code>2. 
</code></pre><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>
<pre><code>3. 
</code></pre><p>以此类推，直到所有元素均排序完毕。</p>
<p>源代码：(python实现)</p>
<p>def select_sort(ary):<br>n = len(ary)<br>for i in range(0,n):<br>min = i #最小元素下标标记<br>for j in range(i+1,n):<br>if ary[j] &lt; ary[min] :<br>min = j #找到最小值的下标<br>ary[min],ary[i] = ary[i],ary[min] #交换两者<br>return ary三、插入排序 InsertionSort<br>介绍：<br>插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br>步骤：</p>
<pre><code>1. 
</code></pre><p>从第一个元素开始，该元素可以认为已经被排序</p>
<pre><code>2. 
</code></pre><p>取出下一个元素，在已经排序的元素序列中从后向前扫描</p>
<pre><code>3. 
</code></pre><p>如果被扫描的元素（已排序）大于新元素，将该元素后移一位</p>
<pre><code>4. 
</code></pre><p>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</p>
<pre><code>5. 
</code></pre><p>将新元素插入到该位置后</p>
<pre><code>6. 
</code></pre><p>重复步骤2~5</p>
<p>排序演示：</p>
<p>源代码：(python实现)四、希尔排序 ShellSort<br>介绍：<br>希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。<br>希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。<br>例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p>
<p>13 14 94 33 82<br>25 59 94 65 23<br>45 27 73 25 39<br>10</p>
<p>然后我们对每列进行排序：</p>
<p>10 14 73 25 23<br>13 27 94 33 39<br>25 59 94 65 82<br>45</p>
<p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]。这时10已经移至正确位置了，然后再以3为步长进行排序：</p>
<p>10 14 73<br>25 23 13<br>27 94 33<br>39 25 59<br>94 65 82<br>45</p>
<p>排序之后变为：</p>
<p>10 14 13<br>25 23 33<br>27 25 59<br>39 65 73<br>45 94 82<br>94</p>
<p>最后以1步长进行排序（此时就是简单的插入排序了）。<br>源代码：(python实现)</p>
<p>def shell_sort(ary):<br>n = len(ary)<br>gap = round(n/2) #初始步长 , 用round四舍五入取整<br>while gap &gt; 0 :<br>for i in range(gap,n): #每一列进行插入排序 , 从gap 到 n-1<br>temp = ary[i]<br>j = i<br>while ( j &gt;= gap and ary[j-gap] &gt; temp ): #插入排序<br>ary[j] = ary[j-gap]<br>j = j - gap<br>ary[j] = temp<br>gap = round(gap/2) #重新设置步长<br>return ary<br>上面源码的步长的选择是从n/2开始，每次再减半，直至为0。步长的选择直接决定了希尔排序的复杂度。在维基百科上有对于步长串行的详细介绍。五、归并排序 MergeSort<br>介绍：<br>归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。<br>先考虑合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。<br>再考虑递归分解，基本思路是将数组分解成left和right，如果这两个数组内部数据是有序的，那么就可以用上面合并数组的方法将这两个数组合并排序。如何让这两个数组内部是有序的？可以再二分，直至分解出的小组只含有一个元素时为止，此时认为该小组内部已有序。然后合并排序相邻二个小组即可。<br>排序演示：<br>源代码：(python实现)</p>
<p>def merge_sort(ary):<br>if len(ary) &lt;= 1 : return ary<br>num = int(len(ary)/2) #二分分解<br>left = merge_sort(ary[:num])<br>right = merge_sort(ary[num:])<br>return merge(left,right) #合并数组def merge(left,right):<br>‘’’合并操作，<br>将两个有序数组left[]和right[]合并成一个大的有序数组’’’<br>l,r = 0,0 #left与right数组的下标指针<br>result = []<br>while l&lt;len(left) and r&lt;len(right) :<br>if left[l] &lt; right[r]:<br>result.append(left[l])<br>l += 1<br>else:<br>result.append(right[r])<br>r += 1<br>result += left[l:]<br>result += right[r:]<br>return result六、快速排序 QuickSort</p>
<p>介绍：<br>快速排序通常明显比同为Ο(n log n)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。<br>步骤：</p>
<pre><code>1. 
</code></pre><p>从数列中挑出一个元素作为基准数。</p>
<pre><code>2. 
</code></pre><p>分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。</p>
<pre><code>3. 
</code></pre><p>再对左右区间递归执行第二步，直至各区间只有一个数。</p>
<p>排序演示：<br>源代码：(python实现)</p>
<p>def quick_sort(ary):<br>return qsort(ary,0,len(ary)-1)def qsort(ary,left,right):</p>
<p>#快排函数，ary为待排序数组，left为待排序的左边界，right为右边界<br>if left &gt;= right : return ary<br>key = ary[left] #取最左边的为基准数<br>lp = left #左指针<br>rp = right #右指针<br>while lp &lt; rp :<br>while ary[rp] &gt;= key and lp &lt; rp :<br>rp -= 1<br>while ary[lp] &lt;= key and lp &lt; rp :<br>lp += 1<br>ary[lp],ary[rp] = ary[rp],ary[lp]<br>ary[left],ary[lp] = ary[lp],ary[left]<br>qsort(ary,left,lp-1)<br>qsort(ary,rp+1,right)<br>return ary七、堆排序 HeapSort<br>介绍：<br>堆排序在 top K 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。二叉堆是一个近似完全二叉树 。<br>二叉堆具有以下性质：</p>
<pre><code>1. 
</code></pre><p>父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。</p>
<pre><code>2. 
</code></pre><p>每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。</p>
<p>步骤：</p>
<pre><code>1. 
</code></pre><p>构造最大堆（Build_Max_Heap）：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆。于是只要从n/2-1开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。</p>
<pre><code>2. 
</code></pre><p>堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[n-1]交换，再对heap[0…n-2]做最大堆调整。第二次将heap[0]与heap[n-2]交换，再对heap[0…n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。</p>
<pre><code>3. 
</code></pre><p>最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点 。</p>
<p>排序演示：<br>源代码：(python实现)</p>
<p>def heap_sort(ary) :<br>n = len(ary)<br>first = int(n/2-1) #最后一个非叶子节点<br>for start in range(first,-1,-1) : #构造大根堆<br>max_heapify(ary,start,n-1)<br>for end in range(n-1,0,-1): #堆排，将大根堆转换成有序数组<br>ary[end],ary[0] = ary[0],ary[end]<br>max_heapify(ary,0,end-1)<br>return ary</p>
<p>#最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点</p>
<p>#start为当前需要调整最大堆的位置，end为调整边界<br>def max_heapify(ary,start,end):<br>root = start<br>while True :<br>child = root*2 +1 #调整节点的子节点<br>if child &gt; end : break child = child+1 #取较大的子节点<br>if ary[root] &lt; ary[child] : #较大的子节点成为父节点<br>ary[root],ary[child] = ary[child],ary[root] #交换<br>root = child<br>else :<br>break总结<br>下面为七种经典排序算法指标对比情况：<br>参考资料<br>注：本文所有源代码已共享到GitHub。<br>-EOF-<br>Original Page: <a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/" target="_blank" rel="noopener">http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wadezhx.github.io/2018/12/06/经典排序算法总结与实现/" data-id="cjpc0m9pm000jgorqdnrz4iwi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java学习第三次笔记" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/05/java学习第三次笔记/" class="article-date">
  <time datetime="2018-12-05T12:28:51.563Z" itemprop="datePublished">2018-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: java学习第三次笔记<br>date: 2018-11-29 20:28:32</p>
<h2 id="tags-java"><a href="#tags-java" class="headerlink" title="tags: java"></a>tags: java</h2><h1 id="wade-zhx"><a href="#wade-zhx" class="headerlink" title="wade.zhx"></a>wade.zhx</h1><h4 id="Java的数据类型可分为两大类："><a href="#Java的数据类型可分为两大类：" class="headerlink" title="Java的数据类型可分为两大类："></a>Java的数据类型可分为两大类：</h4><p><img src="en-resource://database/7196:1" alt="76878d3244bd49c9b4584402f32d1c37.png"></p>
<h5 id="基本数据类型（primitive-data-type）3类8种"><a href="#基本数据类型（primitive-data-type）3类8种" class="headerlink" title="基本数据类型（primitive data type）3类8种"></a>基本数据类型（primitive data type）3类8种</h5><h4 id="1-Byte-8-bits"><a href="#1-Byte-8-bits" class="headerlink" title="1 Byte =8 bits"></a>1 Byte =8 bits</h4><pre><code>数值型－ 
     整数    
</code></pre><table>
<thead>
<tr>
<th>类型</th>
<th>占用存储空间</th>
<th></th>
<th>表数范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>1 字节</td>
<td>2^7</td>
<td>（-128~127）</td>
</tr>
<tr>
<td>short</td>
<td>2 字节</td>
<td>2^15</td>
<td>(-3w—3w)</td>
</tr>
<tr>
<td>int</td>
<td>4 字节</td>
<td>2^31</td>
<td>(-21亿—21亿)</td>
</tr>
<tr>
<td>long</td>
<td>8 字节</td>
<td>2^ 63</td>
<td>非常非常大</td>
</tr>
</tbody>
</table>
<p>默认是 int 后面加L强制转换；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public class TestprimitiveDataType &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[]args)&#123;</span><br><span class="line"></span><br><span class="line">        //测试整形变量</span><br><span class="line"></span><br><span class="line">        int &lt;u&gt;a&lt;/u&gt; = 15;</span><br><span class="line"></span><br><span class="line">        int b = 015;//0开头的是八进制</span><br><span class="line"></span><br><span class="line">        int c = 0x15;//0x开头的是十六进制</span><br><span class="line"></span><br><span class="line">        int d = 0b0001111;//0b开头的都是二进制</span><br><span class="line"></span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        System.out.println(d);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        byte  age  = 30;</span><br><span class="line"></span><br><span class="line">        short  salary  = 30000;</span><br><span class="line"></span><br><span class="line">        int  population = 2100000000;</span><br><span class="line"></span><br><span class="line">        long   globalPopulation = 700000000000000l;</span><br></pre></td></tr></table></figure>
<pre><code>13

21

15
</code></pre><h5 id="引用数据类型（reference-data-type）"><a href="#引用数据类型（reference-data-type）" class="headerlink" title="引用数据类型（reference data type）"></a>引用数据类型（reference data type）</h5>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://wadezhx.github.io/2018/12/05/java学习第三次笔记/" data-id="cjpc0m9oz0004gorq19q3ux3d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java学习第五次笔记" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/05/java学习第五次笔记/" class="article-date">
  <time datetime="2018-12-05T12:28:32.000Z" itemprop="datePublished">2018-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/05/java学习第五次笔记/">java学习第五次笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="wade-zhx"><a href="#wade-zhx" class="headerlink" title="wade.zhx"></a>wade.zhx</h1><h5 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h5><p><img src="en-resource://database/7241:1" alt="6d408ddd2a3f5b00edd918de34fc52fa.png"></p>
<blockquote>
<h5 id="整数运算："><a href="#整数运算：" class="headerlink" title="整数运算：　"></a>整数运算：　</h5><ol>
<li>如果两个操作数有一个为Long, 则结果也为long。　</li>
<li>没有long时，结果为int。即使操作数全为short，byte，结果也是int。　　<h5 id="浮点运算："><a href="#浮点运算：" class="headerlink" title="浮点运算：　　"></a>浮点运算：　　</h5></li>
<li>如果两个操作数有一个为double，则结果为double。　</li>
<li>只有两个操作数都是float，则结果才为float。　　<h5 id="取模运算："><a href="#取模运算：" class="headerlink" title="取模运算：　　"></a>取模运算：　　</h5>1.其操作数可以为浮点数,一般使用整数，结果是“余数”，<br><strong>“余数”符号和左边操作数相同，</strong><br>如：<strong>7%3=1，-7%3=-1，7%-3=1。</strong></li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(-9%5);</span><br><span class="line">    </span><br><span class="line">-4</span><br></pre></td></tr></table></figure>
<p>算术运算符中++，–属于一元运算符，该类运算符只需要一个操作数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        byte &lt;u&gt;a1&lt;/u&gt; = 1;</span><br><span class="line"></span><br><span class="line">        int b1 = 2;</span><br><span class="line"></span><br><span class="line">        // byte c = a+b;</span><br><span class="line"></span><br><span class="line">        long b2 = 3;</span><br><span class="line"></span><br><span class="line">        // &lt;u&gt;int&lt;/u&gt; c2 = b2+b; 因为不接受into &lt;u&gt;int&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        float f1 = 3.14f;</span><br><span class="line"></span><br><span class="line">        double &lt;u&gt;d&lt;/u&gt; = b1+b2;//</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        float &lt;u&gt;f2&lt;/u&gt; = f1+6.2f;//浮点型默认double</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        System.out.println(-9%5);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        //测试自增自减</span><br><span class="line"></span><br><span class="line">        int a = 3;</span><br><span class="line"></span><br><span class="line">        int b = a++;//先赋值后++</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;a=&quot;+a+&quot;\nb=&quot;+b);</span><br><span class="line"></span><br><span class="line">        //a=4</span><br><span class="line"></span><br><span class="line">        //b=3</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">         a = 3;</span><br><span class="line"></span><br><span class="line">         b = ++a; //先++后赋值</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;a=&quot;+a+&quot;\nb=&quot;+b);</span><br><span class="line"></span><br><span class="line">        //a=4</span><br><span class="line"></span><br><span class="line">        //b=4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wadezhx.github.io/2018/12/05/java学习第五次笔记/" data-id="cjpc0m9p30008gorquet9hvbp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-在N个不相等的整数中找出最大的第K个数(NK)" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/04/在N个不相等的整数中找出最大的第K个数(NK)/" class="article-date">
  <time datetime="2018-12-04T02:46:37.000Z" itemprop="datePublished">2018-12-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/04/在N个不相等的整数中找出最大的第K个数(NK)/">在N个不相等的整数中找出最大的第K个数(N&gt;K)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="题目：在N个不相等的整数中找出最大的第K个数-N-gt-K-。"><a href="#题目：在N个不相等的整数中找出最大的第K个数-N-gt-K-。" class="headerlink" title="题目：在N个不相等的整数中找出最大的第K个数(N&gt;K)。"></a>题目：在N个不相等的整数中找出最大的第K个数(N&gt;K)。</h1><p>思路：首先，用前K个整数构造容量为K的最小堆。然后，将后N-K个整数依次与堆顶元素比较，若比堆顶元素大，则替换堆顶元素并调整最小堆结构；反之，则继续比较下一个整数。最终，最小堆存储最大的k个数，其堆顶元素即为所求。<br>代码：</p>
<p>1 #include <cstdio><br>2 #include <cstdlib><br>3 #include <cmath><br>4 #include <ctime><br>5 #include <iostream><br>6<br>7 #define N 90<br>8 #define K 13<br>9<br>10<br>11 void HeapAdjust (int <em>heap, int beginidx, int endidx);<br>12 void HeapConstruct (int </em>heap);<br>13<br>14 void SetData (int <em>data);<br>15 void ShowData (int </em>data);<br>16<br>17 int main (int argc, char *<em>argv)<br>18 {<br>19 int i;<br>20 int h[N + 1];<br>21<br>22 SetData(h);<br>23 ShowData(h);<br>24<br>25 HeapConstruct(h);<br>26 for (i = K + 1; i &lt;= N; i++)<br>27 {<br>28 if (h[i] &gt; h[1])<br>29 {<br>30 h[1] = h[i];<br>31 HeapAdjust(h, 1, K);<br>32 }<br>33 }<br>34<br>35 printf(“The Kth biggest number: %d\n”, h[1]);<br>36 return 0;<br>37 }<br>38<br>39 void HeapAdjust (int </em>heap, int beginidx, int endidx)<br>40 {<br>41 int &amp;current = beginidx;<br>42 int tmp, left, right, data = heap[current];<br>43<br>44 while (left = (current &lt;&lt; 1), left &lt;= endidx)<br>45 {<br>46 right = left | 1;<br>47 if ((left == endidx) || (heap[left] &lt; heap[right]))<br>48 {<br>49 tmp = left;<br>50 }<br>51 else<br>52 {<br>53 tmp = right;<br>54 }<br>55 if (data &gt; heap[tmp])<br>56 {<br>57 heap[current] = heap[tmp];<br>58 current = tmp;<br>59 }<br>60 else<br>61 {<br>62 break;<br>63 }<br>64 }<br>65 heap[current] = data;<br>66 }<br>67<br>68 void HeapConstruct (int <em>heap)<br>69 {<br>70 int i;<br>71 for (i = K/2; i &gt; 0; i–)<br>72 {<br>73 HeapAdjust(heap, i, K);<br>74 }<br>75 }<br>76<br>77 void SetData (int </em>data)<br>78 {<br>79 bool <em>bdata = new bool[N + 1];<br>80 memset(bdata, false, N + 1);<br>81 srand(time(NULL));<br>82 data[0] = -1;<br>83 for (int i = 1; i &lt;= N; i++)<br>84 {<br>85 data[i] = rand() % N + 1;<br>86 while (bdata[data[i]])<br>87 {<br>88 data[i] = rand() % N + 1;<br>89 }<br>90 bdata[data[i]] = true;<br>91 }<br>92 delete []bdata;<br>93 }<br>94<br>95 void ShowData (int </em>data)<br>96 {<br>97 for (int i = 1; i &lt;= N; i++)<br>98 {<br>99 printf(“%02d “, data[i]);<br>100 }<br>101 puts(“”);<br>102 }</iostream></ctime></cmath></cstdlib></cstdio></p>
<p>时间复杂度：O((N-K+1)<em>K</em>lgK).</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wadezhx.github.io/2018/12/04/在N个不相等的整数中找出最大的第K个数(NK)/" data-id="cjpc0m9p7000cgorqcdv08qnu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Web Service" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/04/Web Service/" class="article-date">
  <time datetime="2018-12-04T02:23:45.000Z" itemprop="datePublished">2018-12-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/04/Web Service/">Web Service</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、环境配置：MyEclipse7.0<br>JDK1.6<br>二、创建Web Service Project<br>1）在MyEclipse中选择File—&gt;New—&gt;Other，选择Web Service Project</p>
<p>2）Project Name：WebServiceServer，Framework：XFire，其他选项默认</p>
<p>3）Next，这一步保持默认值<br>4）Project Library选择，选择XFire 1.2 Core Libraries</p>
<p>5）Finish，创建成功后看到的工程目录如下：</p>
<p>6）完成以上5步后，查看WebRoot/WEB-INF/web.xml</p>
<p>这里指明了当遇到/services/*请求时，将选用XFireConfigurableServlet来处理  </p>
<p>三、创建Web Service Code<br>1）通过File—&gt;New—&gt;Other—&gt;Web Services—&gt;Web Service wizard创建JAVA CODE</p>
<p>2）选择通过JAVA CLASS创建Web Service</p>
<p>3）创建HelloWebService.java，通过New创建com.service package，向导将为工程自动创建对应的接口类与实现类</p>
<p>创建成功后查看WebServices/services.xml，发现配置文件多了以下内容：</p>
<p>4）修改HelloWebServiceImpl.java<br>package com.service;<br>//Generated by meteorWJ</p>
<p>public class HelloWebServiceImpl implements IHelloWebService {</p>
<p>public String example(String message) {<br>return getAuthor()+”,”+message;<br>}<br>private String getAuthor(){<br>return “meteorWJ”;<br>}</p>
<p>}</p>
<p>四、部署并测试WebSericeServer</p>
<p>1）部署WebServiceServer</p>
<p>在部署向导中选择项目、服务器</p>
<p>2）启动服务器</p>
<p>3）测试WebService<br>MyEclipse提供了一个Web Service Explorer来测试Web Service</p>
<p>选择列表中的Launch SOAP Web Services Explorer<br>4）选择WSDL模式</p>
<p>5）在Explorer中选择WSDL Main，在右边的URL中输入<br><a href="http://localhost:9090/WebServiceServer/services/HelloWebService?WSDL，单击&quot;Go&quot;" target="_blank" rel="noopener">http://localhost:9090/WebServiceServer/services/HelloWebService?WSDL，单击&quot;Go&quot;</a><br>其中9090是服务器端口号，services在之前的web.xml中指定<br>若在Status中显示成功打开WSDL文件则测试成功</p>
<p>五、创建WebService客户端<br>经过以上几步，我们已经成功发布了一个WebService，现在需要创建一个客户端来调用该服务<br>1）创建Java Project：WebServiceClient<br>2）引入MyEclipse Libraries<br>右键WebServiceClient—&gt;Build Path—&gt;Add Libraries</p>
<p>选择XFire 1.2 HTTP Client Libraries</p>
<p>3）创建HelloWebService.java<br>在src目录下创建com.client.HelloWebService.java<br>package com.client;</p>
<p>import java.net.URL;<br>import org.codehaus.xfire.client.Client;</p>
<p>public class HelloWebService {<br>public static void main(String[] args) throws Exception<br>{<br>Client client = new Client(new URL(“<a href="http://localhost:9090/WebServiceServer/services/HelloWebService?wsdl&quot;))" target="_blank" rel="noopener">http://localhost:9090/WebServiceServer/services/HelloWebService?wsdl&quot;))</a>;<br>Object[] results = client.invoke(“example”, new Object[] {“hello”});<br>System.out.println((String) results[0]);<br>}<br>}</p>
<p>4）在确认服务器启动的情况下，运行HelloWebService.java<br>右键点击Run As&gt;Java Application，在控制台中看到如下输出</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wadezhx.github.io/2018/12/04/Web Service/" data-id="cjpc0m9oo0000gorqzf88m1ga" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web-Service/">Web Service</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-取石子游戏算法" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/03/取石子游戏算法/" class="article-date">
  <time datetime="2018-12-03T02:48:13.000Z" itemprop="datePublished">2018-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/03/取石子游戏算法/">取石子游戏算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>取石子游戏是一个古老的博弈游戏，据说是发源于中国，它是组合数学领域的一个经典问题。它有许多不同的玩法，基本上是两个玩家，玩的形式是轮流抓石子，胜利的标准是抓走了最后的石子。
</code></pre><p>玩家设定： 先取石子的是玩家A，后取石子的是玩家B。<br>经典的三种玩法：<br>一、Bash Game，有1堆含n个石子，两个人轮流从这堆物品中取物，规定每次至少取1个，最多取m个。取走最后石子的人获胜。<br>二、Nimm Game，有k堆各n个石子，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限。取走最后石子的人获胜。<br>三、Wythoff Game，有2堆各n个石子，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取1个，多者不限。取走最后石子的人获胜。<br>平衡状态的概念：<br>    引入一个概念，平衡状态，又称作奇异局势。当面对这个局势时则会失败。任意非平衡态经过一次操作可以变为平衡态。每个玩家都会努力使自己抓完石子之后的局势为平衡，将这个平衡局势留给对方。因此，玩家A能够在初始为非平衡的游戏中取胜，玩家B能够在初始为平衡的游戏中取胜。<br>玩法一（1堆n个石子每次最多取m个）：<br>    最后一个奇异局势是n=(0)。一种奇异局势是，n=(m+1)，那么无论我取走多少个，对方都能够一次取走剩余所有的物品取胜。<br>奇异局势的判定：<br>    一般的奇异局势是n=(m+1)<em>i，其中i为自然数，即n%(m+1)=0，面对这种情况无论我怎么取，对方总可以将其恢复为n%(m+1)=0，一直到n=(m+1)局势。<br>玩家的策略：<br>    就是把当前面对的非奇异局势变为奇异局势留给对方。如果当前的石子个数为(m+1)</em>i+s，那么就将s个石子取走，使其达到奇异局势。<br>玩法二（k堆石子每次只从1堆取）：<br>    最后一个奇异局势是(0,0…,0)。另一个奇异局势是(n,n,0…0)，只要对手总是和我拿走一样多的物品，最后会面对(0,0…,0)。<br>奇异局势的判定：<br>    对于一个普通的局势，如何判断其是不是奇异局势？对于一个局势(s1,s2,…sk)，对所有石子个数做位的异或运算，s1^s2^s3^…^sk，如果结果为0，那么局势(s1,s2,…sk)就是奇异局势（平衡），否则就不是（非平衡）。<br>    从二进制位的角度上说，奇异局势时，每一个bit位上1的个数都是偶数。<br>玩家的策略：<br>    就是把面对的非奇异局势变为奇异局势留给对方。也就是从某一堆取出若干石子之后，使得每一个bit位上1的个数都变为偶数，这样的取法一般不只有一种。可以将其中一堆的石子数变为其他堆石子数的位异或运算的值（如果这个值比原来的石子数小的话）。<br>玩法三（2堆石子每次从一或两堆取一样数目的石子）：<br>    最后一个奇异局势是(0,0)。紧接着的奇异局势有(1,2),(3,5),(4,7),(6,10)……<br>    现在把它们看成一个奇异局势组成的序列(0,0),(1,2),(3,5),(4,7),(6,10)……<br>奇异局势的判定：<br>    我们会发现这个序列的规律，设序列第k个奇异局势元素为(Ak,Bk)，k为自然数。那么，初始条件k=0时是，A0=B0=0，递推关系为下一个奇异局势的Ak是未在前面出现过的最小自然数，且Ak = Bk + k。<br>    上面发现了奇异局势的递推公式，那么给出一个局势，如何判断其是否是奇异局势呢？<br>黄金分割数：数学真奇妙，竟然发现，这个序列跟黄金分割数有关系。黄金分割数是2/(1+sqrt(5))=(sqrt(5)-1)/2，其小数约等于0.61803398875，其倒数是(1+sqrt(5))/2，约等于1.61803398875。<br>    这个奇异局势的序列的通项公式可以表示为：<br>  Ak = [k*(1+sqrt(5.0)/2]<br>  Bk = Ak + k<br>  其中k=0，1，2，…,n ，方括号表示int取整函数。<br>    有了这个通项式子，逆向的，对于某一个局势，只需要判断其A是否是黄金分割数的某个k的倍数，然后再确认B是否等于A+k即可。<br>这里写了一个简单的判断程序：</p>
<p>[cpp] view plain<br>copy</p>
<pre><code>1. 
</code></pre><p>#include<cmath>  </cmath></p>
<pre><code>2. 
</code></pre><p>#include<iostream>  </iostream></p>
<pre><code>3. 
</code></pre><p>using namespace std;  </p>
<pre><code>4. 
</code></pre><p>const double m = (1+sqrt(5.0))/2;  </p>
<pre><code>5. 

6. 
</code></pre><p>void display()  </p>
<pre><code>7. 
</code></pre><p>{  </p>
<pre><code>8. 
int i;  
9. 
int out;  
10. 
for(i=0;i&lt;30;i++)  
11. 
{  
12. 
    out = int(m*i);  
13. 
    cout&lt;&lt;&quot;(&quot;&lt;&lt;out&lt;&lt;&quot;, &quot;&lt;&lt;out+i&lt;&lt;&quot;)&quot;&lt;&lt;endl;  
14. 
}  
15. 
</code></pre><p>}  </p>
<pre><code>16. 

17. 
</code></pre><p>bool judge(int a, int b)  </p>
<pre><code>18. 
</code></pre><p>{  </p>
<pre><code>19. 
int k = a/m;  
20. 

21. 
if ( a == int(k*m) )  
22. 
{  
23. 
    if( b == a + k )  
24. 
        return true;  
25. 
}  
26. 
else if( a == int((k+1)*m) )  
27. 
{  
28. 
    if( b == a + k + 1 )  
29. 
        return true;  
30. 
}  
31. 
return false;  
32. 
</code></pre><p>}  </p>
<pre><code>33. 

34. 
</code></pre><p>void main()  </p>
<pre><code>35. 
</code></pre><p>{  </p>
<pre><code>36. 
int a,b;  
37. 
cin&gt;&gt;a&gt;&gt;b;  
38. 
cout&lt;&lt;judge(a,b)&lt;&lt;endl;  
39. 
</code></pre><p>}  </p>
<p>玩家的策略：<br>    就是把面对的非奇异局势变为奇异局势留给对方。也就是说，玩家必须知道临近的奇异局势是什么，然后把当前局势变成奇异局势。</p>
<p>问题出现在：编程之美。组合数学。<br>游戏的一个变种：两个人轮流报数，每次至少报一个，最多报十个，谁能报到100者胜。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wadezhx.github.io/2018/12/03/取石子游戏算法/" data-id="cjpc0m9p40009gorq3zhdmp9y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java学习第四次笔记" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/02/java学习第四次笔记/" class="article-date">
  <time datetime="2018-12-02T12:28:32.000Z" itemprop="datePublished">2018-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/02/java学习第四次笔记/">java学习第四次笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="java学习第四次笔记"><a href="#java学习第四次笔记" class="headerlink" title="java学习第四次笔记"></a>java学习第四次笔记</h1><p>  小数    浮点数 // 不精确<br>| 类型 |  占用存储空间|  |表数范围  |<br>| — | — | — | — |<br>|   float 单精度| 4 字节  || -3.403e38—3.403e38 |<br>|double 双精度| 8 字节 |   |  -1.7989e308—1.798e308 |     </p>
<p> 科学计数法  3.14e2; 314e-2<br> 默认是double ，后面加f 强制转换；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">import java.math.*;</span><br><span class="line"></span><br><span class="line">public class TestprimitiveDataType &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[]args)&#123;</span><br><span class="line"></span><br><span class="line">        //测试浮点型变量</span><br><span class="line"></span><br><span class="line">    float &lt;u&gt;a&lt;/u&gt; = 3.14f;//默认是double，放不进去，加f转换</span><br><span class="line"></span><br><span class="line">    double b =6.28;</span><br><span class="line"></span><br><span class="line">    double c = 628e-2;</span><br><span class="line"></span><br><span class="line">    System.out.println(b);</span><br><span class="line"></span><br><span class="line">    System.out.println(c);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    //浮点数不精确，不可以比较；</span><br><span class="line"></span><br><span class="line">    float f = 0.1f;</span><br><span class="line"></span><br><span class="line">    double d = 1/10;</span><br><span class="line"></span><br><span class="line">    System.out.println(f==d);//false</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    float d1 = 1246235867;</span><br><span class="line"></span><br><span class="line">    float d2 = d1+1;</span><br><span class="line"></span><br><span class="line">    if(d1==d2)&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;d1==d2&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;d1!=d2&quot;);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;//精度不够</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;#####&quot;);//使用精确用&lt;u&gt;bigdecimal&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    BigDecimal bd = BigDecimal.valueOf(1.0);</span><br><span class="line"></span><br><span class="line">    bd = bd.subtract(BigDecimal.valueOf(0.1));</span><br><span class="line"></span><br><span class="line">    bd = bd.subtract(BigDecimal.valueOf(0.1));</span><br><span class="line"></span><br><span class="line">    bd = bd.subtract(BigDecimal.valueOf(0.1));</span><br><span class="line"></span><br><span class="line">    bd = bd.subtract(BigDecimal.valueOf(0.1));</span><br><span class="line"></span><br><span class="line">    bd = bd.subtract(BigDecimal.valueOf(0.1));</span><br><span class="line"></span><br><span class="line">    System.out.println(bd);//0.5</span><br><span class="line"></span><br><span class="line">    System.out.println(1.0-0.1-0.1-0.1-0.1-0.1);//0.5000000000000001</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    BigDecimal bd2 = BigDecimal.valueOf(0.1);</span><br><span class="line"></span><br><span class="line">    BigDecimal bd3 = </span><br><span class="line">BigDecimal.valueOf(1.0/10.0);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    System.out.println(bd2.equals(bd3));//true</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="java-math包下面的两个有用的类：BigInteger和-BigDecimal，这两个类可以处理任意长度的数值。BigInteger实现了任意精度的整数运算。BigDecimal实现了任意精度的浮点运算。"><a href="#java-math包下面的两个有用的类：BigInteger和-BigDecimal，这两个类可以处理任意长度的数值。BigInteger实现了任意精度的整数运算。BigDecimal实现了任意精度的浮点运算。" class="headerlink" title="java.math包下面的两个有用的类：BigInteger和 BigDecimal，这两个类可以处理任意长度的数值。BigInteger实现了任意精度的整数运算。BigDecimal实现了任意精度的浮点运算。"></a>java.math包下面的两个有用的类：<u>BigInteger</u>和 <u>BigDecimal</u>，这两个类可以处理任意长度的数值。BigInteger实现了任意精度的整数运算。BigDecimal实现了任意精度的浮点运算。</h6><table>
<thead>
<tr>
<th>类型</th>
<th>占用存储空间</th>
<th></th>
<th>表数范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符型</td>
<td>char</td>
<td>2字节</td>
<td>‘a’</td>
</tr>
<tr>
<td>布尔型</td>
<td>boolean</td>
<td>1位</td>
<td>即0或1  bit</td>
</tr>
</tbody>
</table>
<p>字符 unicode  十六进制 0000—FFFF<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Testzifu3 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">    char &lt;u&gt;a&lt;/u&gt; = &apos;z&apos;;</span><br><span class="line"></span><br><span class="line">    char &lt;u&gt;b&lt;/u&gt; = &apos;张&apos;;</span><br><span class="line"></span><br><span class="line">    char c = &apos;\u0061&apos;;</span><br><span class="line"></span><br><span class="line">    System.out.println(c);//a </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    String d = &quot;asdasdf&quot;;//&quot;字符串&quot;；</span><br><span class="line"></span><br><span class="line">    System.out.println(d );</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>\n  换行<br>\t  制表符 tab</p>
<p>转义符|含义|Unicode值|<br>|—|—|—|<br>|\b|退格（backspace）|\u0008|<br>|\n|换行|\u000a|<br>|\r|回车|\u000d|<br>|\t|制表符（tab）|\u0009|<br>|\“|双引号|\u0022|<br>|\ ‘ |单引号|\u0027|<br>| \\ |反斜杠|\u005c|</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class boolean2 &#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		</span><br><span class="line">	boolean man = true;</span><br><span class="line">	 if(man)//不推荐man==true</span><br><span class="line">	 &#123;</span><br><span class="line">		 System.out.println(&quot;男性&quot;);</span><br><span class="line">		</span><br><span class="line">		 </span><br><span class="line">	 &#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://wadezhx.github.io/2018/12/02/java学习第四次笔记/" data-id="cjpc0m9p10005gorq9bdrcy0u" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java学习第二次笔记" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/28/java学习第二次笔记/" class="article-date">
  <time datetime="2018-11-28T12:28:32.000Z" itemprop="datePublished">2018-11-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/28/java学习第二次笔记/">java学习第二次笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="wade-zhx"><a href="#wade-zhx" class="headerlink" title="wade.zhx"></a>wade.zhx</h1><h5 id="局部变量-local-variable-从属于方法"><a href="#局部变量-local-variable-从属于方法" class="headerlink" title="局部变量(local  variable)   从属于方法"></a>局部变量(local  variable)   从属于方法</h5><pre><code>        {  
         方法或语句块内部定义的变量。生命周期是从声明位置开始到到方法或语句块执行完毕为止。局部变量在使用前必须先声明、初始化(赋初值)再使用。
}
</code></pre><h5 id="成员变量（也叫实例变量-member-variable）"><a href="#成员变量（也叫实例变量-member-variable）" class="headerlink" title="成员变量（也叫实例变量  member variable）"></a>成员变量（也叫实例变量  member variable）</h5><pre><code>方法外部、类的内部定义的变量。从属于对象，生命周期伴随对象始终。如果不自行初始化，它会自动初始化成该类型的默认初始值。表2-3实例变量的默认初始值数据类型实始值
</code></pre><p>   <img src="en-resource://database/7188:1" alt="31201947b053e56b2ca7ea3b79fbfead.png"></p>
<h5 id="静态变量（类变量-static-variable）"><a href="#静态变量（类变量-static-variable）" class="headerlink" title="静态变量（类变量 static variable）"></a>静态变量（类变量 static variable）</h5><pre><code>使用static定义。 从属于类，生命周期伴随类始终，从类加载到卸载。最长
</code></pre><h5 id="常量-Constant"><a href="#常量-Constant" class="headerlink" title="常量(Constant)"></a>常量(Constant)</h5><pre><code>    一般将1、2、3、’a’、’b’、true、false、”helloWorld”等称为字面常量，
    而使用final修饰的PI等称为符号常量。


final  type  varName = value;
fina int PI = 3.141592653;
</code></pre><h5 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h5><p>类成员变量：首字母小写和驼峰原则:  monthSalary</p>
<p>类名：首字母大写和驼峰原则:  Man, GoodMan</p>
<p>常量：大写字母和下划线：MAX_VALUE</p>
<p>方法名：首字母小写和驼峰原则: run(), runRun()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class TestVarible &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        final double PI = 3.14;</span><br><span class="line"></span><br><span class="line">        //PI = 3; 定义无效</span><br><span class="line"></span><br><span class="line">        double r = 4;</span><br><span class="line"></span><br><span class="line">        double area = PI * r * r;</span><br><span class="line"></span><br><span class="line">        double circle = 2 * PI * r;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;area =&quot;+ area);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;circle=&quot;+ circle);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://wadezhx.github.io/2018/11/28/java学习第二次笔记/" data-id="cjpc0m9oy0003gorqkebod4zv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java学习第一次笔记" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/26/java学习第一次笔记/" class="article-date">
  <time datetime="2018-11-26T14:38:40.000Z" itemprop="datePublished">2018-11-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/26/java学习第一次笔记/">java学习第一次笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="wade-zhx"><a href="#wade-zhx" class="headerlink" title="wade.zhx"></a>wade.zhx</h1><h2 id="wade-zhx-1"><a href="#wade-zhx-1" class="headerlink" title="wade.zhx"></a><strong>wade.zhx</strong></h2><p>2018年11月28日22:34</p>
<ol>
<li><h4 id="工具-eclipse"><a href="#工具-eclipse" class="headerlink" title="工具 eclipse"></a>工具 eclipse</h4></li>
<li><h4 id="学习网址"><a href="#学习网址" class="headerlink" title="学习网址"></a>学习网址</h4><ol>
<li><a href="https://www.bilibili.com/video/av29306544/?p=25" target="_blank" rel="noopener">bilibili</a></li>
<li><a href="http://www.sxt.cn/Java_jQuery_in_action/Java_Identifier.html" target="_blank" rel="noopener">尚学堂 </a></li>
</ol>
</li>
<li><h4 id="记录："><a href="#记录：" class="headerlink" title="记录："></a>记录：</h4> JVM是虚拟机；java可以跨平台是因为虚拟机可以不同系统编译<pre><code>![16e79e25643f6d14796fb28087c339ba.png](en-resource://database/7186:1)
</code></pre></li>
<li><h4 id="DOS命令"><a href="#DOS命令" class="headerlink" title="DOS命令"></a>DOS命令</h4><pre><code>cd  cd ..  dir  cls
</code></pre></li>
<li><p>一个源文件中至多只能声明一个public的类，其它类的个数不限，如果源文件中包含一个public 类，源文件名必须和其中定义的public的类名相同，且以“.java”为扩展名</p>
<ol start="7">
<li>// 单行注释<br>/<em> 多行注释，灵活</em>/<br>/*<em> 文档注释 </em>/</li>
</ol>
</li>
</ol>
<p>8.</p>
<h5 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h5><pre><code>必须以字母、下划线_、美元符号$开头。 
</code></pre><p> 其它部分可以是字母、下划线“_”、美元符“$”和数字的任意组合。</p>
<pre><code>表示类名的标识符：每个单词的首字母大写，如Man, GoodMan
表示方法和变量的标识符：第一个单词小写，从第二个单词开始首字  母大写，  我们称之为**驼峰原则**，如eat(), eatFood()
</code></pre><ol start="9">
<li><h5 id="变量本质上就是代表一个”可操作的存储空间”，空间位置是确定的，但是里面放置什么值不确定。"><a href="#变量本质上就是代表一个”可操作的存储空间”，空间位置是确定的，但是里面放置什么值不确定。" class="headerlink" title="变量本质上就是代表一个”可操作的存储空间”，空间位置是确定的，但是里面放置什么值不确定。"></a>变量本质上就是代表一个”可操作的存储空间”，空间位置是确定的，但是里面放置什么值不确定。</h5><ol>
<li>我们可通过变量名来访问“对应的存储空间”，从而操纵这个“存储空间”存储的值。     </li>
<li>Java是一种强类型语言，每个变量都必须声明其数据类型。变量的数据类型决定了变量占据存储空间的大小。</li>
</ol>
</li>
<li></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wadezhx.github.io/2018/11/26/java学习第一次笔记/" data-id="cjpc0m9ot0001gorqj1gjnrnq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web-Service/">Web Service</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oracle/">oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Web-Service/" style="font-size: 10px;">Web Service</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/oracle/" style="font-size: 10px;">oracle</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/12/06/数据结构中各种树/">数据结构中各种树</a>
          </li>
        
          <li>
            <a href="/2018/12/06/经典排序算法总结与实现/">经典排序算法总结与实现</a>
          </li>
        
          <li>
            <a href="/2018/12/05/java学习第三次笔记/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/12/05/java学习第五次笔记/">java学习第五次笔记</a>
          </li>
        
          <li>
            <a href="/2018/12/04/在N个不相等的整数中找出最大的第K个数(NK)/">在N个不相等的整数中找出最大的第K个数(N&gt;K)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 wadezhx<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>