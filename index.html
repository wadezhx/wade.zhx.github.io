<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://wadezhx.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://wadezhx.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-新建文本文档" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/新建文本文档/" class="article-date">
  <time datetime="2018-12-06T13:27:39.173Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>title: Distributed2：SQL Server 创建分布式数据库<br>date: 2018-12-06 21:06:25<br>tags: 分布式数据库<br>分布式数据库的优势是将IO分散在不同的Physical Disk上，每次查询都由多台Server的CPU,I/O共同负载，通过各节点并行处理数据来提高性能，劣势是消耗大量的网络带宽资源，管理难度大。在SQL Server 2012 版本中，创建水平切分的分布式数据库，必须分两步来实现：划分子集和对子集进行并集操作。</p>
<p>划分子集是将原始表水平切分成若干个较小的成员表，每一个成员表都是全集的一个划分（各子集的并集是全集，其交集是空集）。每个成员表包含与原始表相同数量的列，并且每一列具有与原始表中的相应列同样的特性（如数据类型、大小、排序规则），成员表的schema和原始表相同，只是存储的数据不同。水平切分原始表，也叫做数据库水平分片，sharding。在查询时，利用分区视图来实现水平分片对用户透明，分区视图对分布在不同服务器中的分区数据进行并集操作，使数据看起来来自一个表。</p>
<p>分布在不同场地的SQL Server通过Linked Server相互通信，通过MSDTC来保证查询的事务特性。Linked Server定义从某一数据库服务器到另一数据库服务器的单向通信路径，而MSDTC能够保证一个事务在不同的Server上实现ACID属性。例如，在一个事务中存在 Server1上的 Insert 操作和 Server2上 Update 操作 ，如果事务回滚，那么MSDTC保证Server1 和 Server2的操作都要回滚；如果事务提交，MSDTC保证Server1 和 Server2的操作都要Commit。</p>
<p>设计目的：将table dbo.Person 的数据水平分片，分布到两天SQL Server上，Column [PersonType] 共有6个值，分别是：(‘IN’,’EM’,’SP’),(‘SC’,’VC’,’GC’)；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE [dbo].[Person]</span><br><span class="line">(</span><br><span class="line">    [PersonID] [int] NOT NULL,</span><br><span class="line">    [PersonType] [nchar](2) NOT NULL,</span><br><span class="line">    [FirstName] [sysname] NOT NULL,</span><br><span class="line">    [MiddleName] [sysname] NOT NULL,</span><br><span class="line">    [LastName] [sysname] NOT NULL</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--default instance</span><br><span class="line">CREATE TABLE [dbo].[Person](</span><br><span class="line">    [PersonID] [int] NOT NULL,</span><br><span class="line">    [PersonType] [nchar](2) NOT NULL,</span><br><span class="line">    [FirstName] sysname,</span><br><span class="line">    [MiddleName] sysname ,</span><br><span class="line">    [LastName] sysname,</span><br><span class="line">    constraint   chk__Person_PersonType check([PersonType] in (&apos;IN&apos;,&apos;EM&apos;,&apos;SP&apos;)) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h5 id="step1，打开Win10-MSDTC（Microsoft-Distributed-Transaction-Coordinator）"><a href="#step1，打开Win10-MSDTC（Microsoft-Distributed-Transaction-Coordinator）" class="headerlink" title="step1，打开Win10 MSDTC（Microsoft Distributed Transaction Coordinator）"></a>step1，打开Win10 MSDTC（Microsoft Distributed Transaction Coordinator）</h5><p>参考《Win10 打开MSDTC》，不再赘述。</p>
<h5 id="step2，分别在两台Server上创建数据库和表，数据库分别是DBtest1-和-DBTest2，将DBTest1作为Master-DB，将DBTest2作为Slave-DB"><a href="#step2，分别在两台Server上创建数据库和表，数据库分别是DBtest1-和-DBTest2，将DBTest1作为Master-DB，将DBTest2作为Slave-DB" class="headerlink" title="step2，分别在两台Server上创建数据库和表，数据库分别是DBtest1 和 DBTest2，将DBTest1作为Master DB，将DBTest2作为Slave DB"></a>step2，分别在两台Server上创建数据库和表，数据库分别是DBtest1 和 DBTest2，将DBTest1作为Master DB，将DBTest2作为Slave DB</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--named instance</span><br><span class="line">CREATE TABLE [dbo].[Person](</span><br><span class="line">    [PersonID] [int] NOT NULL,</span><br><span class="line">    [PersonType] [nchar](2) NOT NULL,</span><br><span class="line">    [FirstName] sysname,</span><br><span class="line">    [MiddleName] sysname ,</span><br><span class="line">    [LastName] sysname,</span><br><span class="line">    constraint   chk__Person_PersonType check([PersonType] in (&apos;SC&apos;,&apos;VC&apos;,&apos;GC&apos;)) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">##### Step3，在Master DB中，添加Linked Server</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">--add linked server</span><br><span class="line">exec sys.sp_addlinkedserver @server= N&apos;db1&apos;</span><br><span class="line">    ,@srvproduct= N&apos;&apos;</span><br><span class="line">    ,@provider= N&apos;SQLNCLI&apos;</span><br><span class="line">    ,@datasrc=  N&apos;LJHPC\NamedInstance1&apos;  </span><br><span class="line">    ,@location= null</span><br><span class="line">    ,@provstr= null </span><br><span class="line">    ,@catalog= N&apos;dbtest2&apos;</span><br><span class="line"></span><br><span class="line">--check </span><br><span class="line">select *</span><br><span class="line">from sys.servers</span><br><span class="line">where is_linked=1</span><br><span class="line"></span><br><span class="line">--drop linked server</span><br><span class="line">--EXEC sys.sp_dropserver @server=N&apos;db1&apos;, @droplogins=&apos;droplogins&apos;</span><br><span class="line"></span><br><span class="line">--add login</span><br><span class="line">exec sp_addlinkedsrvlogin @rmtsrvname = &apos;db1&apos; </span><br><span class="line">     ,@useself=false</span><br><span class="line">     ,@locallogin=null</span><br><span class="line">     ,@rmtuser =&apos;sa&apos;</span><br><span class="line">     ,@rmtpassword=&apos;sa&apos;</span><br></pre></td></tr></table></figure>
<h5 id="step4，创建分布式水平分区视图"><a href="#step4，创建分布式水平分区视图" class="headerlink" title="step4，创建分布式水平分区视图"></a>step4，创建分布式水平分区视图</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">create view dbo.view_Person</span><br><span class="line">as</span><br><span class="line">    select [PersonID]</span><br><span class="line">          ,[PersonType]</span><br><span class="line">          ,[FirstName]</span><br><span class="line">          ,[MiddleName]</span><br><span class="line">          ,[LastName]</span><br><span class="line">    from [dbo].[Person]  with(nolock)</span><br><span class="line">    where [PersonType] in(&apos;IN&apos;,&apos;EM&apos;,&apos;SP&apos;)</span><br><span class="line">    union all</span><br><span class="line">    select [PersonID]</span><br><span class="line">          ,[PersonType]</span><br><span class="line">          ,[FirstName]</span><br><span class="line">          ,[MiddleName]</span><br><span class="line">          ,[LastName]</span><br><span class="line">    from db1.[DBTest2].[dbo].[Person] with(nolock)</span><br><span class="line">    where [PersonType] in(&apos;SC&apos;,&apos;VC&apos;,&apos;GC&apos;)</span><br><span class="line">    with check OPTION;</span><br></pre></td></tr></table></figure>
<h5 id="Step5，查询分布式数据，查看执行计划"><a href="#Step5，查询分布式数据，查看执行计划" class="headerlink" title="Step5，查询分布式数据，查看执行计划"></a>Step5，查询分布式数据，查看执行计划</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">from dbo.view_Person p </span><br><span class="line">where p.PersonType in (&apos;em&apos;,&apos;sc&apos;)</span><br></pre></td></tr></table></figure>
<h5 id="Step6，优化"><a href="#Step6，优化" class="headerlink" title="Step6，优化"></a>Step6，优化</h5><p>分布式事务使用的资源远大于内部事务，通常使用OPENQUERY等相关行集函数，避免过度依赖分布式事务。</p>
<h5 id="1，使用OpenQuery，避免DTC的干预"><a href="#1，使用OpenQuery，避免DTC的干预" class="headerlink" title="1，使用OpenQuery，避免DTC的干预"></a>1，使用OpenQuery，避免DTC的干预</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create view dbo.view_Person</span><br><span class="line">as</span><br><span class="line">    select [PersonID]</span><br><span class="line">          ,[PersonType]</span><br><span class="line">          ,[FirstName]</span><br><span class="line">          ,[MiddleName]</span><br><span class="line">          ,[LastName]</span><br><span class="line">    from [dbo].[Person]  with(nolock)</span><br><span class="line">    where [PersonType] in(&apos;IN&apos;,&apos;EM&apos;,&apos;SP&apos;)</span><br><span class="line">    union all</span><br><span class="line">    select [PersonID]</span><br><span class="line">              ,[PersonType]</span><br><span class="line">              ,[FirstName]</span><br><span class="line">              ,[MiddleName]</span><br><span class="line">              ,[LastName]</span><br><span class="line">    from OPENQUERY ( db1 ,</span><br><span class="line">        N&apos;select [PersonID]</span><br><span class="line">              ,[PersonType]</span><br><span class="line">              ,[FirstName]</span><br><span class="line">              ,[MiddleName]</span><br><span class="line">              ,[LastName]</span><br><span class="line">        from db1.[DBTest2].[dbo].[Person] with(nolock)</span><br><span class="line">        where [PersonType] in(&apos;&apos;SC&apos;&apos;,&apos;&apos;VC&apos;&apos;,&apos;&apos;GC&apos;&apos;)&apos; ) as p</span><br><span class="line">    with check OPTION;</span><br></pre></td></tr></table></figure>
<p>参考doc：</p>
<p>Top 3 Performance Killers For Linked Server Queries<br>作者：悦光阴<br>出处：<a href="http://www.cnblogs.com/ljhdo/" target="_blank" rel="noopener">http://www.cnblogs.com/ljhdo/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wadezhx.github.io/2018/12/06/新建文本文档/" data-id="cjpcn5hq90015jkrqw49j2phn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-1 - 副本 (2)" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/1 - 副本 (2)/" class="article-date">
  <time datetime="2018-12-06T13:06:25.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/1 - 副本 (2)/">前端学习 1-9</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>下拉列表也可以进行多选操作，在<select>标签中设置multiple=”multiple”属性，就可以实现多选功能，在 windows 操作系统下，进行多选时按下Ctrl键同时进行单击（在 Mac下使用 Command +单击），可以选择多个选项。如下代码：<br>    <figure class="highlight plain"><figcaption><span>HTML></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;使用下拉列表框进行多选&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;save.php&quot; method=&quot;post&quot; &gt;</span><br><span class="line">    &lt;label&gt;爱好:&lt;/label&gt;</span><br><span class="line">    &lt;select multpie=&quot;multpie&quot;&gt;</span><br><span class="line">      &lt;option value=&quot;看书&quot;&gt;看书&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;旅游&quot;&gt;旅游&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;运动&quot;&gt;运动&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;购物&quot;&gt;购物&lt;/option&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></select></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wadezhx.github.io/2018/12/06/1 - 副本 (2)/" data-id="cjpcn5hoo0000jkrqhh89nn7m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-1 - 副本 (3)" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/1 - 副本 (3)/" class="article-date">
  <time datetime="2018-12-06T13:06:25.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/1 - 副本 (3)/">前端学习 1-8</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在使用表单设计调查表时，为了减少用户的操作，使用选择框是一个好主意，html中有两种选择框，即单选框和复选框，两者的区别是单选框中的选项用户只能选择一项，而复选框中用户可以任意选择多项，甚至全选。请看下面的例子:</p>
<p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input   type=&quot;radio/checkbox&quot;   value=&quot;值&quot;    name=&quot;名称&quot;   checked=&quot;checked&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>1、type:</p>
<p>   当 type=”radio” 时，控件为单选框</p>
<p>   当 type=”checkbox” 时，控件为复选框</p>
<p>2、value：提交数据到服务器的值（后台程序PHP使用）</p>
<p>3、name：为控件命名，以备后台程序 ASP、PHP 使用</p>
<p>4、checked：当设置 checked=”checked” 时，该选项被默认选中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;单选框、复选框&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;save.php&quot; method=&quot;post&quot; &gt;</span><br><span class="line">    &lt;label&gt;性别:&lt;/label&gt;</span><br><span class="line">    &lt;label&gt;男&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;radio&quot; value=&quot;1&quot;  name=&quot;gender&quot; /&gt;</span><br><span class="line">    &lt;label&gt;女&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;radio&quot; value=&quot;2&quot;  name=&quot;gender&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wadezhx.github.io/2018/12/06/1 - 副本 (3)/" data-id="cjpcn5hp20003jkrqylwg8fo9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-分布式数据库" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/分布式数据库/" class="article-date">
  <time datetime="2018-12-06T03:18:18.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/分布式数据库/">分布式数据库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h1><p>分布式数据库是用计算机网络将物理上分散的多个数据库单元连接起来组成的一个逻辑上统一的数据库。每个被连接起来的数据库单元称为站点或节点。分布式数据库有一个统一的数据库管理系统来进行管理，称为分布式数据库管理系统。分布式数据库的基本特点包括：物理分布性、逻辑整体性和站点自治性。从这三个基本特点还可以导出的其它特点有：数据分布透明性、按既定协议达成共识的机制、适当的数据冗余度和事务管理的分布性。</p>
<p>这种组织数据库的方法克服了物理中心数据库组织的弱点。首先，降低了数据传送代价，因为大多数的对数据库的访问操作都是针对局部数据库的，而不是对其他位置的数据库访问；其次，系统的可靠性提高了很多，因为当网络出现故障时，仍然允许对局部数据库的操作，而且一个位置的故障不影响其他位置的处理工作，只有当访问出现故障位置的数据时，在某种程度上才受影响；第三，便于系统的扩充，增加一个新的局部数据库，或在某个位置扩充一台适当的小型计算机，都很容易实现。然而有些功能要付出更高的代价。例如，为了调配在几个位置上的活动，事务管理的性能比在中心数据库时花费更高，而且甚至抵消许多其他的优点。</p>
<p>分布式软件系统(Distributed Software Systems)是支持分布式处理的软件系统,是在由通信网络互联的多处理机体系结构上执行任务的系统。它包括分布式操作系统、分布式程序设计语言及其编译(解释)系统、分布式文件系统和分布式数据库系统等。</p>
<p>分布式操作系统负责管理分布式处理系统资源和控制分布式程序运行。它和集中式操作系统的区别在于资源管理、进程通信和系统结构等方面。 分布式程序设计语言用于编写运行于分布式计算机系统上的分布式程序。一个分布式程序由若干个可以独立执行的程序模块组成,它们分布于一个分布式处理系统的多台计算机上被同时执行。它与集中式的程序设计语言相比有三个特点：分布性、通信性和稳健性。 分布式文件系统具有执行远程文件存取的能力,并以透明方式对分布在网络上的文件进行管理和存取。 分布式数据库系统由分布于多个计算机结点上的若干个数据库系统组成,它提供有效的存取手段来操纵这些结点上的子数据库。分布式数据库在使用上可视为一个完整的数据库,而实际上它是分布在地理分散的各个结点上。当然,分布在各个结点上的子数据库在逻辑上是相关的。</p>
<p>Hadoop的分布式文件系统HDFS，作为开源的分布式平台，为目前流行的很多分布式数据库提供了支持，譬如HBase等。Yonghong的分布式文件系统ZFS，为分布式数据集市Z-DataMart提供了底层平台。</p>
<p>2<br>体系结构<br>编辑<br>根据我国制定的《分布式数据库系统标准》，分布式数据库系统抽象为4层的结构模式。这种结构模式得到了国内外的支持和认同。</p>
<p>4层模式划分为全局外层、全局概念层、局部概念层和局部内层，在各层间还有相应的层间映射。这种4层模式适用于同构型分布式数据库系统，也适用于异构型分布式数据库系统。</p>
<p>3<br>主要特点<br>编辑<br>· 多数处理就地完成；</p>
<p>· 各地的计算机由数据通信网络相联系；</p>
<p>· 克服了中心数据库的弱点：降低了数据传输代价；</p>
<p>· 提高了系统的可靠性，局部系统发生故障，其他部分还可继续工作；</p>
<p>· 各个数据库的位置是透明的，方便系统的扩充；</p>
<p>· 为了协调整个系统的事务活动，事务管理的性能花费高；</p>
<p>4<br>数据分配方式<br>编辑<br>（1）集中式：所有数据片段都安排在同一个场地上。</p>
<p>（2）分割式：所有数据只有一份，它被分割成若干逻辑片段，每个逻辑片段被指派在一个特定的场地上。</p>
<p>（3）全复制式：数据在每个场地重复存储。也就是每个场地上都有一个完整的数据副本。</p>
<p>（4）混合式：这是一种介乎于分割式和全复制式之间的分配方式。</p>
<p>目前分布式数据库分配的设计，越来越多的采用寻找最优解的算法，比如遗传算法、退火机制等</p>
<p>5<br>数据分片类型<br>编辑<br>（1）水平分片：按一定的条件把全局关系的所有元组划分成若干不相交的子集，每个子集为关系的一个片段。</p>
<p>（2）垂直分片：把一个全局关系的属性集分成若干子集，并在这些子集上作投影运算，每个投影称为垂直分片。</p>
<p>（3）导出分片：又称为导出水平分片，即水平分片的条件不是本关系属性的条件，而是其他关系属性的条件。</p>
<p>（4）混合分片：以上三种方法的混合。可以先水平分片再垂直分片，或先垂直分片再水平分片，或其他形式，但他们的结果是不相同的。</p>
<p>条件：</p>
<p>（1）完备性条件：必须把全局关系的所有数据映射到片段中，决不允许有属于全局关系的数据却不属于它的某一个片段。</p>
<p>（2）可重构条件：必须保证能够由同一个全局关系的各个片段来重建该全局关系。对于水平分片可用并操作重构全局关系；对于垂直分片可用联接操作重构全局关系。</p>
<p>（3）不相交条件：要求一个全局关系被分割后所得的各个数据片段互不重叠（对垂直分片的主键除外）。</p>
<p>6<br>查询优化<br>编辑<br>指在执行分布式查询时选择查询执行计划的方法和关系运算符的实现算法。根据系统环境的不同，查询优化所使用的算法也有所不同，通常分为远程广域网环境和高速局域网环境，其区别主要在网络的带宽。对于一元运算符可以采用集中式数据库中的查询优化方法。而对于二元运算符，由于涉及场地间的数据传输，因此必须考虑通信代价。分布式查询中常见的连接运算执行策略包括：</p>
<p>（1）半连接方法：利用半连接运算的转换方法R∞S=（RµS）∞S。假设场地1和场地2上分别有关系R和关系S，首先在S上执行连接属性上的投影并将结果传输至场地1，在场地1上执行关系R与投影的连接操作，再将结果传输至场地2与关系S执行连接操作。这种方法能够降低执行连接运算时的网络通信代价，主要适用于带宽较低的远程广域网络。</p>
<p>（2）枚举法方法：指枚举关系运算符的物理执行计划，通过对比执行计划的代价选择执行算法的方法。其中，连接运算符的物理执行计划包括嵌套循环方法、哈希连接法和归并连接法。枚举法主要适用于以磁盘IO代价为主的高速局域网环境。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wadezhx.github.io/2018/12/06/分布式数据库/" data-id="cjpcn5hpz000tjkrq8zbbp6oy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构中各种树" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/数据结构中各种树/" class="article-date">
  <time datetime="2018-12-06T02:48:13.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/数据结构中各种树/">数据结构中各种树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="数据结构中各种树"><a href="#数据结构中各种树" class="headerlink" title="数据结构中各种树"></a>数据结构中各种树</h1><p>原文出处： Poll的笔记<br>数据结构中有很多树的结构，其中包括二叉树、二叉搜索树、2-3树、红黑树等等。本文中对数据结构中常见的几种树的概念和用途进行了汇总，不求严格精准，但求简单易懂。1. 二叉树<br>二叉树是数据结构中一种重要的数据结构，也是树表家族最为基础的结构。<br>二叉树的定义：二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2i-1个结点；深度为k的二叉树至多有2k-1个结点；对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。<br>二叉树的示例：</p>
<p>满二叉树和完全二叉树：<br>满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上。<br>满二叉树的性质：<br>1) 一颗树深度为h，最大层数为k，深度与最大层数相同，k=h;<br>2) 叶子数为2h;<br>3) 第k层的结点数是：2k-1;<br>4) 总结点数是：2k-1，且总节点数一定是奇数。<br>完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。<br>注：完全二叉树是效率很高的数据结构，堆是一种完全二叉树或者近似完全二叉树，所以效率极高，像十分常用的排序算法、Dijkstra算法、Prim算法等都要用堆才能优化，二叉排序树的效率也要借助平衡性来提高，而平衡性基于完全二叉树。</p>
<p>二叉树的性质：<br>1) 在非空二叉树中，第i层的结点总数不超过2i-1, i&gt;=1;<br>2) 深度为h的二叉树最多有2h-1个结点(h&gt;=1)，最少有h个结点;<br>3) 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1;<br>4) 具有n个结点的完全二叉树的深度为log2(n+1);<br>5)有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系：<br>若I为结点编号则 如果I&gt;1，则其父结点的编号为I/2；<br>如果2I&lt;=N，则其左儿子（即左子树的根结点）的编号为2I；若2I&gt;N，则无左儿子；<br>如果2I+1&lt;=N，则其右儿子的结点编号为2I+1；若2I+1&gt;N，则无右儿子。<br>6)给定N个节点，能构成h(N)种不同的二叉树，其中h(N)为卡特兰数的第N项，h(n)=C(2*n, n)/(n+1)。<br>7)设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和J=I+2i。2. 二叉查找树<br>二叉查找树定义：又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：<br>1) 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>2) 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；<br>3) 左、右子树也分别为二叉排序树；<br>4) 没有键值相等的节点。<br>二叉查找树的性质：对二叉查找树进行中序遍历，即可得到有序的数列。<br>二叉查找树的时间复杂度：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。<br>二叉查找树的高度决定了二叉查找树的查找效率。<br>二叉查找树的插入过程如下：<br>1) 若当前的二叉查找树为空，则插入的元素为根节点;<br>2) 若插入的元素值小于根节点值，则将元素插入到左子树中;<br>3) 若插入的元素值不小于根节点值，则将元素插入到右子树中。<br>二叉查找树的删除，分三种情况进行处理：<br>1) p为叶子节点，直接删除该节点，再修改其父节点的指针（注意分是根节点和不是根节点），如图a;<br>2) p为单支节点（即只有左子树或右子树）。让p的子树与p的父亲节点相连，删除p即可（注意分是根节点和不是根节点），如图b;<br>3) p的左子树和右子树均不空。找到p的后继y，因为y一定没有左子树，所以可以删除y，并让y的父亲节点成为y的右子树的父亲节点，并用y的值代替p的值；或者方法二是找到p的前驱x，x一定没有右子树，所以可以删除x，并让x的父亲节点成为y的左子树的父亲节点。如图c。</p>
<p>二叉树相关实现源码：<br>插入操作：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60</p>
<p>struct node<br>{<br>    int val;<br>    pnode lchild;<br>    pnode rchild;<br>};</p>
<p>pnode BT = NULL;</p>
<p>//递归方法插入节点<br>pnode insert(pnode root, int x)<br>{<br>    pnode p = (pnode)malloc(LEN);<br>    p-&gt;val = x;<br>    p-&gt;lchild = NULL;<br>    p-&gt;rchild = NULL;<br>    if(root == NULL){<br>        root = p;<br>    }<br>    else if(x &lt; root-&gt;val){<br>        root-&gt;lchild = insert(root-&gt;lchild, x);<br>    }<br>    else{<br>        root-&gt;rchild = insert(root-&gt;rchild, x);<br>    }<br>    return root;<br>}</p>
<p>//非递归方法插入节点<br>void insert_BST(pnode q, int x)<br>{<br>    pnode p = (pnode)malloc(LEN);<br>    p-&gt;val = x;<br>    p-&gt;lchild = NULL;<br>    p-&gt;rchild = NULL;<br>    if(q == NULL){<br>        BT = p;<br>        return ;<br>    }<br>    while(q-&gt;lchild != p &amp;&amp; q-&gt;rchild != p){<br>        if(x &lt; q-&gt;val){<br>            if(q-&gt;lchild){<br>                q = q-&gt;lchild;<br>            }<br>            else{<br>                q-&gt;lchild = p;<br>            }<br>        }<br>        else{<br>            if(q-&gt;rchild){<br>                q = q-&gt;rchild;<br>            }<br>            else{<br>                q-&gt;rchild = p;<br>            }<br>        }<br>    }<br>    return;<br>}</p>
<p>删除操作：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77</p>
<p>bool delete_BST(pnode p, int x) //返回一个标志，表示是否找到被删元素<br>{<br>    bool find = false;<br>    pnode q;<br>    p = BT;<br>    while(p &amp;&amp; !find){  //寻找被删元素<br>        if(x == p-&gt;val){  //找到被删元素<br>            find = true;<br>        }<br>        else if(x &lt; p-&gt;val){ //沿左子树找<br>            q = p;<br>            p = p-&gt;lchild;<br>        }<br>        else{   //沿右子树找<br>            q = p;<br>            p = p-&gt;rchild;<br>        }<br>    }<br>    if(p == NULL){   //没找到<br>        cout &lt;&lt; “没有找到” &lt;&lt; x &lt;&lt; endl;<br>    }</p>
<pre><code>if(p-&gt;lchild == NULL &amp;&amp; p-&gt;rchild == NULL){  //p为叶子节点
    if(p == BT){  //p为根节点
        BT = NULL;    
    }
    else if(q-&gt;lchild == p){  
        q-&gt;lchild = NULL;
    }        
    else{
        q-&gt;rchild = NULL;    
    }
    free(p);  //释放节点p
}
else if(p-&gt;lchild == NULL || p-&gt;rchild == NULL){ //p为单支子树
    if(p == BT){  //p为根节点
        if(p-&gt;lchild == NULL){
            BT = p-&gt;rchild;    
        }    
        else{
            BT = p-&gt;lchild;    
        }
    }    
    else{
        if(q-&gt;lchild == p &amp;&amp; p-&gt;lchild){ //p是q的左子树且p有左子树
            q-&gt;lchild = p-&gt;lchild;    //将p的左子树链接到q的左指针上
        }    
        else if(q-&gt;lchild == p &amp;&amp; p-&gt;rchild){
            q-&gt;lchild = p-&gt;rchild;    
        }
        else if(q-&gt;rchild == p &amp;&amp; p-&gt;lchild){
            q-&gt;rchild = p-&gt;lchild;    
        }
        else{
            q-&gt;rchild = p-&gt;rchild;
        }
    }
    free(p);
}
else{ //p的左右子树均不为空
    pnode t = p;
    pnode s = p-&gt;lchild;  //从p的左子节点开始
    while(s-&gt;rchild){  //找到p的前驱，即p左子树中值最大的节点
        t = s;  
        s = s-&gt;rchild;    
    }
    p-&gt;val = s-&gt;val;   //把节点s的值赋给p
    if(t == p){
        p-&gt;lchild = s-&gt;lchild;    
    }    
    else{
        t-&gt;rchild = s-&gt;lchild;    
    }
    free(s);
}
return find;
</code></pre><p>}</p>
<p>查找操作：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19</p>
<p>pnode search_BST(pnode p, int x)<br>{<br>    bool solve = false;<br>    while(p &amp;&amp; !solve){<br>        if(x == p-&gt;val){<br>            solve = true;<br>        }<br>        else if(x &lt; p-&gt;val){<br>            p = p-&gt;lchild;<br>        }<br>        else{<br>            p = p-&gt;rchild;<br>        }<br>    }<br>    if(p == NULL){<br>        cout &lt;&lt; “没有找到” &lt;&lt; x &lt;&lt; endl;<br>    }<br>    return p;<br>}</p>
<ol start="3">
<li>平衡二叉树<br>我们知道，对于一般的二叉搜索树（Binary Search Tree），其期望高度（即为一棵平衡树时）为log2n，其各操作的时间复杂度O(log2n)同时也由此而决定。但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即O(n)。我们可以通过随机化建立二叉搜索树来尽量的避免这种情况，但是在进行了多次的操作之后，由于在删除时，我们总是选择将待删除节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于树向左偏沉。这同时也会造成树的平衡性受到破坏，提高它的操作的时间复杂度。于是就有了我们下边介绍的平衡二叉树。<br>平衡二叉树定义：平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用算法有红黑树、AVL树等。在平衡二叉搜索树中，我们可以看到，其高度一般都良好地维持在O(log2n)，大大降低了操作的时间复杂度。<br>最小二叉平衡树的节点的公式如下：<br>F(n)=F(n-1)+F(n-2)+1<br>这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。3.1 平衡查找树之AVL树<br>有关AVL树的具体实现，可以参考C小加的博客《一步一步写平衡二叉树（AVL）》。<br>AVL树定义：AVL树是最先发明的自平衡二叉查找树。AVL树得名于它的发明者 G.M. Adelson-Velsky 和 E.M. Landis，他们在 1962 年的论文 “An algorithm for the organization of information” 中发表了它。在AVL中任何节点的两个儿子子树的高度最大差别为1，所以它也被称为高度平衡树，n个结点的AVL树最大深度约1.44log2n。查找、插入和删除在平均和最坏情况下都是O(logn)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。<br>AVL树的自平衡操作——旋转：<br>AVL树最关键的也是最难的一步操作就是旋转。旋转主要是为了实现AVL树在实施了插入和删除操作以后，树重新回到平衡的方法。下面我们重点研究一下AVL树的旋转。<br>对于一个平衡的节点，由于任意节点最多有两个儿子，因此高度不平衡时，此节点的两颗子树的高度差2.容易看出，这种不平衡出现在下面四种情况：</li>
</ol>
<p>1) 6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为左左。<br>2) 6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为左右。<br>3) 2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为右左。<br>4) 2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为右右。<br>从图2中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，我们称之为单旋转。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，我们称之为双旋转。<br>单旋转<br>单旋转是针对于左左和右右这两种情况的解决方案，这两种情况是对称的，只要解决了左左这种情况，右右就很好办了。图3是左左情况的解决方案，节点k2不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的左子树X子树，所以属于左左情况。</p>
<p>为使树恢复平衡，我们把k2变成这棵树的根节点，因为k2大于k1，把k2置于k1的右子树上，而原本在k1右子树的Y大于k1，小于k2，就把Y置于k2的左子树上，这样既满足了二叉查找树的性质，又满足了平衡二叉树的性质。<br>这样的操作只需要一部分指针改变，结果我们得到另外一颗二叉查找树，它是一棵AVL树，因为X向上一移动了一层，Y还停留在原来的层面上，Z向下移动了一层。整棵树的新高度和之前没有在左子树上插入的高度相同，插入操作使得X高度长高了。因此，由于这颗子树高度没有变化，所以通往根节点的路径就不需要继续旋转了。<br>双旋转<br>对于左右和右左这两种情况，单旋转不能使它达到一个平衡状态，要经过两次旋转。双旋转是针对于这两种情况的解决方案，同样的，这样两种情况也是对称的，只要解决了左右这种情况，右左就很好办了。图4是左右情况的解决方案，节点k3不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的右子树k2子树，所以属于左右情况。</p>
<p>为使树恢复平衡，我们需要进行两步，第一步，把k1作为根，进行一次右右旋转，旋转之后就变成了左左情况，所以第二步再进行一次左左旋转，最后得到了一棵以k2为根的平衡二叉树。<br>AVL树实现源码：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148<br>149<br>150<br>151<br>152<br>153<br>154<br>155<br>156<br>157<br>158<br>159<br>160<br>161<br>162<br>163<br>164<br>165<br>166<br>167<br>168<br>169<br>170<br>171<br>172<br>173<br>174<br>175<br>176<br>177<br>178<br>179<br>180<br>181<br>182<br>183<br>184<br>185<br>186<br>187<br>188<br>189<br>190<br>191<br>192<br>193<br>194<br>195<br>196<br>197<br>198<br>199<br>200<br>201<br>202<br>203<br>204<br>205<br>206<br>207<br>208<br>209<br>210<br>211<br>212<br>213<br>214<br>215<br>216<br>217<br>218<br>219<br>220<br>221<br>222<br>223<br>224<br>225<br>226<br>227<br>228<br>229</p>
<p>//AVL树节点信息<br>template<class t=""><br>class TreeNode<br>{<br>    public:<br>        TreeNode():lson(NULL),rson(NULL),freq(1),hgt(0){}<br>        T data;//值<br>        int hgt;//高度<br>        unsigned int freq;//频率<br>        TreeNode<em> lson;//指向左儿子的地址<br>        TreeNode</em> rson;//指向右儿子的地址<br>};<br>//AVL树类的属性和方法声明<br>template<class t=""><br>class AVLTree<br>{<br>    private:<br>        TreeNode<t><em> root;//根节点<br>        void insertpri(TreeNode<t></t></em> &amp;node,T x);//插入<br>        TreeNode<t><em> findpri(TreeNode<t></t></em> node,T x);//查找<br>        void insubtree(TreeNode<t><em> node);//中序遍历<br>        void Deletepri(TreeNode<t></t></em> &amp;node,T x);//删除<br>        int height(TreeNode<t><em> node);//求树的高度<br>        void SingRotateLeft(TreeNode<t></t></em> &amp;k2);//左左情况下的旋转<br>        void SingRotateRight(TreeNode<t><em> &amp;k2);//右右情况下的旋转<br>        void DoubleRotateLR(TreeNode<t></t></em> &amp;k3);//左右情况下的旋转<br>        void DoubleRotateRL(TreeNode<t>* &amp;k3);//右左情况下的旋转<br>        int Max(int cmpa,int cmpb);//求最大值</t></t></t></t></t></t></class></class></p>
<pre><code>public:
    AVLTree():root(NULL){}
    void insert(T x);//插入接口
    TreeNode&lt;T&gt;* find(T x);//查找接口
    void Delete(T x);//删除接口
    void traversal();//遍历接口
</code></pre><p>};<br>//计算节点的高度<br>template<class t=""><br>int AVLTree<t>::height(TreeNode<t><em> node)<br>{<br>    if(node!=NULL)<br>        return node-&gt;hgt;<br>    return -1;<br>}<br>//求最大值<br>template<class t=""><br>int AVLTree<t>::Max(int cmpa,int cmpb)<br>{<br>    return cmpa&gt;cmpb?cmpa:cmpb;<br>}<br>//左左情况下的旋转<br>template<class t=""><br>void AVLTree<t>::SingRotateLeft(TreeNode<t></t></t></class></t></class></em> &amp;k2)<br>{<br>    TreeNode<t>* k1;<br>    k1=k2-&gt;lson;<br>    k2-&gt;lson=k1-&gt;rson;<br>    k1-&gt;rson=k2;</t></t></t></class></p>
<pre><code>k2-&gt;hgt=Max(height(k2-&gt;lson),height(k2-&gt;rson))+1;
k1-&gt;hgt=Max(height(k1-&gt;lson),k2-&gt;hgt)+1;
</code></pre><p>}<br>//右右情况下的旋转<br>template<class t=""><br>void AVLTree<t>::SingRotateRight(TreeNode<t><em> &amp;k2)<br>{<br>    TreeNode<t></t></em> k1;<br>    k1=k2-&gt;rson;<br>    k2-&gt;rson=k1-&gt;lson;<br>    k1-&gt;lson=k2;</t></t></class></p>
<pre><code>k2-&gt;hgt=Max(height(k2-&gt;lson),height(k2-&gt;rson))+1;
k1-&gt;hgt=Max(height(k1-&gt;rson),k2-&gt;hgt)+1;
</code></pre><p>}<br>//左右情况的旋转<br>template<class t=""><br>void AVLTree<t>::DoubleRotateLR(TreeNode<t><em> &amp;k3)<br>{<br>    SingRotateRight(k3-&gt;lson);<br>    SingRotateLeft(k3);<br>}<br>//右左情况的旋转<br>template<class t=""><br>void AVLTree<t>::DoubleRotateRL(TreeNode<t></t></t></class></em> &amp;k3)<br>{<br>    SingRotateLeft(k3-&gt;rson);<br>    SingRotateRight(k3);<br>}<br>//插入<br>template<class t=""><br>void AVLTree<t>::insertpri(TreeNode<t><em> &amp;node,T x)<br>{<br>    if(node==NULL)//如果节点为空,就在此节点处加入x信息<br>    {<br>        node=new TreeNode<t>();<br>        node-&gt;data=x;<br>        return;<br>    }<br>    if(node-&gt;data&gt;x)//如果x小于节点的值,就继续在节点的左子树中插入x<br>    {<br>        insertpri(node-&gt;lson,x);<br>        if(2==height(node-&gt;lson)-height(node-&gt;rson))<br>            if(x<node->lson-&gt;data)<br>                SingRotateLeft(node);<br>            else<br>                DoubleRotateLR(node);<br>    }<br>    else if(node-&gt;data&lt;x)//如果x大于节点的值,就继续在节点的右子树中插入x<br>    {<br>        insertpri(node-&gt;rson,x);<br>        if(2==height(node-&gt;rson)-height(node-&gt;lson))//如果高度之差为2的话就失去了平衡,需要旋转<br>            if(x&gt;node-&gt;rson-&gt;data)<br>                SingRotateRight(node);<br>            else<br>                DoubleRotateRL(node);<br>    }<br>    else ++(node-&gt;freq);//如果相等,就把频率加1<br>    node-&gt;hgt=Max(height(node-&gt;lson),height(node-&gt;rson));<br>}<br>//插入接口<br>template<class t=""><br>void AVLTree<t>::insert(T x)<br>{<br>    insertpri(root,x);<br>}<br>//查找<br>template<class t=""><br>TreeNode<t></t></class></t></class></node-></t></em> AVLTree<t>::findpri(TreeNode<t><em> node,T x)<br>{<br>    if(node==NULL)//如果节点为空说明没找到,返回NULL<br>    {<br>        return NULL;<br>    }<br>    if(node-&gt;data&gt;x)//如果x小于节点的值,就继续在节点的左子树中查找x<br>    {<br>        return findpri(node-&gt;lson,x);<br>    }<br>    else if(node-&gt;data&lt;x)//如果x大于节点的值,就继续在节点的左子树中查找x<br>    {<br>        return findpri(node-&gt;rson,x);<br>    }<br>    else return node;//如果相等,就找到了此节点<br>}<br>//查找接口<br>template<class t=""><br>TreeNode<t></t></class></em> AVLTree<t>::find(T x)<br>{<br>    return findpri(root,x);<br>}<br>//删除<br>template<class t=""><br>void AVLTree<t>::Deletepri(TreeNode<t>* &amp;node,T x)<br>{<br>    if(node==NULL) return ;//没有找到值是x的节点<br>    if(x &lt; node-&gt;data)<br>    {<br>         Deletepri(node-&gt;lson,x);//如果x小于节点的值,就继续在节点的左子树中删除x<br>         if(2==height(node-&gt;rson)-height(node-&gt;lson))<br>            if(node-&gt;rson-&gt;lson!=NULL&amp;&amp;(height(node-&gt;rson-&gt;lson)&gt;height(node-&gt;rson-&gt;rson)) )<br>                DoubleRotateRL(node);<br>            else<br>                SingRotateRight(node);<br>    }</t></t></class></t></t></t></t></t></class></t></t></class></p>
<pre><code>else if(x &gt; node-&gt;data)
{
     Deletepri(node-&gt;rson,x);//如果x大于节点的值,就继续在节点的右子树中删除x
     if(2==height(node-&gt;lson)-height(node-&gt;rson))
        if(node-&gt;lson-&gt;rson!=NULL&amp;&amp; (height(node-&gt;lson-&gt;rson)&gt;height(node-&gt;lson-&gt;lson) ))
            DoubleRotateLR(node);
        else
            SingRotateLeft(node);
}

else//如果相等,此节点就是要删除的节点
{
    if(node-&gt;lson&amp;&amp;node-&gt;rson)//此节点有两个儿子
    {
        TreeNode&lt;T&gt;* temp=node-&gt;rson;//temp指向节点的右儿子
        while(temp-&gt;lson!=NULL) temp=temp-&gt;lson;//找到右子树中值最小的节点
        //把右子树中最小节点的值赋值给本节点
        node-&gt;data=temp-&gt;data;
        node-&gt;freq=temp-&gt;freq;
        Deletepri(node-&gt;rson,temp-&gt;data);//删除右子树中最小值的节点
        if(2==height(node-&gt;lson)-height(node-&gt;rson))
        {
            if(node-&gt;lson-&gt;rson!=NULL&amp;&amp; (height(node-&gt;lson-&gt;rson)&gt;height(node-&gt;lson-&gt;lson) ))
                DoubleRotateLR(node);
            else
                SingRotateLeft(node);
        }
    }
    else//此节点有1个或0个儿子
    {
        TreeNode&lt;T&gt;* temp=node;
        if(node-&gt;lson==NULL)//有右儿子或者没有儿子
        node=node-&gt;rson;
        else if(node-&gt;rson==NULL)//有左儿子
        node=node-&gt;lson;
        delete(temp);
        temp=NULL;
    }
}
if(node==NULL) return;
node-&gt;hgt=Max(height(node-&gt;lson),height(node-&gt;rson))+1;
return;
</code></pre><p>}<br>//删除接口<br>template<class t=""><br>void AVLTree<t>::Delete(T x)<br>{<br>    Deletepri(root,x);<br>}<br>//中序遍历函数<br>template<class t=""><br>void AVLTree<t>::insubtree(TreeNode<t>* node)<br>{<br>    if(node==NULL) return;<br>    insubtree(node-&gt;lson);//先遍历左子树<br>    cout&lt;<node->data&lt;&lt;” “;//输出根节点<br>    insubtree(node-&gt;rson);//再遍历右子树<br>}<br>//中序遍历接口<br>template<class t=""><br>void AVLTree<t>::traversal()<br>{<br>    insubtree(root);<br>}</t></class></node-></t></t></class></t></class></p>
<p>3.2 平衡二叉树之红黑树<br>红黑树的定义：红黑树是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它是在1972年由鲁道夫·贝尔发明的，称之为”对称二叉B树”，它现代的名字是在 Leo J. Guibas 和 Robert Sedgewick 于1978年写的一篇论文中获得的。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(logn)时间内做查找，插入和删除，这里的n是树中元素的数目。<br>红黑树和AVL树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。这不只是使它们在时间敏感的应用如实时应用（real time application）中有价值，而且使它们有在提供最坏情况担保的其他数据结构中作为建造板块的价值；例如，在计算几何中使用的很多数据结构都可以基于红黑树。此外，红黑树还是2-3-4树的一种等同，它们的思想是一样的，只不过红黑树是2-3-4树用二叉树的形式表示的。<br>红黑树的性质：<br>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制的一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:<br>性质1. 节点是红色或黑色。<br>性质2. 根是黑色。<br>性质3. 所有叶子都是黑色（叶子是NIL节点）。<br>性质4. 每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。)<br>性质5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。<br>下面是一个具体的红黑树的图例：</p>
<p>这些约束确保了红黑树的关键特性: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。<br>要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。<br>以下内容整理自wiki百科之红黑树。<br>红黑树的自平衡操作：<br>因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。然而，在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量(O(logn))的颜色变更(实际是非常快速的)和不超过三次树旋转(对于插入操作是两次)。虽然插入和删除很复杂，但操作时间仍可以保持为O(logn) 次。<br>我们首先以二叉查找树的方法增加节点并标记它为红色。如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的（违背性质5）。但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整。下面要进行什么操作取决于其他临近节点的颜色。同人类的家族树中一样，我们将使用术语叔父节点来指一个节点的父节点的兄弟节点。注意:</p>
<pre><code>* 
</code></pre><p>性质1和性质3总是保持着。</p>
<pre><code>* 
</code></pre><p>性质4只在增加红色节点、重绘黑色节点为红色，或做旋转时受到威胁。</p>
<pre><code>* 
</code></pre><p>性质5只在增加黑色节点、重绘红色节点为黑色，或做旋转时受到威胁。</p>
<p>插入操作：<br>假设，将要插入的节点标为N，N的父节点标为P，N的祖父节点标为G，N的叔父节点标为U。在图中展示的任何颜色要么是由它所处情形这些所作的假定，要么是假定所暗含的。<br>情形1: 该树为空树，直接插入根结点的位置，违反性质1，把节点颜色有红改为黑即可。<br>情形2: 插入节点N的父节点P为黑色，不违反任何性质，无需做任何修改。在这种情形下，树仍是有效的。性质5也未受到威胁，尽管新节点N有两个黑色叶子子节点；但由于新节点N是红色，通过它的每个子节点的路径就都有同通过它所取代的黑色的叶子的路径同样数目的黑色节点，所以依然满足这个性质。<br>注： 情形1很简单，情形2中P为黑色，一切安然无事，但P为红就不一样了，下边是P为红的各种情况，也是真正难懂的地方。<br>情形3: 如果父节点P和叔父节点U二者都是红色，(此时新插入节点N做为P的左子节点或右子节点都属于情形3,这里右图仅显示N做为P左子的情形)则我们可以将它们两个重绘为黑色并重绘祖父节点G为红色(用来保持性质4)。现在我们的新节点N有了一个黑色的父节点P。因为通过父节点P或叔父节点U的任何路径都必定通过祖父节点G，在这些路径上的黑节点数目没有改变。但是，红色的祖父节点G的父节点也有可能是红色的，这就违反了性质4。为了解决这个问题，我们在祖父节点G上递归地进行上述情形的整个过程（把G当成是新加入的节点进行各种情形的检查）。比如，G为根节点，那我们就直接将G变为黑色（情形1）；如果G不是根节点，而它的父节点为黑色，那符合所有的性质，直接插入即可（情形2）；如果G不是根节点，而它的父节点为红色，则递归上述过程（情形3）。</p>
<p>情形4: 父节点P是红色而叔父节点U是黑色或缺少，新节点N是其父节点的左子节点，而父节点P又是其父节点G的左子节点。在这种情形下，我们进行针对祖父节点G的一次右旋转; 在旋转产生的树中，以前的父节点P现在是新节点N和以前的祖父节点G的父节点。我们知道以前的祖父节点G是黑色，否则父节点P就不可能是红色(如果P和G都是红色就违反了性质4，所以G必须是黑色)。我们切换以前的父节点P和祖父节点G的颜色，结果的树满足性质4。性质5也仍然保持满足，因为通过这三个节点中任何一个的所有路径以前都通过祖父节点G，现在它们都通过以前的父节点P。在各自的情形下，这都是三个节点中唯一的黑色节点。</p>
<p>情形5: 父节点P是红色而叔父节点U是黑色或缺少，并且新节点N是其父节点P的右子节点而父节点P又是其父节点的左子节点。在这种情形下，我们进行一次左旋转调换新节点和其父节点的角色; 接着，我们按情形4处理以前的父节点P以解决仍然失效的性质4。注意这个改变会导致某些路径通过它们以前不通过的新节点N（比如图中1号叶子节点）或不通过节点P（比如图中3号叶子节点），但由于这两个节点都是红色的，所以性质5仍有效。</p>
<p>注: 插入实际上是原地算法，因为上述所有调用都使用了尾部递归。<br>删除操作：<br>如果需要删除的节点有两个儿子，那么问题可以被转化成删除另一个只有一个儿子的节点的问题。对于二叉查找树，在删除带有两个非叶子儿子的节点的时候，我们找到要么在它的左子树中的最大元素、要么在它的右子树中的最小元素，并把它的值转移到要删除的节点中。我们接着删除我们从中复制出值的那个节点，它必定有少于两个非叶子的儿子。因为只是复制了一个值，不违反任何性质，这就把问题简化为如何删除最多有一个儿子的节点的问题。它不关心这个节点是最初要删除的节点还是我们从中复制出值的那个节点。<br>我们只需要讨论删除只有一个儿子的节点(如果它两个儿子都为空，即均为叶子，我们任意将其中一个看作它的儿子)。如果我们删除一个红色节点（此时该节点的儿子将都为叶子节点），它的父亲和儿子一定是黑色的。所以我们可以简单的用它的黑色儿子替换它，并不会破坏性质3和性质4。通过被删除节点的所有路径只是少了一个红色节点，这样可以继续保证性质5。另一种简单情况是在被删除节点是黑色而它的儿子是红色的时候。如果只是去除这个黑色节点，用它的红色儿子顶替上来的话，会破坏性质5，但是如果我们重绘它的儿子为黑色，则曾经通过它的所有路径将通过它的黑色儿子，这样可以继续保持性质5。<br>需要进一步讨论的是在要删除的节点和它的儿子二者都是黑色的时候，这是一种复杂的情况。我们首先把要删除的节点替换为它的儿子。出于方便，称呼这个儿子为N(在新的位置上)，称呼它的兄弟(它父亲的另一个儿子)为S。在下面的示意图中，我们还是使用P称呼N的父亲，SL称呼S的左儿子，SR称呼S的右儿子。<br>如果N和它初始的父亲是黑色，则删除它的父亲导致通过N的路径都比不通过它的路径少了一个黑色节点。因为这违反了性质5，树需要被重新平衡。有几种情形需要考虑:<br>情形1: N是新的根。在这种情形下，我们就做完了。我们从所有路径去除了一个黑色节点，而新根是黑色的，所以性质都保持着。<br>注意: 在情形2、5和6下，我们假定N是它父亲的左儿子。如果它是右儿子，则在这些情形下的左和右应当对调。<br>情形2: S是红色。在这种情形下我们在N的父亲上做左旋转，把红色兄弟转换成N的祖父，我们接着对调N的父亲和祖父的颜色。完成这两个操作后，尽管所有路径上黑色节点的数目没有改变，但现在N有了一个黑色的兄弟和一个红色的父亲（它的新兄弟是黑色因为它是红色S的一个儿子），所以我们可以接下去按情形4、情形5或情形6来处理。</p>
<p>情形3: N的父亲、S和S的儿子都是黑色的。在这种情形下，我们简单的重绘S为红色。结果是通过S的所有路径，它们就是以前不通过N的那些路径，都少了一个黑色节点。因为删除N的初始的父亲使通过N的所有路径少了一个黑色节点，这使事情都平衡了起来。但是，通过P的所有路径现在比不通过P的路径少了一个黑色节点，所以仍然违反性质5。要修正这个问题，我们要从情形1开始，在P上做重新平衡处理。</p>
<p>情形4: S和S的儿子都是黑色，但是N的父亲是红色。在这种情形下，我们简单的交换N的兄弟和父亲的颜色。这不影响不通过N的路径的黑色节点的数目，但是它在通过N的路径上对黑色节点数目增加了一，添补了在这些路径上删除的黑色节点。</p>
<p>情形5: S是黑色，S的左儿子是红色，S的右儿子是黑色，而N是它父亲的左儿子。在这种情形下我们在S上做右旋转，这样S的左儿子成为S的父亲和N的新兄弟。我们接着交换S和它的新父亲的颜色。所有路径仍有同样数目的黑色节点，但是现在N有了一个黑色兄弟，他的右儿子是红色的，所以我们进入了情形6。N和它的父亲都不受这个变换的影响。</p>
<p>情形6: S是黑色，S的右儿子是红色，而N是它父亲的左儿子。在这种情形下我们在N的父亲上做左旋转，这样S成为N的父亲（P）和S的右儿子的父亲。我们接着交换N的父亲和S的颜色，并使S的右儿子为黑色。子树在它的根上的仍是同样的颜色，所以性质3没有被违反。但是，N现在增加了一个黑色祖先: 要么N的父亲变成黑色，要么它是黑色而S被增加为一个黑色祖父。所以，通过N的路径都增加了一个黑色节点。<br>此时，如果一个路径不通过N，则有两种可能性:</p>
<pre><code>* 
</code></pre><p>它通过N的新兄弟。那么它以前和现在都必定通过S和N的父亲，而它们只是交换了颜色。所以路径保持了同样数目的黑色节点。</p>
<pre><code>* 
</code></pre><p>它通过N的新叔父，S的右儿子。那么它以前通过S、S的父亲和S的右儿子，但是现在只通过S，它被假定为它以前的父亲的颜色，和S的右儿子，它被从红色改变为黑色。合成效果是这个路径通过了同样数目的黑色节点。</p>
<p>在任何情况下，在这些路径上的黑色节点数目都没有改变。所以我们恢复了性质4。在示意图中的白色节点可以是红色或黑色，但是在变换前后都必须指定相同的颜色。</p>
<p>红黑树实现源码：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148<br>149<br>150<br>151<br>152<br>153<br>154<br>155<br>156<br>157<br>158<br>159<br>160<br>161<br>162<br>163<br>164<br>165<br>166<br>167<br>168<br>169<br>170<br>171<br>172<br>173<br>174<br>175<br>176<br>177<br>178<br>179<br>180<br>181<br>182<br>183<br>184<br>185<br>186<br>187<br>188<br>189<br>190<br>191<br>192<br>193<br>194<br>195<br>196<br>197<br>198<br>199<br>200<br>201<br>202<br>203<br>204<br>205<br>206<br>207<br>208<br>209<br>210<br>211<br>212<br>213<br>214<br>215<br>216<br>217<br>218<br>219<br>220<br>221<br>222<br>223<br>224<br>225<br>226<br>227<br>228<br>229<br>230<br>231<br>232<br>233<br>234<br>235<br>236<br>237<br>238<br>239<br>240<br>241<br>242<br>243<br>244<br>245<br>246<br>247<br>248<br>249<br>250<br>251<br>252<br>253<br>254<br>255<br>256<br>257<br>258<br>259<br>260<br>261<br>262<br>263<br>264<br>265<br>266<br>267<br>268<br>269<br>270<br>271<br>272<br>273<br>274<br>275<br>276<br>277<br>278<br>279<br>280<br>281<br>282<br>283<br>284<br>285<br>286<br>287<br>288<br>289<br>290<br>291<br>292<br>293<br>294<br>295<br>296<br>297<br>298<br>299<br>300<br>301<br>302<br>303<br>304<br>305<br>306<br>307<br>308<br>309<br>310<br>311<br>312<br>313<br>314<br>315<br>316<br>317<br>318<br>319<br>320<br>321<br>322<br>323<br>324<br>325<br>326<br>327<br>328<br>329<br>330<br>331<br>332<br>333</p>
<p>#define BLACK 1</p>
<p>#define RED 0</p>
<p>using namespace std;</p>
<p>class bst {<br>private:</p>
<pre><code>struct Node {
    int value;
    bool color;
    Node *leftTree, *rightTree, *parent;

    Node() {
        color = RED;
        leftTree = NULL;
        rightTree = NULL;
        parent = NULL;
        value = 0;
    }

    Node* grandparent() {
        if (parent == NULL) {
            return NULL;
        }
        return parent-&gt;parent;
    }

    Node* uncle() {
        if (grandparent() == NULL) {
            return NULL;
        }
        if (parent == grandparent()-&gt;rightTree)
            return grandparent()-&gt;leftTree;
        else
            return grandparent()-&gt;rightTree;
    }

    Node* sibling() {
        if (parent-&gt;leftTree == this)
            return parent-&gt;rightTree;
        else
            return parent-&gt;leftTree;
    }
};

void rotate_right(Node *p) {
    Node *gp = p-&gt;grandparent();
    Node *fa = p-&gt;parent;
    Node *y = p-&gt;rightTree;

    fa-&gt;leftTree = y;

    if (y != NIL)
        y-&gt;parent = fa;
    p-&gt;rightTree = fa;
    fa-&gt;parent = p;

    if (root == fa)
        root = p;
    p-&gt;parent = gp;

    if (gp != NULL) {
        if (gp-&gt;leftTree == fa)
            gp-&gt;leftTree = p;
        else
            gp-&gt;rightTree = p;
    }

}

void rotate_left(Node *p) {
    if (p-&gt;parent == NULL) {
        root = p;
        return;
    }
    Node *gp = p-&gt;grandparent();
    Node *fa = p-&gt;parent;
    Node *y = p-&gt;leftTree;

    fa-&gt;rightTree = y;

    if (y != NIL)
        y-&gt;parent = fa;
    p-&gt;leftTree = fa;
    fa-&gt;parent = p;

    if (root == fa)
        root = p;
    p-&gt;parent = gp;

    if (gp != NULL) {
        if (gp-&gt;leftTree == fa)
            gp-&gt;leftTree = p;
        else
            gp-&gt;rightTree = p;
    }
}

void inorder(Node *p) {
    if (p == NIL)
        return;

    if (p-&gt;leftTree)
        inorder(p-&gt;leftTree);

    cout &lt;&lt; p-&gt;value &lt;&lt; &quot; &quot;;

    if (p-&gt;rightTree)
        inorder(p-&gt;rightTree);
}

string outputColor(bool color) {
    return color ? &quot;BLACK&quot; : &quot;RED&quot;;
}

Node* getSmallestChild(Node *p) {
    if (p-&gt;leftTree == NIL)
        return p;
    return getSmallestChild(p-&gt;leftTree);
}

bool delete_child(Node *p, int data) {
    if (p-&gt;value &gt; data) {
        if (p-&gt;leftTree == NIL) {
            return false;
        }
        return delete_child(p-&gt;leftTree, data);
    } else if (p-&gt;value &lt; data) {
        if (p-&gt;rightTree == NIL) {
            return false;
        }
        return delete_child(p-&gt;rightTree, data);
    } else if (p-&gt;value == data) {
        if (p-&gt;rightTree == NIL) {
            delete_one_child(p);
            return true;
        }
        Node *smallest = getSmallestChild(p-&gt;rightTree);
        swap(p-&gt;value, smallest-&gt;value);
        delete_one_child(smallest);

        return true;
    }
}

void delete_one_child(Node *p) {
    Node *child = p-&gt;leftTree == NIL ? p-&gt;rightTree : p-&gt;leftTree;
    if (p-&gt;parent == NULL &amp;&amp; p-&gt;leftTree == NIL &amp;&amp; p-&gt;rightTree == NIL) {
        p = NULL;
        root = p;
        return;
    }

    if (p-&gt;parent == NULL) {
        delete  p;
        child-&gt;parent = NULL;
        root = child;
        root-&gt;color = BLACK;
        return;
    }

    if (p-&gt;parent-&gt;leftTree == p) {
        p-&gt;parent-&gt;leftTree = child;
    } else {
        p-&gt;parent-&gt;rightTree = child;
    }
    child-&gt;parent = p-&gt;parent;

    if (p-&gt;color == BLACK) {
        if (child-&gt;color == RED) {
            child-&gt;color = BLACK;
        } else
            delete_case(child);
    }

    delete p;
}

void delete_case(Node *p) {
    if (p-&gt;parent == NULL) {
        p-&gt;color = BLACK;
        return;
    }
    if (p-&gt;sibling()-&gt;color == RED) {
        p-&gt;parent-&gt;color = RED;
        p-&gt;sibling()-&gt;color = BLACK;
        if (p == p-&gt;parent-&gt;leftTree)
            rotate_left(p-&gt;sibling());
        else
            rotate_right(p-&gt;sibling());
    }
    if (p-&gt;parent-&gt;color == BLACK &amp;&amp; p-&gt;sibling()-&gt;color == BLACK
            &amp;&amp; p-&gt;sibling()-&gt;leftTree-&gt;color == BLACK &amp;&amp; p-&gt;sibling()-&gt;rightTree-&gt;color == BLACK) {
        p-&gt;sibling()-&gt;color = RED;
        delete_case(p-&gt;parent);
    } else if (p-&gt;parent-&gt;color == RED &amp;&amp; p-&gt;sibling()-&gt;color == BLACK
            &amp;&amp; p-&gt;sibling()-&gt;leftTree-&gt;color == BLACK &amp;&amp; p-&gt;sibling()-&gt;rightTree-&gt;color == BLACK) {
        p-&gt;sibling()-&gt;color = RED;
        p-&gt;parent-&gt;color = BLACK;
    } else {
        if (p-&gt;sibling()-&gt;color == BLACK) {
            if (p == p-&gt;parent-&gt;leftTree &amp;&amp; p-&gt;sibling()-&gt;leftTree-&gt;color == RED
                    &amp;&amp; p-&gt;sibling()-&gt;rightTree-&gt;color == BLACK) {
                p-&gt;sibling()-&gt;color = RED;
                p-&gt;sibling()-&gt;leftTree-&gt;color = BLACK;
                rotate_right(p-&gt;sibling()-&gt;leftTree);
            } else if (p == p-&gt;parent-&gt;rightTree &amp;&amp; p-&gt;sibling()-&gt;leftTree-&gt;color == BLACK
                    &amp;&amp; p-&gt;sibling()-&gt;rightTree-&gt;color == RED) {
                p-&gt;sibling()-&gt;color = RED;
                p-&gt;sibling()-&gt;rightTree-&gt;color = BLACK;
                rotate_left(p-&gt;sibling()-&gt;rightTree);
            }
        }
        p-&gt;sibling()-&gt;color = p-&gt;parent-&gt;color;
        p-&gt;parent-&gt;color = BLACK;
        if (p == p-&gt;parent-&gt;leftTree) {
            p-&gt;sibling()-&gt;rightTree-&gt;color = BLACK;
            rotate_left(p-&gt;sibling());
        } else {
            p-&gt;sibling()-&gt;leftTree-&gt;color = BLACK;
            rotate_right(p-&gt;sibling());
        }
    }
}

void insert(Node *p, int data) {
    if (p-&gt;value &gt;= data) {
        if (p-&gt;leftTree != NIL)
            insert(p-&gt;leftTree, data);
        else {
            Node *tmp = new Node();
            tmp-&gt;value = data;
            tmp-&gt;leftTree = tmp-&gt;rightTree = NIL;
            tmp-&gt;parent = p;
            p-&gt;leftTree = tmp;
            insert_case(tmp);
        }
    } else {
        if (p-&gt;rightTree != NIL)
            insert(p-&gt;rightTree, data);
        else {
            Node *tmp = new Node();
            tmp-&gt;value = data;
            tmp-&gt;leftTree = tmp-&gt;rightTree = NIL;
            tmp-&gt;parent = p;
            p-&gt;rightTree = tmp;
            insert_case(tmp);
        }
    }
}

void insert_case(Node *p) {
    if (p-&gt;parent == NULL) {
        root = p;
        p-&gt;color = BLACK;
        return;
    }
    if (p-&gt;parent-&gt;color == RED) {
        if (p-&gt;uncle()-&gt;color == RED) {
            p-&gt;parent-&gt;color = p-&gt;uncle()-&gt;color = BLACK;
            p-&gt;grandparent()-&gt;color = RED;
            insert_case(p-&gt;grandparent());
        } else {
            if (p-&gt;parent-&gt;rightTree == p &amp;&amp; p-&gt;grandparent()-&gt;leftTree == p-&gt;parent) {
                rotate_left(p);
                rotate_right(p);
                p-&gt;color = BLACK;
                p-&gt;leftTree-&gt;color = p-&gt;rightTree-&gt;color = RED;
            } else if (p-&gt;parent-&gt;leftTree == p &amp;&amp; p-&gt;grandparent()-&gt;rightTree == p-&gt;parent) {
                rotate_right(p);
                rotate_left(p);
                p-&gt;color = BLACK;
                p-&gt;leftTree-&gt;color = p-&gt;rightTree-&gt;color = RED;
            } else if (p-&gt;parent-&gt;leftTree == p &amp;&amp; p-&gt;grandparent()-&gt;leftTree == p-&gt;parent) {
                p-&gt;parent-&gt;color = BLACK;
                p-&gt;grandparent()-&gt;color = RED;
                rotate_right(p-&gt;parent);
            } else if (p-&gt;parent-&gt;rightTree == p &amp;&amp; p-&gt;grandparent()-&gt;rightTree == p-&gt;parent) {
                p-&gt;parent-&gt;color = BLACK;
                p-&gt;grandparent()-&gt;color = RED;
                rotate_left(p-&gt;parent);
            }
        }
    }
}

void DeleteTree(Node *p) {
    if (!p || p == NIL) {
        return;
    }
    DeleteTree(p-&gt;leftTree);
    DeleteTree(p-&gt;rightTree);
    delete p;
}
</code></pre><p>public:</p>
<pre><code>bst() {
    NIL = new Node();
    NIL-&gt;color = BLACK;
    root = NULL;
}

~bst() {
    if (root)
        DeleteTree(root);
    delete NIL;
}

void inorder() {
    if (root == NULL)
        return;
    inorder(root);
    cout &lt;&lt; endl;
}

void insert(int x) {
    if (root == NULL) {
        root = new Node();
        root-&gt;color = BLACK;
        root-&gt;leftTree = root-&gt;rightTree = NIL;
        root-&gt;value = x;
    } else {
        insert(root, x);
    }
}

bool delete_value(int data) {
    return delete_child(root, data);
}
</code></pre><p>private:<br>    Node <em>root, </em>NIL;<br>};</p>
<ol start="4">
<li>B树<br>B树也是一种用于查找的平衡树，但是它不是二叉树。<br>B树的定义：B树（B-tree）是一种树状数据结构，能够用来存储排序后的数据。这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树，可以拥有多于2个子节点。与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。这种数据结构常被应用在数据库和文件系统的实作上。<br>在B树中查找给定关键字的方法是，首先把根结点取来，在根结点所包含的关键字K1,…,Kn查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查找的关键字在Ki与Ki+1之间，Pi为指向子树根节点的指针，此时取指针Pi所指的结点继续查找，直至找到，或指针Pi为空时查找失败。<br>B树作为一种多路搜索树（并不是二叉的）：<br>1) 定义任意非叶子结点最多只有M个儿子；且M&gt;2；<br>2) 根结点的儿子数为[2, M]；<br>3) 除根结点以外的非叶子结点的儿子数为[M/2, M]；<br>4) 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）<br>5) 非叶子结点的关键字个数=指向儿子的指针个数-1；<br>6) 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；<br>7) 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；<br>8) 所有叶子结点位于同一层；<br>如下图为一个M=3的B树示例：</li>
</ol>
<p>B树创建的示意图：</p>
<ol start="5">
<li>B+树<br>B+树是B树的变体，也是一种多路搜索树：<br>1) 其定义基本与B-树相同，除了：<br>2) 非叶子结点的子树指针与关键字个数相同；<br>3) 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；<br>4) 为所有叶子结点增加一个链指针；<br>5) 所有关键字都在叶子结点出现；<br>下图为M=3的B+树的示意图：</li>
</ol>
<p>B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；<br>B+的性质：<br>1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；<br>2.不可能在非叶子结点命中；<br>3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；<br>4.更适合文件索引系统。<br>下面为一个B+树创建的示意图：</p>
<ol start="6">
<li>B<em>树<br>B</em>树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针，将结点的最低利用率从1/2提高到2/3。<br>B*树如下图所示：</li>
</ol>
<p>B<em>树定义了非叶子结点关键字个数至少为(2/3)</em>M，即块的最低使用率为2/3（代替B+树的1/2）；<br>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；<br>B<em>树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；<br>所以，B</em>树分配新结点的概率比B+树要低，空间使用率更高。7. Trie树<br>Tire树称为字典树，又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。<br>Tire树的三个基本性质：<br>1) 根节点不包含字符，除根节点外每一个节点都只包含一个字符；<br>2) 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；<br>3) 每个节点的所有子节点包含的字符都不相同。<br>Tire树的应用：<br>1) 串的快速检索<br>给出N个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。在这道题中，我们可以用数组枚举，用哈希，用字典树，先把熟词建一棵树，然后读入文章进行比较，这种方法效率是比较高的。<br>2) “串”排序<br>给定N个互不相同的仅由一个单词构成的英文名，让你将他们按字典序从小到大输出。用字典树进行排序，采用数组的方式创建字典树，这棵树的每个结点的所有儿子很显然地按照其字母大小排序。对这棵树进行先序遍历即可。<br>3) 最长公共前缀<br>对所有串建立字典树，对于两个串的最长公共前缀的长度即他们所在的结点的公共祖先个数，于是，问题就转化为求公共祖先的问题。<br> 1 赞  12 收藏  3 评论</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wadezhx.github.io/2018/12/06/数据结构中各种树/" data-id="cjpcn5hr2001cjkrq65yycrwx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-经典排序算法总结与实现" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/经典排序算法总结与实现/" class="article-date">
  <time datetime="2018-12-06T02:46:37.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/经典排序算法总结与实现/">经典排序算法总结与实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="经典排序算法总结与实现"><a href="#经典排序算法总结与实现" class="headerlink" title="经典排序算法总结与实现"></a>经典排序算法总结与实现</h1><p>by WuChong, wuchong.me</p>
<p>经典排序算法在面试中占有很大的比重，也是基础，为了未雨绸缪，在寒假里整理并用Python实现了七大经典排序算法，包括冒泡排序，插入排序，选择排序，希尔排序，归并排序，快速排序，堆排序。希望能帮助到有需要的同学。之所以用Python实现，主要是因为它更接近伪代码，能用更少的代码实现算法，更利于理解。<br>本篇博客所有排序实现均默认从小到大。一、冒泡排序 BubbleSort<br>介绍：<br>冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。<br>步骤：</p>
<pre><code>1. 
</code></pre><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
<pre><code>2. 
</code></pre><p>对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。</p>
<pre><code>3. 
</code></pre><p>针对所有的元素重复以上的步骤，除了最后一个。</p>
<pre><code>4. 
</code></pre><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<p>源代码：(python实现)</p>
<p>def bubble_sort(arry):<br>n = len(arry) #获得数组的长度<br>for i in range(n):<br>for j in range(1,n-i):<br>if arry[j-1] &gt; arry[j] : #如果前者比后者大<br>arry[j-1],arry[j] = arry[j],arry[j-1] #则交换两者<br>return arry<br>不过针对上述代码还有两种优化方案。</p>
<p>优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。用一个标记记录这个状态即可。<br>优化2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。<br>这两种优化方案的实现可以详见这里。二、选择排序 SelectionSort<br>介绍：<br>选择排序无疑是最简单直观的排序。它的工作原理如下。<br>步骤：</p>
<pre><code>1. 
</code></pre><p>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p>
<pre><code>2. 
</code></pre><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>
<pre><code>3. 
</code></pre><p>以此类推，直到所有元素均排序完毕。</p>
<p>源代码：(python实现)</p>
<p>def select_sort(ary):<br>n = len(ary)<br>for i in range(0,n):<br>min = i #最小元素下标标记<br>for j in range(i+1,n):<br>if ary[j] &lt; ary[min] :<br>min = j #找到最小值的下标<br>ary[min],ary[i] = ary[i],ary[min] #交换两者<br>return ary三、插入排序 InsertionSort<br>介绍：<br>插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br>步骤：</p>
<pre><code>1. 
</code></pre><p>从第一个元素开始，该元素可以认为已经被排序</p>
<pre><code>2. 
</code></pre><p>取出下一个元素，在已经排序的元素序列中从后向前扫描</p>
<pre><code>3. 
</code></pre><p>如果被扫描的元素（已排序）大于新元素，将该元素后移一位</p>
<pre><code>4. 
</code></pre><p>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</p>
<pre><code>5. 
</code></pre><p>将新元素插入到该位置后</p>
<pre><code>6. 
</code></pre><p>重复步骤2~5</p>
<p>排序演示：</p>
<p>源代码：(python实现)四、希尔排序 ShellSort<br>介绍：<br>希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。<br>希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。<br>例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p>
<p>13 14 94 33 82<br>25 59 94 65 23<br>45 27 73 25 39<br>10</p>
<p>然后我们对每列进行排序：</p>
<p>10 14 73 25 23<br>13 27 94 33 39<br>25 59 94 65 82<br>45</p>
<p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]。这时10已经移至正确位置了，然后再以3为步长进行排序：</p>
<p>10 14 73<br>25 23 13<br>27 94 33<br>39 25 59<br>94 65 82<br>45</p>
<p>排序之后变为：</p>
<p>10 14 13<br>25 23 33<br>27 25 59<br>39 65 73<br>45 94 82<br>94</p>
<p>最后以1步长进行排序（此时就是简单的插入排序了）。<br>源代码：(python实现)</p>
<p>def shell_sort(ary):<br>n = len(ary)<br>gap = round(n/2) #初始步长 , 用round四舍五入取整<br>while gap &gt; 0 :<br>for i in range(gap,n): #每一列进行插入排序 , 从gap 到 n-1<br>temp = ary[i]<br>j = i<br>while ( j &gt;= gap and ary[j-gap] &gt; temp ): #插入排序<br>ary[j] = ary[j-gap]<br>j = j - gap<br>ary[j] = temp<br>gap = round(gap/2) #重新设置步长<br>return ary<br>上面源码的步长的选择是从n/2开始，每次再减半，直至为0。步长的选择直接决定了希尔排序的复杂度。在维基百科上有对于步长串行的详细介绍。五、归并排序 MergeSort<br>介绍：<br>归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。<br>先考虑合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。<br>再考虑递归分解，基本思路是将数组分解成left和right，如果这两个数组内部数据是有序的，那么就可以用上面合并数组的方法将这两个数组合并排序。如何让这两个数组内部是有序的？可以再二分，直至分解出的小组只含有一个元素时为止，此时认为该小组内部已有序。然后合并排序相邻二个小组即可。<br>排序演示：<br>源代码：(python实现)</p>
<p>def merge_sort(ary):<br>if len(ary) &lt;= 1 : return ary<br>num = int(len(ary)/2) #二分分解<br>left = merge_sort(ary[:num])<br>right = merge_sort(ary[num:])<br>return merge(left,right) #合并数组def merge(left,right):<br>‘’’合并操作，<br>将两个有序数组left[]和right[]合并成一个大的有序数组’’’<br>l,r = 0,0 #left与right数组的下标指针<br>result = []<br>while l&lt;len(left) and r&lt;len(right) :<br>if left[l] &lt; right[r]:<br>result.append(left[l])<br>l += 1<br>else:<br>result.append(right[r])<br>r += 1<br>result += left[l:]<br>result += right[r:]<br>return result六、快速排序 QuickSort</p>
<p>介绍：<br>快速排序通常明显比同为Ο(n log n)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。<br>步骤：</p>
<pre><code>1. 
</code></pre><p>从数列中挑出一个元素作为基准数。</p>
<pre><code>2. 
</code></pre><p>分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。</p>
<pre><code>3. 
</code></pre><p>再对左右区间递归执行第二步，直至各区间只有一个数。</p>
<p>排序演示：<br>源代码：(python实现)</p>
<p>def quick_sort(ary):<br>return qsort(ary,0,len(ary)-1)def qsort(ary,left,right):</p>
<p>#快排函数，ary为待排序数组，left为待排序的左边界，right为右边界<br>if left &gt;= right : return ary<br>key = ary[left] #取最左边的为基准数<br>lp = left #左指针<br>rp = right #右指针<br>while lp &lt; rp :<br>while ary[rp] &gt;= key and lp &lt; rp :<br>rp -= 1<br>while ary[lp] &lt;= key and lp &lt; rp :<br>lp += 1<br>ary[lp],ary[rp] = ary[rp],ary[lp]<br>ary[left],ary[lp] = ary[lp],ary[left]<br>qsort(ary,left,lp-1)<br>qsort(ary,rp+1,right)<br>return ary七、堆排序 HeapSort<br>介绍：<br>堆排序在 top K 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。二叉堆是一个近似完全二叉树 。<br>二叉堆具有以下性质：</p>
<pre><code>1. 
</code></pre><p>父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。</p>
<pre><code>2. 
</code></pre><p>每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。</p>
<p>步骤：</p>
<pre><code>1. 
</code></pre><p>构造最大堆（Build_Max_Heap）：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆。于是只要从n/2-1开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。</p>
<pre><code>2. 
</code></pre><p>堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[n-1]交换，再对heap[0…n-2]做最大堆调整。第二次将heap[0]与heap[n-2]交换，再对heap[0…n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。</p>
<pre><code>3. 
</code></pre><p>最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点 。</p>
<p>排序演示：<br>源代码：(python实现)</p>
<p>def heap_sort(ary) :<br>n = len(ary)<br>first = int(n/2-1) #最后一个非叶子节点<br>for start in range(first,-1,-1) : #构造大根堆<br>max_heapify(ary,start,n-1)<br>for end in range(n-1,0,-1): #堆排，将大根堆转换成有序数组<br>ary[end],ary[0] = ary[0],ary[end]<br>max_heapify(ary,0,end-1)<br>return ary</p>
<p>#最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点</p>
<p>#start为当前需要调整最大堆的位置，end为调整边界<br>def max_heapify(ary,start,end):<br>root = start<br>while True :<br>child = root*2 +1 #调整节点的子节点<br>if child &gt; end : break child = child+1 #取较大的子节点<br>if ary[root] &lt; ary[child] : #较大的子节点成为父节点<br>ary[root],ary[child] = ary[child],ary[root] #交换<br>root = child<br>else :<br>break总结<br>下面为七种经典排序算法指标对比情况：<br>参考资料<br>注：本文所有源代码已共享到GitHub。<br>-EOF-<br>Original Page: <a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/" target="_blank" rel="noopener">http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wadezhx.github.io/2018/12/06/经典排序算法总结与实现/" data-id="cjpcn5hqk001ajkrq1ciop8wf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-1 - 副本 (4)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/05/1 - 副本 (4)/" class="article-date">
  <time datetime="2018-12-05T13:06:25.000Z" itemprop="datePublished">2018-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/05/1 - 副本 (4)/">前端学习 1-7</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="文本输入框、密码输入框"><a href="#文本输入框、密码输入框" class="headerlink" title="文本输入框、密码输入框"></a>文本输入框、密码输入框</h1><p>当用户要在表单中键入字母、数字等内容时，就会用到文本输入框。文本框也可以转化为密码输入框。</p>
<p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">   &lt;input type=&quot;text/password&quot; name=&quot;名称&quot; value=&quot;文本&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></p>
<p>1、type：</p>
<p>   当type=”text”时，输入框为文本输入框;</p>
<p>   当type=”password”时, 输入框为密码输入框。</p>
<p>2、name：为文本框命名，以备后台程序ASP 、PHP使用。</p>
<p>3、value：为文本输入框设置默认值。(一般起到提示作用)</p>
<p>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  姓名：</span><br><span class="line">  &lt;input type=&quot;text&quot; name=&quot;myName&quot;&gt;</span><br><span class="line">  &lt;br/&gt;</span><br><span class="line">  密码：</span><br><span class="line">  &lt;input type=&quot;password&quot; name=&quot;pass&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></p>
<p>在浏览器中显示的结果：<br>&lt;!DOCTYPE HTML&gt;</p>
<html><br><head><meta name="generator" content="Hexo 3.8.0"><br><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><br><title>文本输入框、密码输入框</title><br></head><br><body><br><form method="post" action="save.php"><br>    账户:<br>    <input type="text" name="myName"><br>    <br><br>    密码:<br>    <input type="password" name="pass"><br></form><br></body><br></html>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://wadezhx.github.io/2018/12/05/1 - 副本 (4)/" data-id="cjpcn5hox0001jkrqk8u28wup" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java学习第五次笔记" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/05/java学习第五次笔记/" class="article-date">
  <time datetime="2018-12-05T12:28:32.000Z" itemprop="datePublished">2018-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/05/java学习第五次笔记/">java学习第五次笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="wade-zhx"><a href="#wade-zhx" class="headerlink" title="wade.zhx"></a>wade.zhx</h1><h5 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h5><p><img src="en-resource://database/7241:1" alt="6d408ddd2a3f5b00edd918de34fc52fa.png"></p>
<blockquote>
<h5 id="整数运算："><a href="#整数运算：" class="headerlink" title="整数运算：　"></a>整数运算：　</h5><ol>
<li>如果两个操作数有一个为Long, 则结果也为long。　</li>
<li>没有long时，结果为int。即使操作数全为short，byte，结果也是int。　　<h5 id="浮点运算："><a href="#浮点运算：" class="headerlink" title="浮点运算：　　"></a>浮点运算：　　</h5></li>
<li>如果两个操作数有一个为double，则结果为double。　</li>
<li>只有两个操作数都是float，则结果才为float。　　<h5 id="取模运算："><a href="#取模运算：" class="headerlink" title="取模运算：　　"></a>取模运算：　　</h5>1.其操作数可以为浮点数,一般使用整数，结果是“余数”，<br><strong>“余数”符号和左边操作数相同，</strong><br>如：<strong>7%3=1，-7%3=-1，7%-3=1。</strong></li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(-9%5);</span><br><span class="line">    </span><br><span class="line">-4</span><br></pre></td></tr></table></figure>
<p>算术运算符中++，–属于一元运算符，该类运算符只需要一个操作数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        byte &lt;u&gt;a1&lt;/u&gt; = 1;</span><br><span class="line"></span><br><span class="line">        int b1 = 2;</span><br><span class="line"></span><br><span class="line">        // byte c = a+b;</span><br><span class="line"></span><br><span class="line">        long b2 = 3;</span><br><span class="line"></span><br><span class="line">        // &lt;u&gt;int&lt;/u&gt; c2 = b2+b; 因为不接受into &lt;u&gt;int&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        float f1 = 3.14f;</span><br><span class="line"></span><br><span class="line">        double &lt;u&gt;d&lt;/u&gt; = b1+b2;//</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        float &lt;u&gt;f2&lt;/u&gt; = f1+6.2f;//浮点型默认double</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        System.out.println(-9%5);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        //测试自增自减</span><br><span class="line"></span><br><span class="line">        int a = 3;</span><br><span class="line"></span><br><span class="line">        int b = a++;//先赋值后++</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;a=&quot;+a+&quot;\nb=&quot;+b);</span><br><span class="line"></span><br><span class="line">        //a=4</span><br><span class="line"></span><br><span class="line">        //b=3</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">         a = 3;</span><br><span class="line"></span><br><span class="line">         b = ++a; //先++后赋值</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;a=&quot;+a+&quot;\nb=&quot;+b);</span><br><span class="line"></span><br><span class="line">        //a=4</span><br><span class="line"></span><br><span class="line">        //b=4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wadezhx.github.io/2018/12/05/java学习第五次笔记/" data-id="cjpcn5hpy000rjkrq3eqcr9yb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-在N个不相等的整数中找出最大的第K个数(NK)" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/04/在N个不相等的整数中找出最大的第K个数(NK)/" class="article-date">
  <time datetime="2018-12-04T02:46:37.000Z" itemprop="datePublished">2018-12-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/04/在N个不相等的整数中找出最大的第K个数(NK)/">在N个不相等的整数中找出最大的第K个数(N&gt;K)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="题目：在N个不相等的整数中找出最大的第K个数-N-gt-K-。"><a href="#题目：在N个不相等的整数中找出最大的第K个数-N-gt-K-。" class="headerlink" title="题目：在N个不相等的整数中找出最大的第K个数(N&gt;K)。"></a>题目：在N个不相等的整数中找出最大的第K个数(N&gt;K)。</h1><p>思路：首先，用前K个整数构造容量为K的最小堆。然后，将后N-K个整数依次与堆顶元素比较，若比堆顶元素大，则替换堆顶元素并调整最小堆结构；反之，则继续比较下一个整数。最终，最小堆存储最大的k个数，其堆顶元素即为所求。<br>代码：</p>
<p>1 #include <cstdio><br>2 #include <cstdlib><br>3 #include <cmath><br>4 #include <ctime><br>5 #include <iostream><br>6<br>7 #define N 90<br>8 #define K 13<br>9<br>10<br>11 void HeapAdjust (int <em>heap, int beginidx, int endidx);<br>12 void HeapConstruct (int </em>heap);<br>13<br>14 void SetData (int <em>data);<br>15 void ShowData (int </em>data);<br>16<br>17 int main (int argc, char *<em>argv)<br>18 {<br>19 int i;<br>20 int h[N + 1];<br>21<br>22 SetData(h);<br>23 ShowData(h);<br>24<br>25 HeapConstruct(h);<br>26 for (i = K + 1; i &lt;= N; i++)<br>27 {<br>28 if (h[i] &gt; h[1])<br>29 {<br>30 h[1] = h[i];<br>31 HeapAdjust(h, 1, K);<br>32 }<br>33 }<br>34<br>35 printf(“The Kth biggest number: %d\n”, h[1]);<br>36 return 0;<br>37 }<br>38<br>39 void HeapAdjust (int </em>heap, int beginidx, int endidx)<br>40 {<br>41 int &amp;current = beginidx;<br>42 int tmp, left, right, data = heap[current];<br>43<br>44 while (left = (current &lt;&lt; 1), left &lt;= endidx)<br>45 {<br>46 right = left | 1;<br>47 if ((left == endidx) || (heap[left] &lt; heap[right]))<br>48 {<br>49 tmp = left;<br>50 }<br>51 else<br>52 {<br>53 tmp = right;<br>54 }<br>55 if (data &gt; heap[tmp])<br>56 {<br>57 heap[current] = heap[tmp];<br>58 current = tmp;<br>59 }<br>60 else<br>61 {<br>62 break;<br>63 }<br>64 }<br>65 heap[current] = data;<br>66 }<br>67<br>68 void HeapConstruct (int <em>heap)<br>69 {<br>70 int i;<br>71 for (i = K/2; i &gt; 0; i–)<br>72 {<br>73 HeapAdjust(heap, i, K);<br>74 }<br>75 }<br>76<br>77 void SetData (int </em>data)<br>78 {<br>79 bool <em>bdata = new bool[N + 1];<br>80 memset(bdata, false, N + 1);<br>81 srand(time(NULL));<br>82 data[0] = -1;<br>83 for (int i = 1; i &lt;= N; i++)<br>84 {<br>85 data[i] = rand() % N + 1;<br>86 while (bdata[data[i]])<br>87 {<br>88 data[i] = rand() % N + 1;<br>89 }<br>90 bdata[data[i]] = true;<br>91 }<br>92 delete []bdata;<br>93 }<br>94<br>95 void ShowData (int </em>data)<br>96 {<br>97 for (int i = 1; i &lt;= N; i++)<br>98 {<br>99 printf(“%02d “, data[i]);<br>100 }<br>101 puts(“”);<br>102 }</iostream></ctime></cmath></cstdlib></cstdio></p>
<p>时间复杂度：O((N-K+1)<em>K</em>lgK).</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wadezhx.github.io/2018/12/04/在N个不相等的整数中找出最大的第K个数(NK)/" data-id="cjpcn5hq50013jkrqrxj74r58" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Web Service" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/04/Web Service/" class="article-date">
  <time datetime="2018-12-04T02:23:45.000Z" itemprop="datePublished">2018-12-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/04/Web Service/">Web Service</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、环境配置：MyEclipse7.0<br>JDK1.6<br>二、创建Web Service Project<br>1）在MyEclipse中选择File—&gt;New—&gt;Other，选择Web Service Project</p>
<p>2）Project Name：WebServiceServer，Framework：XFire，其他选项默认</p>
<p>3）Next，这一步保持默认值<br>4）Project Library选择，选择XFire 1.2 Core Libraries</p>
<p>5）Finish，创建成功后看到的工程目录如下：</p>
<p>6）完成以上5步后，查看WebRoot/WEB-INF/web.xml</p>
<p>这里指明了当遇到/services/*请求时，将选用XFireConfigurableServlet来处理  </p>
<p>三、创建Web Service Code<br>1）通过File—&gt;New—&gt;Other—&gt;Web Services—&gt;Web Service wizard创建JAVA CODE</p>
<p>2）选择通过JAVA CLASS创建Web Service</p>
<p>3）创建HelloWebService.java，通过New创建com.service package，向导将为工程自动创建对应的接口类与实现类</p>
<p>创建成功后查看WebServices/services.xml，发现配置文件多了以下内容：</p>
<p>4）修改HelloWebServiceImpl.java<br>package com.service;<br>//Generated by meteorWJ</p>
<p>public class HelloWebServiceImpl implements IHelloWebService {</p>
<p>public String example(String message) {<br>return getAuthor()+”,”+message;<br>}<br>private String getAuthor(){<br>return “meteorWJ”;<br>}</p>
<p>}</p>
<p>四、部署并测试WebSericeServer</p>
<p>1）部署WebServiceServer</p>
<p>在部署向导中选择项目、服务器</p>
<p>2）启动服务器</p>
<p>3）测试WebService<br>MyEclipse提供了一个Web Service Explorer来测试Web Service</p>
<p>选择列表中的Launch SOAP Web Services Explorer<br>4）选择WSDL模式</p>
<p>5）在Explorer中选择WSDL Main，在右边的URL中输入<br><a href="http://localhost:9090/WebServiceServer/services/HelloWebService?WSDL，单击&quot;Go&quot;" target="_blank" rel="noopener">http://localhost:9090/WebServiceServer/services/HelloWebService?WSDL，单击&quot;Go&quot;</a><br>其中9090是服务器端口号，services在之前的web.xml中指定<br>若在Status中显示成功打开WSDL文件则测试成功</p>
<p>五、创建WebService客户端<br>经过以上几步，我们已经成功发布了一个WebService，现在需要创建一个客户端来调用该服务<br>1）创建Java Project：WebServiceClient<br>2）引入MyEclipse Libraries<br>右键WebServiceClient—&gt;Build Path—&gt;Add Libraries</p>
<p>选择XFire 1.2 HTTP Client Libraries</p>
<p>3）创建HelloWebService.java<br>在src目录下创建com.client.HelloWebService.java<br>package com.client;</p>
<p>import java.net.URL;<br>import org.codehaus.xfire.client.Client;</p>
<p>public class HelloWebService {<br>public static void main(String[] args) throws Exception<br>{<br>Client client = new Client(new URL(“<a href="http://localhost:9090/WebServiceServer/services/HelloWebService?wsdl&quot;))" target="_blank" rel="noopener">http://localhost:9090/WebServiceServer/services/HelloWebService?wsdl&quot;))</a>;<br>Object[] results = client.invoke(“example”, new Object[] {“hello”});<br>System.out.println((String) results[0]);<br>}<br>}</p>
<p>4）在确认服务器启动的情况下，运行HelloWebService.java<br>右键点击Run As&gt;Java Application，在控制台中看到如下输出</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wadezhx.github.io/2018/12/04/Web Service/" data-id="cjpcn5hpn000fjkrqmmeynep4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web-Service/">Web Service</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web-Service/">Web Service</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oracle/">oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/吃苦/">吃苦</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Web-Service/" style="font-size: 10px;">Web Service</a> <a href="/tags/java/" style="font-size: 16.67px;">java</a> <a href="/tags/oracle/" style="font-size: 10px;">oracle</a> <a href="/tags/前端/" style="font-size: 20px;">前端</a> <a href="/tags/吃苦/" style="font-size: 10px;">吃苦</a> <a href="/tags/算法/" style="font-size: 13.33px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/12/06/新建文本文档/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/12/06/1 - 副本 (2)/">前端学习 1-9</a>
          </li>
        
          <li>
            <a href="/2018/12/06/1 - 副本 (3)/">前端学习 1-8</a>
          </li>
        
          <li>
            <a href="/2018/12/06/分布式数据库/">分布式数据库</a>
          </li>
        
          <li>
            <a href="/2018/12/06/数据结构中各种树/">数据结构中各种树</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 wadezhx<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>